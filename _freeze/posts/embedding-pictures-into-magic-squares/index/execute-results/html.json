{
  "hash": "67b75cf43b34d69b4e88330df88410c6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Embedding Pictures into Magic Squares\"\ndescription: \"How to construct magic squares from any image using Python.\"\nauthor: \"Aswin van Woudenberg\"\ndate: \"2025-06-03\"\ncategories: [programming, python, art, mathematics]\ntoc: true\n---\n\n\nA magic square is a square grid of numbers in which all numbers are distinct and each row, column and diagonal adds up to the same constant. \n\nMany algorithms have been developed to generate magic squares, and the website [https://www.magischvierkant.com](https://www.magischvierkant.com) showcases quite a few of them. While exploring the site, I came across a cool concept: [embedding pictures into magic squares](https://www.magischvierkant.com/specials-eng/photo-magic-square/). \n\nHere's one of the examples they showed:\n\n![A picture of Benjamin Franklin inside a magic square](franklin1x.jpg)\n\nThe center 32x32 square contains a picture of Benjamin Franklin within a larger 128x128 magic square. The numbers in the 32×32 center range from 1 (white) to 1024 (black), and the surrounding space is filled with numbers (1025 to 16384) that complete the magic square. You might want to zoom in on the picture above to see the numbers.\n\nThis magic square was made by Ot Ottenheim, a fellow Dutchman, who has created a variety of magic squares. You can find his blog [here](https://magicsquareorder4x4.blogspot.com/).\n\nNo details were provided on how to create these magic squares, but reverse engineering the process wasn't too hard. Read on to see what I learned and how you can embed your own pictures into magic squares.\n\n## Clarifying some jargon\n\nBefore we go into understanding how to create magic squares containing a picture, let's further clarify some terms. At the same time, we'll write code that will help us visualize, understand, and check our magic squares.\n\nAs defined above, a **magic square** is a square grid filled with distinct numbers. It typically contains consecutive integers starting from 1. Its fundamental property is that the sum of the numbers in each row, each column, and both main diagonals is identical. This consistent sum is known as the **magic constant**.\n\nFor instance, consider this 3×3 square:\n\n::: {#86299381 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nms3 = np.array([\n    [8, 1, 6], \n    [3, 5, 7], \n    [4, 9, 2]\n])\n```\n:::\n\n\nThe following code prints a magic square in a more readable format:\n\n::: {#842fc7f9 .cell execution_count=2}\n``` {.python .cell-code}\nfrom IPython.core.display import HTML\n\ndef print_square(m):\n    table = \"<table border='1' cellspacing='0' cellpadding='10'>\"\n    for r in m:\n        table += \"<tr>\"\n        for c in r:\n            table += \"<td>\" + str(c) + \"</td>\"\n        table += \"</tr>\"\n    table += \"</table>\"\n    display(HTML(table))\n```\n:::\n\n\n::: {#339ef45a .cell execution_count=3}\n``` {.python .cell-code}\nprint_square(ms3)\n```\n\n::: {.cell-output .cell-output-display html-table-processing=none}\n```{=html}\n<table border='1' cellspacing='0' cellpadding='10'><tr><td>8</td><td>1</td><td>6</td></tr><tr><td>3</td><td>5</td><td>7</td></tr><tr><td>4</td><td>9</td><td>2</td></tr></table>\n```\n:::\n:::\n\n\nHere, every row (8+1+6=15, 3+5+7=15, 4+9+2=15), every column (8+3+4=15, 1+5+9=15, 6+7+2=15), and both main diagonals (8+5+2=15, 6+5+4=15) sum to 15 (the magic constant). This type is generally called an **ordinary magic square**.\n\nIf an ordinary magic square strictly uses consecutive integers from $1$ up to $N^2$ (where N is the side length of the square, e.g., 1 to 9 for a 3×3 square), it is then classified as a **normal magic square**. The 3×3 example provided above is therefor a normal magic square.\n\nA **semimagic square** is a less stringent variation where only the sums of the numbers in each row and each column are equal to the magic constant; the main diagonals do not necessarily sum to this constant. While standard 3×3 examples often turn out to be ordinary, larger semimagic squares can exist where this diagonal property is intentionally absent.\n\nLet's write some functions to check for these properties:\n\n::: {#f2db4da8 .cell execution_count=4}\n``` {.python .cell-code}\ndef is_semimagic(m, c=None):\n    row_sums = np.sum(m, axis=1)\n    col_sums = np.sum(m, axis=0)\n    mc = row_sums[0] if not c else c\n    return np.all(row_sums == mc) and np.all(col_sums == mc)\n```\n:::\n\n\n::: {#ed18c900 .cell execution_count=5}\n``` {.python .cell-code}\ndef is_magic(m, c=None):\n    diag_sum1 = np.sum(np.diag(m))  # sum of first diagonal  \n    diag_sum2 = np.sum(np.diag(np.fliplr(m)))  # sum of second diagonal\n    mc = diag_sum1 if not c else c\n    return is_semimagic(m, mc) and diag_sum1 == mc and diag_sum2 == mc\n```\n:::\n\n\n::: {#f61553fe .cell execution_count=6}\n``` {.python .cell-code}\ndef is_normal(m):\n    n = m.shape[0]\n    unique_values = np.unique(m)\n    return np.min(unique_values) == 1 and np.max(unique_values) == n**2 and len(unique_values) == n**2\n```\n:::\n\n\nThese will come in handy later when we create our own magic squares. For now, let's verify that our 3×3 example is indeed a normal magic square:\n\n::: {#ba5b9c89 .cell execution_count=7}\n``` {.python .cell-code}\nis_magic(ms3) and is_normal(ms3)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nTrue\n```\n:::\n:::\n\n\nMoving on to more complex types, a **panmagic square** (also known as a **diabolic** or **pandiagonal magic square**) builds upon the ordinary definition. In addition to the main rows, columns, and diagonals, all **broken diagonals** also sum to the magic constant. A broken diagonal forms by starting at a cell, moving diagonally to an edge, and then wrapping around to continue from the opposite edge.\n\nConsider the following 4×4 panmagic square, with a magic constant of 34:\n\n::: {#d11f6c23 .cell execution_count=8}\n``` {.python .cell-code}\nms4 = np.array([\n    [ 1,  8, 10, 15],\n    [12, 13,  3,  6],\n    [ 7,  2, 16,  9],\n    [14, 11,  5,  4]\n])\n\nprint_square(ms4)\n```\n\n::: {.cell-output .cell-output-display html-table-processing=none}\n```{=html}\n<table border='1' cellspacing='0' cellpadding='10'><tr><td>1</td><td>8</td><td>10</td><td>15</td></tr><tr><td>12</td><td>13</td><td>3</td><td>6</td></tr><tr><td>7</td><td>2</td><td>16</td><td>9</td></tr><tr><td>14</td><td>11</td><td>5</td><td>4</td></tr></table>\n```\n:::\n:::\n\n\nHere, not only do rows, columns, and main diagonals sum to 34, but so do diagonals like (12+2+5+15) and (14+8+3+9). Just for fun, let's write a function to check if a square is panmagic and test it on our example:\n\n::: {#3f89c533 .cell execution_count=9}\n``` {.python .cell-code}\ndef is_panmagic(m):\n    n = m.shape[0]\n    sums = []\n    # Top-left to bottom-right\n    for offset in range(n):\n        s = 0\n        for i in range(n):\n            j = (i + offset) % n\n            s += m[i, j]\n        sums.append(s)\n    # Top-right to bottom-left\n    for offset in range(n):\n        s = 0\n        for i in range(n):\n            j = (offset - i) % n\n            s += m[i, j]\n        sums.append(s)\n\n    mc = sums[0]  # Magic constant from the first sum\n    return np.all(sums == mc) and is_magic(m, mc)\n```\n:::\n\n\n::: {#7ea564ed .cell execution_count=10}\n``` {.python .cell-code}\nis_panmagic(ms4)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nTrue\n```\n:::\n:::\n\n\nA property of panmagic squares is that if you move the first column(s) to the end, the resulting square remains panmagic. In the same way, if you move the first row(s) from the top to the bottom, the square also remains panmagic. This property is not true for ordinary magic squares.\n\nWe can demonstrate this property with our 4×4 panmagic square.\n\n::: {#cc4b225e .cell execution_count=11}\n``` {.python .cell-code}\nms4_reordered = np.hstack((ms4[:, 1:], ms4[:, [0]]))\nprint_square(ms4_reordered)\n```\n\n::: {.cell-output .cell-output-display html-table-processing=none}\n```{=html}\n<table border='1' cellspacing='0' cellpadding='10'><tr><td>8</td><td>10</td><td>15</td><td>1</td></tr><tr><td>13</td><td>3</td><td>6</td><td>12</td></tr><tr><td>2</td><td>16</td><td>9</td><td>7</td></tr><tr><td>11</td><td>5</td><td>4</td><td>14</td></tr></table>\n```\n:::\n:::\n\n\nAfter moving the first column to the end, we get a new square that is still panmagic.\n\n::: {#ef3ed425 .cell execution_count=12}\n``` {.python .cell-code}\nis_panmagic(ms4_reordered)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nTrue\n```\n:::\n:::\n\n\n## Exploring the structure of magic squares that contain pictures\n\nLet's look at the structure of the magic square that contains a picture. From the page where I found the Benjamin Franklin example, we can also download the numbers that make up the square as a file. Let's start by loading [this file](franklin.csv) into a NumPy array.\n\n::: {#5348c44d .cell execution_count=13}\n``` {.python .cell-code}\nfranklin = np.genfromtxt('franklin.csv', delimiter=';', dtype=int)\n```\n:::\n\n\nThe following function plots the magic square as a heatmap, which gives us a visual representation of the numbers in the square.\n\n::: {#09c8b13e .cell execution_count=14}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\ndef plot_square(m, center_only=True, show_values=True, figsize=(4, 4)):\n    plt.figure(figsize=figsize)\n\n    nrows, ncols = m.shape\n    block_size = nrows // 4\n\n    if center_only:\n        c0, c1 = 3 * (block_size // 2), 5 * (block_size // 2)\n        block = m[c0:c1, c0:c1]\n        plt.imshow(block, cmap='grey_r', interpolation='nearest', extent=(c0 - 0.5, c1 - 0.5, c1 - 0.5, c0 - 0.5))\n    else:\n        plt.imshow(m, cmap='grey_r', interpolation='nearest')\n    \n    plt.xlim(-0.5, ncols)\n    plt.ylim(nrows, -0.5)\n    plt.axis('off')\n\n    if show_values:        \n        ax = plt.gca()\n        fig = plt.gcf()\n        bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n        width, height = bbox.width * fig.dpi, bbox.height * fig.dpi\n        cell_width = width / ncols\n        n_digits = len(str(abs(ncols * nrows)))\n\n        for (j, i), label in np.ndenumerate(m):\n            plt.text(i, j, label, ha='center', va='center', color='black', fontsize=cell_width / n_digits)\n\n    plt.show()\n```\n:::\n\n\nBy default it shows the numbers in the square, and only shows the center 32x32 square in the heatmap.\n\n::: {#5f0dbf48 .cell execution_count=15}\n``` {.python .cell-code}\nplot_square(franklin, figsize=(10, 10))\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-16-output-1.png){width=758 height=758}\n:::\n:::\n\n\nLet's verify that this is indeed a magic square by checking the properties using the functions we defined above.\n\n::: {#336a8916 .cell execution_count=16}\n``` {.python .cell-code}\nis_magic(franklin) and is_panmagic(franklin) and is_normal(franklin)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nTrue\n```\n:::\n:::\n\n\nWe can see that the square is not only magic, but also panmagic!\n\nNote that the center 32x32 square isn't a magic square.\n\n::: {#61d618ec .cell execution_count=17}\n``` {.python .cell-code}\nis_magic(franklin[48:80, 48:80])\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nFalse\n```\n:::\n:::\n\n\nThe numbers in the center square do range from 1 to 1024.\n\n::: {#2e80229a .cell execution_count=18}\n``` {.python .cell-code}\nis_normal(franklin[48:80, 48:80])\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nTrue\n```\n:::\n:::\n\n\nBy looking at the entire magic square as a heatmap, we can get a better understanding of how the magic square is structured.\n\n::: {#09a7d33a .cell execution_count=19}\n``` {.python .cell-code}\nplot_square(franklin, center_only=False, figsize=(10, 10))\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-20-output-1.png){width=758 height=758}\n:::\n:::\n\n\nFranklin's picture seems to not only be contained in the center 32x32 square, but repeats itself in the surrounding area. Furthermore, half of the pictures appear to be inverted.\n\nThe key to understanding how to create these was actually [another example](https://magicsquareorder4x4.blogspot.com/2020/03/franklin-in-magic-square.html) from Ot Ottenheim's blog.\n\n![Another magic square featuring Benjamin Franklin](franklin16x.jpg)\n\nThis magic square shows the same picture of Benjamin Franklin, but this time in a 4x4 grid. It made me realize that the magic square that shows the picture of Franklin in the center is actually the same 4x4 grid but scrambled.\n\nBy zooming in on the 4x4 grid, and looking at the ranges of numbers in each subsquare, I found out that these magic squares are actually constructed from the same 4x4 panmagic square we looked at earlier.\n\n::: {#7f9a3892 .cell execution_count=20}\n``` {.python .cell-code}\nprint_square(ms4)\n```\n\n::: {.cell-output .cell-output-display html-table-processing=none}\n```{=html}\n<table border='1' cellspacing='0' cellpadding='10'><tr><td>1</td><td>8</td><td>10</td><td>15</td></tr><tr><td>12</td><td>13</td><td>3</td><td>6</td></tr><tr><td>7</td><td>2</td><td>16</td><td>9</td></tr><tr><td>14</td><td>11</td><td>5</td><td>4</td></tr></table>\n```\n:::\n:::\n\n\n## Creating a magic square from an image step by step\n\nNow let's try to understand the process by taking a picture and creating a magic square. We'll use a 16x16 sprite of Mario to create a 64x64 magic square.\n\n### Loading the image\n\nWe start by loading the image from disk.\n\n::: {#0e0783c9 .cell execution_count=21}\n``` {.python .cell-code}\nfrom PIL import Image\n\nmario_sprite = Image.open('mario.png')\n```\n:::\n\n\nThis is what the image looks like in color:\n\n::: {#89b7a4e9 .cell execution_count=22}\n``` {.python .cell-code}\nplt.imshow(mario_sprite)\nplt.axis('off')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-23-output-1.png){width=389 height=389}\n:::\n:::\n\n\n### Converting the image to grayscale\n\nIn order to embed the image into a magic square, we need to convert it to grayscale. We also want 0 to represent white and 255 to represent black, so we need to invert the colors.\n\n::: {#988a14e8 .cell execution_count=23}\n``` {.python .cell-code}\nmario_grayscale = mario_sprite.convert('L')\nmario_grayscale = 255 - np.array(mario_grayscale, dtype=int)\n```\n:::\n\n\nIn greyscale, the image looks like this:\n\n::: {#06cc1168 .cell execution_count=24}\n``` {.python .cell-code}\nplt.imshow(mario_grayscale, cmap='gray_r', interpolation='nearest')\nplt.axis('off')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-25-output-1.png){width=389 height=389}\n:::\n:::\n\n\n### Mapping pixel values to a range from 1 to 256\n\nWe need to convert the pixel values to a range from 1 to 256, without duplicate values, so we can use them in a magic square. We can do this by ordering the pixels from light to dark and then give each pixel a new value starting from 1.\n\n::: {#3759e678 .cell execution_count=25}\n``` {.python .cell-code}\ndef relabel_unique(arr):\n    n = arr.shape[0]\n    flat = arr.flatten()\n    # Get sorted indices for stable relabeling\n    sorted_indices = np.argsort(flat, kind='stable')\n    # Create an empty array for the relabeled values\n    relabeled = np.empty_like(flat)\n    # Assign numbers 1 to n^2 in the order of sorted values\n    relabeled[sorted_indices] = np.arange(1, n*n + 1)\n    # Reshape back to original shape\n    return relabeled.reshape(arr.shape)\n```\n:::\n\n\n::: {#349d60ae .cell execution_count=26}\n``` {.python .cell-code}\nmario_relabeled = relabel_unique(mario_grayscale)\n```\n:::\n\n\n::: {#1838aa4e .cell execution_count=27}\n``` {.python .cell-code}\nplot_square(mario_relabeled, center_only=False, show_values=True, figsize=(5, 5))\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-28-output-1.png){width=389 height=389}\n:::\n:::\n\n\nNow no two pixels have the same value.\n\n### Tiling the image into a magic square\n\nWe can now start composing the actual magic square. Remember that we'll use the 4x4 panmagic square shown earlier as our base.\n\n::: {#38bd8c48 .cell execution_count=28}\n``` {.python .cell-code}\nprint_square(ms4)\n```\n\n::: {.cell-output .cell-output-display html-table-processing=none}\n```{=html}\n<table border='1' cellspacing='0' cellpadding='10'><tr><td>1</td><td>8</td><td>10</td><td>15</td></tr><tr><td>12</td><td>13</td><td>3</td><td>6</td></tr><tr><td>7</td><td>2</td><td>16</td><td>9</td></tr><tr><td>14</td><td>11</td><td>5</td><td>4</td></tr></table>\n```\n:::\n:::\n\n\nWe want to tile copies of the image into a 4x4 grid. The 4x4 panmagic square will tell us the range of numbers that will be used in each of these copies.\n\nThe top left value of the 4x4 panmagic square is 1, so the top left copy of the image in the 4x4 grid of tiles will contain the pixels with values from 1 to 256. The value 2 in the panmagic square indicates that the copy of the image in the third row/second column will contain pixels with values from 257 to 512, and so on.\n\nThe following code takes care of this tiling process.\n\n::: {#6b15aaa8 .cell execution_count=29}\n``` {.python .cell-code}\nmario_tiled = np.kron(ms4 - 1, np.ones(mario_relabeled.shape, dtype=int)) * np.max(mario_relabeled) + np.tile(mario_relabeled, ms4.shape)\n```\n:::\n\n\n::: {#668a8120 .cell execution_count=30}\n``` {.python .cell-code}\nplot_square(mario_tiled, center_only=False, show_values=True, figsize=(10, 10))\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-31-output-1.png){width=758 height=758}\n:::\n:::\n\n\n### Inverting half the tiles\n\nOur magic square is not yet complete. We still need to invert half of the tiles, as we saw in the example with Franklin's picture.\n\nThe following function replaces each number in the square with its complementary number. The complementary number is defined as $n^2 + 1 - x$ where $x$ is the number in the cell and $n$ is the size of the tile (in this case 16).\n\n::: {#b8ef3a1c .cell execution_count=31}\n``` {.python .cell-code}\ndef complement_square(m):\n    min_val = np.min(m)\n    max_val = np.max(m)\n    comp_sum = min_val + max_val\n    return comp_sum - m\n```\n:::\n\n\nThe next function applies this transformation to the tiles based on a boolean mask that indicates which tiles to invert.\n\n::: {#e37533bf .cell execution_count=32}\n``` {.python .cell-code}\ndef conditional_complement_blocks(bool_mask, arr):\n    n_blocks = 4\n    block_size = arr.shape[0] // 4\n    out = arr.copy()\n    for i in range(n_blocks):\n        for j in range(n_blocks):\n            if bool_mask[i, j]:\n                r0, r1 = i * block_size, (i + 1) * block_size\n                c0, c1 = j * block_size, (j + 1) * block_size\n                out[r0:r1, c0:c1] = complement_square(arr[r0:r1, c0:c1])\n    return out\n```\n:::\n\n\nWe want to invert 2 tiles in each row and column. One easy way to do this is to invert the tiles where the value in the panmagic square is larger than 8.\n\n::: {#a01b08c5 .cell execution_count=33}\n``` {.python .cell-code}\nmario16x = conditional_complement_blocks(ms4 > 8, mario_tiled)\n```\n:::\n\n\nLet's see if we indeed ended up with a magic square.\n\n::: {#645b399a .cell execution_count=34}\n``` {.python .cell-code}\nis_magic(mario16x) and is_panmagic(mario16x) and is_normal(mario16x)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\nTrue\n```\n:::\n:::\n\n\nAnd indeed, the square is magic and panmagic, just like we wanted!\n\n### Plotting the tiled images\n\nThe following function plots the magic square as a heatmap, where each tile is plotted in a different color.\n\n::: {#3e4926a0 .cell execution_count=35}\n``` {.python .cell-code}\nfrom matplotlib.colors import LinearSegmentedColormap\nimport matplotlib.colors as mcolors\n\ndef plot_square_colored_blocks(m, show_values=True, figsize=(8, 8)):\n    invert = ms4 > 8\n\n    n = m.shape[0]\n    block_size = n // 4\n    \n    # Define a list of colors to cycle through\n    tab_colors = list(mcolors.TABLEAU_COLORS.keys())\n    \n    plt.figure(figsize=figsize)\n    plt.xlim(-0.5, n)\n    plt.ylim(n, -0.5)\n\n    for i in range(4):\n        for j in range(4):\n            r0, r1 = i * block_size, (i + 1) * block_size\n            c0, c1 = j * block_size, (j + 1) * block_size\n            block = m[r0:r1, c0:c1]\n\n            color = tab_colors[(i * 4 + j) % len(tab_colors)]\n            colors = ['white', color] if not invert[i, j] else [color, 'white']\n            cmap = LinearSegmentedColormap.from_list(f'cmap_{i}_{j}', colors)\n\n            plt.imshow(block, cmap=cmap, interpolation='nearest', extent=(c0 - 0.5, c1 - 0.5, r1 - 0.5, r0 - 0.5))\n\n    if show_values:        \n        ax = plt.gca()\n        fig = plt.gcf()\n        bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n        width, height = bbox.width * fig.dpi, bbox.height * fig.dpi\n        cell_width = width / n\n        n_digits = len(str(abs(n * n)))\n\n        for (j, i), label in np.ndenumerate(m):\n            plt.text(i, j, label, ha='center', va='center', color='black', fontsize=cell_width / n_digits)\n\n\n    plt.axis('off')\n    plt.show()\n```\n:::\n\n\n::: {#bd1b6226 .cell execution_count=36}\n``` {.python .cell-code}\nplot_square_colored_blocks(mario16x, figsize=(10, 10))\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-37-output-1.png){width=758 height=758}\n:::\n:::\n\n\nWe can save this magic square to a file if we want.\n\n::: {#676baadb .cell execution_count=37}\n``` {.python .cell-code}\nnp.savetxt(\"mario16x.csv\", mario16x, fmt='%d', delimiter=\";\")\n```\n:::\n\n\n### Centering the image\n\nAs mentioned before, a property of panmagic squares is that moving columns from the left side to the right side, or moving top rows to the bottom, will always yield another panmagic square.\n\nWe can use this property to center the image.\n\n::: {#83fa8b80 .cell execution_count=38}\n``` {.python .cell-code}\nd = mario16x.shape[0] // 8 * 5\nmario_shifted = np.hstack((mario16x[:, d:], mario16x[:, :d]))\nmario1x = np.vstack((mario_shifted[d:, :], mario_shifted[:d, :]))\n```\n:::\n\n\n::: {#3de64f3a .cell execution_count=39}\n``` {.python .cell-code}\nplot_square(mario1x, center_only=True, show_values=True, figsize=(10, 10))\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-40-output-1.png){width=758 height=758}\n:::\n:::\n\n\nAs expected, the resulting magic square is still panmagic.\n\n::: {#feaf7600 .cell execution_count=40}\n``` {.python .cell-code}\nis_magic(mario1x) and is_panmagic(mario1x) and is_normal(mario1x)\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\nTrue\n```\n:::\n:::\n\n\nAmazing! Now let's save it to [a file](mario1x.csv).\n\n::: {#617c12e9 .cell execution_count=41}\n``` {.python .cell-code}\nnp.savetxt(\"mario1x.csv\", mario1x, fmt='%d', delimiter=\";\")\n```\n:::\n\n\n## All steps in one function\n\nFor convenience, we define a function that combines all steps. The function takes an image file path, resizes it to the provided size, and returns a magic square that contains the image. Centering the image is optional.\n\n::: {#4bc47418 .cell execution_count=42}\n``` {.python .cell-code}\ndef create_magic_square_from_image(image_path, image_size=(32, 32), center_image=True):\n    # Load and process the image\n    sprite = Image.open(image_path).resize(image_size, Image.LANCZOS)\n    sprite_gray = sprite.convert('L')\n    sprite_array = 255 - np.array(sprite_gray, dtype=int)\n    \n    # Relabel the unique values in the image\n    relabeled_sprite = relabel_unique(sprite_array)\n    \n    # Create a tiled magic square\n    tiled_magic_square = np.kron(ms4 - 1, np.ones(relabeled_sprite.shape, dtype=int)) * np.max(relabeled_sprite) + np.tile(relabeled_sprite, ms4.shape)\n    \n    # Apply conditional complement blocks\n    complemented_magic_square = conditional_complement_blocks(ms4 > 8, tiled_magic_square)\n    \n    # Center the image in the magic square if required\n    if center_image:\n        d = complemented_magic_square.shape[0] // 8 * 5\n        shifted_magic_square = np.hstack((complemented_magic_square[:, d:], complemented_magic_square[:, :d]))\n        centered_magic_square = np.vstack((shifted_magic_square[d:, :], shifted_magic_square[:d, :]))\n        return centered_magic_square\n    \n    return complemented_magic_square\n```\n:::\n\n\n## Creating some more magic squares\n\nNow that we have a function to create magic squares from images, let's create some more. I've chosen images of people who have, like Benjamin Franklin, created, or studied magic squares.\n\n### Srinivasa Ramanujan\n\n![](ramanujan.jpg)\n\n[Srinivasa Ramanujan](https://en.wikipedia.org/wiki/Srinivasa_Ramanujan) was an Indian mathematician who made significant contributions to mathematical analysis, number theory, infinite series, and continued fractions. \n\nRamanujan also came up with the following magic square:\n\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"10\">\n  <tr>\n    <td>22</td>\n    <td>12</td>\n    <td>18</td>\n    <td>87</td>\n  </tr>\n  <tr>\n    <td>88</td>\n    <td>17</td>\n    <td>9</td>\n    <td>25</td>\n  </tr>\n  <tr>\n    <td>10</td>\n    <td>24</td>\n    <td>89</td>\n    <td>16</td>\n  </tr>\n  <tr>\n    <td>19</td>\n    <td>86</td>\n    <td>23</td>\n    <td>11</td>\n  </tr>\n</table>\n\nIn it, the sum of each row, column, and diagonal is 139. In addition, the sum of any 2x2 box is also 139. As the cells are not consecutive integers starting from 1, this is not a normal magic square. The first row shows his birthdate (22/12/1887).\n\n::: {#61fbe603 .cell execution_count=43}\n``` {.python .cell-code}\nramanujan1x = create_magic_square_from_image('ramanujan.jpg', image_size=(64, 64), center_image=True)\nplot_square(ramanujan1x, center_only=True, show_values=True, figsize=(10, 10))\nnp.savetxt(\"ramanujan1x.csv\", ramanujan1x, fmt='%d', delimiter=\";\")\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-44-output-1.png){width=759 height=758}\n:::\n:::\n\n\nThe resulting file can be found [here](ramanujan1x.csv).\n\n### John Horton Conway\n\n![](conway.jpg)\n\n[John Conway](https://en.wikipedia.org/wiki/John_Horton_Conway) made contributions to many branches of recreational mathematics. He's likely best known for inventing the [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life).\n\nHe also thought up an interesting method to construct magic squares of order 4n+2, where n is a natural number, which he called the [Conway's LUX method](https://en.wikipedia.org/wiki/Conway%27s_LUX_method_for_magic_squares).\n\n::: {#c8ffcc49 .cell execution_count=44}\n``` {.python .cell-code}\nconway1x = create_magic_square_from_image('conway.jpg', image_size=(64, 64), center_image=True)\nplot_square(conway1x, center_only=True, show_values=True, figsize=(10, 10))\nnp.savetxt(\"conway1x.csv\", conway1x, fmt='%d', delimiter=\";\")\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-45-output-1.png){width=759 height=758}\n:::\n:::\n\n\n[This file](conway1x.csv) is the result of saving this magic square.\n\n### Leonhard Euler\n\n![](euler.png)\n\n[Leonhard Euler](https://en.wikipedia.org/wiki/Leonhard_Euler) was a Swiss mathematician and physicist who made important discoveries in fields like calculus, graph theory, topology, mechanics, fluid dynamics, astronomy, and number theory.\n\nIn 1770 Euler found a magic square of order 4 filled with squares.\n\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"10\">\n  <tr>\n    <td>68²</td>\n    <td>29²</td>\n    <td>41²</td>\n    <td>37²</td>\n  </tr>\n  <tr>\n    <td>17²</td>\n    <td>31²</td>\n    <td>79²</td>\n    <td>32²</td>\n  </tr>\n  <tr>\n    <td>59²</td>\n    <td>28²</td>\n    <td>23²</td>\n    <td>61²</td>\n  </tr>\n  <tr>\n    <td>11²</td>\n    <td>77²</td>\n    <td>8²</td>\n    <td>49²</td>\n  </tr>\n</table>\n\n::: {#58a747a7 .cell execution_count=45}\n``` {.python .cell-code}\neuler16x = create_magic_square_from_image('euler.png', image_size=(32, 32), center_image=False)\nplot_square_colored_blocks(euler16x, show_values=True, figsize=(10, 10))\nnp.savetxt(\"euler16x.csv\", euler16x, fmt='%d', delimiter=\";\")\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-46-output-1.png){width=758 height=758}\n:::\n:::\n\n\nThis time I chose to not center the image. Download the resulting file [from here](euler16x.csv).\n\n## Try it using your own images\n\nWant to turn your own image into a magic square? You can find my code as a GitHub gist:\n\n<a target=\"_blank\" href=\"https://gist.github.com/afvanwoudenberg/64a94139272219045c4d3897a9c38655\">![GitHub](https://shields.io/badge/-View%20as%20Gist-grey.svg?logo=github&style=flat&logoColor=white&labelColor=black)</a>\n\nEnjoy!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}