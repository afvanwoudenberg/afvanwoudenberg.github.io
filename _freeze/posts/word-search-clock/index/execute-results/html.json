{
  "hash": "7e14f5f62d18f5be96d0db08eaca685b",
  "result": {
    "markdown": "---\ntitle: \"Word Search Clock\"\ndescription: \"How I created a clock using an old digital photo frame and some Python code.\"\nauthor: \"Aswin van Woudenberg\"\ndate: \"2023-11-26\"\ncategories: [programming, python, matplotlib, algorithms]\ntoc: true\n---\n\nA few weeks ago, my clock stopped working, and I wasn't inclined to invest in a replacement. After futile attempts to revive it, I decided to get crafty. I had an unused photo frame collecting dust and realized it could be turned into a clock by making it display images that show the time of the day. I'd need one image for every minute of the day and display each of them for 60 seconds before transitioning to the next one.\n\nUsing pictures that show a digital clock seemed too mundane. Analog faces felt a bit lackluster. Then it hit meâ€”why not combine the charm of [word clocks](https://www.timeanddate.com/wordclock/) with the visuals of a [word search puzzle](https://en.wikipedia.org/wiki/Word_search)? The outcome: a word clock that shows words not just horizontally but also vertically and diagonally. Brilliant, if I may say so myself.\n\n![](word_search_clock.jpg)\n\nEvery minute, the photo frame displays an image featuring a different set of highlighted words that indicate the current time.\n\nCurious about how I generated these images? Dive into the details below.\n\n## Design decisions\n\n### Arranging words in a grid\n\nMy intention was to position words both horizontally, vertically, and diagonally, similar to word search puzzles, allowing for occasional partial overlaps. To ensure a singular way of reading the time, I established the following criteria:\n\n1. Each letter can only be the first letter in a word once. \n2. Words should follow a specific order.\n3. Due to varying word orientations, the first letter in each word dictates the reading sequence.\n\nIn simpler terms, by scanning the grid left to right and top to bottom and identifying whether each letter marks the beginning of a word, one can deduce the time. Applying this method to the image above reveals the time as \"It is twenty-four minutes past four.\"\n\n### Telling time in English\n\nFor time expression, I adopted the following format:\n\n1. Top of the hour:\n    * \"It is [number] o'clock.\"\n        * Example: \"It is two o'clock.\"\n2. Times after the top of the hour:\n    * \"It is [minutes] past [number].\"\n        * Example: \"It is eleven minutes past three.\"\n3. Times before the top of the hour:\n    * \"It is [minutes] to [next hour].\"\n        * Example: \"It is twenty-three minutes to five.\"\n\n(Note: We use \"half\" for thirty minutes and \"a quarter\" for fifteen minutes.)\n\n### Language nuances\n\nAccording to the [Cambridge dictionary](https://dictionary.cambridge.org/grammar/british-grammar/time), for multiplies of five, the word \"minutes\" can be omitted. This might be a British-English specific convention but I decided to follow it anyways.\n\nWhile Americans might use \"after\" instead of \"past,\" and many English speakers tend to omit the word \"minutes\" in everyday speech, I opted for \"past\" and excluded \"minutes\" only for multiples of five.\n\n### Simplifications\n\nI decided against adding phrases like \"in the morning\" or \"in the afternoon\", limiting the generation to only 720 images (12 hours * 60 minutes).\n\nThe word \"fourteen\" contains \"four,\" and likewise, \"sixteen\" encompasses \"six.\" By positioning \"fourteen,\" \"sixteen,\" \"seventeen,\" \"eighteen,\" and \"nineteen,\" we inherently include \"four,\" \"six,\" \"seven,\" \"eight,\" and \"nine.\" This ensures the grid remains compact.\n\n## Importing libraries\n\nWe'll start by importing libraries. We use matplotlib to draw the images.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport string\nimport os\n```\n:::\n\n\n## Specifying the word order\n\nThe following graph specifies the order in which words must be placed on the grid.\n\n\n```{dot}\ndigraph {\n    layout=dot;\n    node [shape=circle, style=filled, fillcolor=lightblue];\n    \n    n0 -> it [color=\"black:invis:black\"];\n    it -> is;\n    is -> twenty;\n    is -> half;\n    is -> ten;\n    is -> eleven;\n    is -> twelve;\n    is -> thirteen;\n    is -> fourteen;\n    is -> sixteen;\n    is -> seventeen;\n    is -> eighteen;\n    is -> nineteen;\n    is -> a;\n    a -> quarter;\n    twenty -> one;\n    twenty -> two;\n    twenty -> three;\n    twenty -> five;\n    one -> minutes;\n    two -> minutes;\n    three -> minutes;\n    fourteen -> minutes;\n    sixteen -> minutes;\n    seventeen -> minutes;\n    eighteen -> minutes;\n    nineteen -> minutes;\n    eleven -> minutes;\n    twelve -> minutes;\n    thirteen -> minutes;\n    minutes -> past;\n    five -> past;\n    ten -> past;\n    quarter -> past;\n    twenty -> past;\n    half -> past;\n    minutes -> to;\n    five -> to;\n    ten -> to;\n    quarter -> to;\n    twenty -> to;\n    past -> onehour;\n    to -> onehour;\n    past -> twohour;\n    to -> twohour;\n    past -> threehour;\n    to -> threehour;\n    past -> fourhour;\n    to -> fourhour;\n    past -> fivehour;\n    to -> fivehour;\n    past -> sixhour;\n    to -> sixhour;\n    past -> sevenhour;\n    to -> sevenhour;\n    past -> eighthour;\n    to -> eighthour;\n    past -> ninehour;\n    to -> ninehour;\n    past -> tenhour;\n    to -> tenhour;\n    past -> elevenhour;\n    to -> elevenhour;\n    past -> twelvehour;\n    to -> twelvehour;\n    onehour -> oclock;\n    twohour -> oclock;\n    threehour -> oclock;\n    fourhour -> oclock;\n    fivehour -> oclock;\n    sixhour -> oclock;\n    sevenhour -> oclock;\n    eighthour -> oclock;\n    ninehour -> oclock;\n    tenhour -> oclock;\n    elevenhour -> oclock;\n    twelvehour -> oclock;\n\n    n0 [label= \"\", shape=none, fillcolor=none]\n    onehour [label=\"one\"];\n    twohour [label=\"two\"];\n    threehour [label=\"three\"];\n    fourhour [label=\"four\"];\n    fivehour [label=\"five\"];\n    sixhour [label=\"six\"];\n    sevenhour [label=\"seven\"];\n    eighthour [label=\"eight\"];\n    ninehour [label=\"nine\"];\n    tenhour [label=\"ten\"];\n    elevenhour [label=\"eleven\"];\n    twelvehour [label=\"twelve\"];\n    oclock [label=\"o'clock\"];\n}\n```\n\n\nIn code this can be specified as follows:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Words to fill. Each tuple is (ID, word, preceding)\nwords = [\n    (0, \"it\", []), \n    (1, \"is\", [0]),\n    (2, \"twenty\", [1]),\n    (3, \"half\", [1]),\n    (4, \"ten\", [1]),\n    (5, \"eleven\", [1]),\n    (6, \"twelve\", [1]),\n    (7, \"thirteen\", [1]),\n    (8, \"fourteen\", [2]),\n    (9, \"sixteen\", [2]),\n    (10, \"seventeen\", [2]),\n    (11, \"eighteen\", [2]),\n    (12, \"nineteen\", [2]),\n    (13, \"a\", [1]),\n    (14, \"quarter\", [13]),\n    (15, \"one\", [2]),\n    (16, \"two\", [2]),\n    (17, \"three\", [2]),\n    (18, \"five\", [2]),\n    (19, \"minutes\", [15, 16, 17, 8, 9, 10, 11, 12, 5, 6, 7]),\n    (20, \"past\", [19, 18, 4, 14, 2, 3]),\n    (21, \"to\", [19, 18, 4, 14, 2]),\n    (22, \"one\", [20, 21]),\n    (23, \"two\", [20, 21]),\n    (24, \"three\", [20, 21]),\n    (25, \"four\", [20, 21]),\n    (26, \"five\", [20, 21]),\n    (27, \"six\", [20, 21]),\n    (28, \"seven\", [20, 21]),\n    (29, \"eight\", [20, 21]),\n    (30, \"nine\", [20, 21]),\n    (31, \"ten\", [20, 21]),\n    (32, \"eleven\", [20, 21]),\n    (33, \"twelve\", [20, 21]),\n    (34, \"oclock\", [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])\n]\n```\n:::\n\n\nEach word is specified by a tuple of the form `(id, word, preceding)`. The `id` is an integer that uniquely identifies the word. The `word` is the word to be placed. The `preceding` is a list of integers that specify which words must be placed before this word.\n\n## Filling the grid\n\nWe ensure that each word is readable in either a left-to-right or top-down direction, never in reverse.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndirections = [(1, 0), (0, 1), (1, 1), (1, -1)]\n```\n:::\n\n\nThe following function returns a list of identifiers of words that are ready to be placed in the grid. This is done by checking if all preceding words are placed in the grid. If so, the word is ready to be placed. At first, the only word that can be placed is the word _it_ because its list of preceding words is empty.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef placeable_word_ids(words):\n    unplaced_word_ids = [id for (id, _, loc, _, _) in words if loc is None]\n    return [id for (id, _, loc, _, prec) in words if not any(prec_id in unplaced_word_ids for prec_id in prec) and loc is None]\n```\n:::\n\n\nThe following function checks is a word can be placed in the grid in a given direction and location.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef can_place_word(word, grid, dir, r, c):\n    height = len(grid)\n    width = len(grid[0])\n    d_x, d_y = dir\n    if c + len(word) * d_x > width or r + len(word) * d_y > height or c + len(word) * d_x < 0 or r + len(word) * d_y < 0:\n        return False\n    for i, ch in enumerate(word):\n        if grid[r + i * d_y][c + i * d_x] not in ['?', ch]: \n            return False\n    return True\n```\n:::\n\n\nIf a word can be placed, we call the following function to place it. The original content is returned so we can backtrack later.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef replace_characters(word, grid, dir, r, c):\n    height = len(grid)\n    width = len(grid[0])\n    previous = \"\"\n    d_x, d_y = dir\n    for i, ch in enumerate(word):\n        previous += grid[r + i * d_y][c + i * d_x]\n        grid[r + i * d_y][c + i * d_x] = ch\n    return previous\n```\n:::\n\n\nA recursive generator function attempts to fill a grid with words. It uses backtracking to explore possible word placements in different directions.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef fill_grid_(grid, words, i=0):\n    height = len(grid)\n    width = len(grid[0])\n    ids = placeable_word_ids(words)\n    \n    if not ids:\n        yield grid, words\n    elif i < height * width:\n        row = i // width\n        col = i % width\n        for id in ids:\n            dir_length = len(directions)\n            for d in range(dir_length):\n                dir = directions[(i + d) % dir_length]\n                if can_place_word(words[id][1], grid, dir, row, col):\n                    previous = replace_characters(words[id][1], grid, dir, row, col)\n                    words[id] = (id, words[id][1], (col, row), dir, words[id][4])\n                    yield from fill_grid_(grid, words, i+1)\n                    words[id] = (id, words[id][1], None, None, words[id][4])\n                    replace_characters(previous, grid, dir, row, col)\n        else:\n            yield from fill_grid_(grid, words, i+1)\n```\n:::\n\n\nThe function `fill_grid` is a wrapper function that initializes the grid and calls `fill_grid_`.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef fill_grid(width, height):\n    loc_dir_words = [(id, word, None, None, prec) for (id, word, prec) in words]\n    grid = [['?' for c in range(width)] for r in range(height)]\n    yield from fill_grid_(grid, loc_dir_words, 0)\n```\n:::\n\n\nWe call this wrapper function as follows:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ngen = fill_grid(15, 11)\n(g, w) = next(gen)\n```\n:::\n\n\nThis returns a filled grid with a width of 15 and a height of 11. These dimensions were found experimentally. The digital photo frame that I'm using has an aspect ratio of 4:3. It makes sense to use a grid with a similar aspect ratio. I started with a width of 16 and height of 12, but that yielded grids with too many unoccupied spaces. Using 15 by 11 deviates only slightly from a 4:3 aspect ratio.\n\nLet's look at the grid.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ng\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n[['i', 't', 'i', 't', 'w', 'e', 'n', 't', 'y', 'h', 'a', 'o', 'n', 'e', 't'],\n ['t', 'f', 's', 's', '?', 'l', 'q', 'i', 'e', 't', 'a', '?', '?', 'i', 'w'],\n ['h', 'o', 'i', 't', 'e', 'e', 'f', 'u', 'n', 'n', 'w', 'l', '?', 'g', 'e'],\n ['i', 'u', 'x', 'h', 'm', 'v', 'p', 'i', 'a', 'e', 't', 'o', 'f', 'h', 'l'],\n ['r', 'r', 't', 'r', 'i', 'e', 'e', 'a', 'v', 'r', 't', 'n', 'i', 't', 'v'],\n ['t', 't', 'e', 'e', 'n', 'n', 'i', 'n', 's', 'e', 't', 'e', 'v', 'e', 'e'],\n ['e', 'e', 'e', 'e', 'u', 'i', 't', 'g', 't', 't', 'l', 'e', 'e', 'e', 'f'],\n ['e', 'e', 'n', 's', 't', '?', 'n', 'w', 'h', 'e', 'h', 'e', 'r', 'n', 'o'],\n ['n', 'n', '?', 'i', 'e', '?', '?', 'e', 'o', 't', 'e', 'r', 'v', '?', 'u'],\n ['?', '?', '?', 'x', 's', 'e', 'v', 'e', 'n', '?', '?', 'n', 'e', 'e', 'r'],\n ['t', 'w', 'e', 'l', 'v', 'e', 'o', 'c', 'l', 'o', 'c', 'k', '?', 'e', 'n']]\n```\n:::\n:::\n\n\nAnd how the words are placed.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nw\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n[(0, 'it', (0, 0), (1, 0), []),\n (1, 'is', (2, 0), (1, 1), [0]),\n (2, 'twenty', (3, 0), (1, 0), [1]),\n (3, 'half', (9, 0), (1, 1), [1]),\n (4, 'ten', (7, 0), (1, 1), [1]),\n (5, 'eleven', (5, 0), (0, 1), [1]),\n (6, 'twelve', (14, 0), (0, 1), [1]),\n (7, 'thirteen', (0, 1), (0, 1), [1]),\n (8, 'fourteen', (1, 1), (0, 1), [2]),\n (9, 'sixteen', (2, 1), (0, 1), [2]),\n (10, 'seventeen', (3, 1), (1, 1), [2]),\n (11, 'eighteen', (13, 0), (0, 1), [2]),\n (12, 'nineteen', (6, 0), (1, 1), [2]),\n (13, 'a', (10, 0), (1, 1), [1]),\n (14, 'quarter', (6, 1), (1, 1), [13]),\n (15, 'one', (11, 0), (1, 0), [2]),\n (16, 'two', (9, 1), (1, 1), [2]),\n (17, 'three', (3, 2), (0, 1), [2]),\n (18, 'five', (6, 2), (1, 1), [2]),\n (19, 'minutes', (4, 3), (0, 1), [15, 16, 17, 8, 9, 10, 11, 12, 5, 6, 7]),\n (20, 'past', (6, 3), (1, 1), [19, 18, 4, 14, 2, 3]),\n (21, 'to', (10, 3), (1, 0), [19, 18, 4, 14, 2]),\n (22, 'one', (11, 3), (0, 1), [20, 21]),\n (23, 'two', (6, 6), (1, 1), [20, 21]),\n (24, 'three', (9, 6), (1, 1), [20, 21]),\n (25, 'four', (14, 6), (0, 1), [20, 21]),\n (26, 'five', (12, 3), (0, 1), [20, 21]),\n (27, 'six', (3, 7), (0, 1), [20, 21]),\n (28, 'seven', (4, 9), (1, 0), [20, 21]),\n (29, 'eight', (5, 4), (1, 1), [20, 21]),\n (30, 'nine', (4, 5), (1, 1), [20, 21]),\n (31, 'ten', (0, 5), (1, 1), [20, 21]),\n (32, 'eleven', (9, 5), (1, 1), [20, 21]),\n (33, 'twelve', (0, 10), (1, 0), [20, 21]),\n (34,\n  'oclock',\n  (6, 10),\n  (1, 0),\n  [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])]\n```\n:::\n:::\n\n\n## Occupying vacant spaces in the grid\n\nNot all spaces in the grid are filled as indicated by the question marks. Let's see how many are empty.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nsum(row.count('?') for row in g)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n15\n```\n:::\n:::\n\n\nWe can fill these spaces with some sage words.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef remove_spaces_and_punctuation(input_string):\n    # Remove spaces\n    no_spaces = input_string.replace(\" \", \"\")\n    \n    # Remove punctuation\n    translator = str.maketrans(\"\", \"\", string.punctuation)\n    no_punctuation = no_spaces.translate(translator)\n    \n    return no_punctuation\n```\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndef replace_question_marks(grid, phrase):\n    chars = remove_spaces_and_punctuation(phrase)\n    i = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == '?' and i < len(chars):\n                grid[row][col] = chars[i]\n                i += 1\n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nreplace_question_marks(g, \"Time keeps moving\")\n```\n:::\n\n\nSpaces and interpunctions are removed before the phrase is placed in the grid.\n\n## Plotting the grid\n\nNow, we're ready to visualize the grid using matplotlib. To do so, I defined a few helper functions.\n\nThe following function converts a time to a sentence. The time is given in hours and minutes. The function returns a sentence that describes the time. \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ndef time_to_sentence(hours, minutes):\n    # Define words for numbers\n    time_words = [\"twelve\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \n             \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"a quarter\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\",\n             \"twenty-one\", \"twenty-two\", \"twenty-three\", \"twenty-four\", \"twenty-five\", \"twenty-six\", \"twenty-seven\", \"twenty-eight\", \"twenty-nine\", \"half\"]\n\n    # Convert hours and minutes to words\n    if minutes <= 30:\n        hour_word = time_words[hours % 12]\n        minute_word = time_words[minutes]\n    else:\n        hour_word = time_words[(hours+1) % 12]\n        minute_word = time_words[60 - minutes]\n        \n    # Determine whether it's past or to\n    if minutes == 0:\n        time_phrase = f\"it is {hour_word} o'clock\"\n    elif minutes in [5, 10, 15, 20, 25, 30]:\n        time_phrase = f\"it is {minute_word} past {hour_word}\"\n    elif minutes in [35, 40, 45, 50, 55]:\n        time_phrase = f\"it is {minute_word} to {hour_word}\"\n    elif minutes == 1:\n        time_phrase = f\"it is {minute_word} minute past {hour_word}\"\n    elif minutes == 59:\n        time_phrase = f\"it is {minute_word} minute to {hour_word}\"\n    elif minutes < 30:\n        time_phrase = f\"it is {minute_word} minutes past {hour_word}\"\n    else:\n        time_phrase = f\"it is {minute_word} minutes to {hour_word}\"\n\n    return time_phrase\n```\n:::\n\n\nLet's test this function. \n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nprint(time_to_sentence(10, 23))\nprint(time_to_sentence(0, 8))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nit is twenty-three minutes past ten\nit is eight minutes past twelve\n```\n:::\n:::\n\n\nWe use a helper function that returns the word at a given location.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndef word_at_location(words, r, c):\n    for (id, word, (x, y), dir, prec) in words:\n        if x == c and y == r:\n            return (id, word, (x, y), dir, prec)\n    return None        \n```\n:::\n\n\nThe following function then finally plots the grid using matplotlib. It calls the `time_to_sequence` function to get a sentence that describes the time. This sentence is then split into words and the words are then highlighted in the grid. It loops through the positions in the grid from top-left to bottom-right and checks, using `word_at_location`, whether the word that starts at that position matches the next word in the sentence. If so, the word is highlighted.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndef plot_grid(grid, words=None, hours=None, minutes=None, ax=None):\n    if not ax:\n        # Create a figure and axes\n        fig, ax = plt.subplots(figsize=(12,9))\n    else:\n        fig = None\n    \n    # Give all cells the same value/color\n    ax.imshow([[0 for cell in row] for row in grid], cmap='gray')\n\n    ax.patch.set_edgecolor('black')\n    ax.patch.set_linewidth(2)\n    \n    # Display the letters\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            ax.text(j, i, grid[i][j].upper(), ha='center', va='center', fontsize=32, color='white')\n\n    # Highlight the time\n    if not None in [hours, minutes, words]:\n        # Highlight the time\n        time_sentence = time_to_sentence(hours, minutes)\n        time_sentence = time_sentence.replace(\"-\", \" \")\n        time_sentence = time_sentence.replace(\"'\", \"\")\n\n        time_words = time_sentence.split()\n        i = 0\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                word_at_loc = word_at_location(words, r, c)\n                if word_at_loc:\n                    (_, word, (x, y), (d_x, d_y), _) = word_at_loc\n                    if i < len(time_words) and time_words[i] == word[:len(time_words[i])]:\n                        x_values = [x, x + d_x * (len(time_words[i])-1) + 0.01]\n                        y_values = [y - 0.05, y + d_y * (len(time_words[i])-1) - 0.05]\n                        ax.plot(x_values, y_values, linewidth=35, solid_capstyle='round', alpha=0.5)\n                        i += 1\n    \n    # Remove the axes ticks\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    if fig:\n        fig.tight_layout()\n```\n:::\n\n\nLet's plot the grid with the time fourteen minutes past four.\n\n::: {.cell .column-screen-inset-right execution_count=20}\n``` {.python .cell-code}\nplot_grid(g, w, 4, 14)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-21-output-1.png){width=1142 height=843}\n:::\n:::\n\n\n## Saving images to file\n\nWe can now generate all images and save them to file. We loop through all hours and minutes and call `plot_grid` to plot the grid and save it to disk.\n\n```{.python}\noutput_directory = 'images'\nos.makedirs(output_directory, exist_ok=True)\n\nfor h in range(12):\n    for m in range(60):\n        plot_grid(g, w, h, m)\n        file_name = f\"time_{h:02d}_{m:02d}.jpg\"\n        file_path = os.path.join(output_directory, file_name)\n        plt.savefig(file_path, bbox_inches='tight')\n        plt.close()\n```\n\nThe files are saved as JPEG to the `images` folder. \n\nFinally, the images need to be transfered to an SD card or USB flash drive for displaying them on the digital photo frame. I own a Braun DigiFrame 88 photo frame, but any photo frame that allows you to set the display interval of the slideshow should work.\n\n## Reflecting on the outcome\n\nI'm happy with how it turned out. It works pretty well, and I think it looks nice on my desk. \n\nThere's some minor drift as the images don't switch exactly after 60 seconds. I deal with it by adjusting the image manually once a week or so which is easy enough using the buttons on the back of the device.\n\nIf you want to play with the code to perhaps make a version for another language, check out one of the following links:\n\n<a target=\"_blank\" href=\"https://kaggle.com/kernels/welcome?src=https://gist.githubusercontent.com/afvanwoudenberg/d6b63c44fdb2a1c6a36aef6529436997/raw/38e9a94d288d908ac81b1f12c9a70e5c972e39be/word_search_clock.ipynb\">![Kaggle](https://kaggle.com/static/images/open-in-kaggle.svg)</a> \n<a target=\"_blank\" href=\"http://colab.research.google.com/gist/afvanwoudenberg/d6b63c44fdb2a1c6a36aef6529436997/word_search_clock.ipynb\">![Colab](https://colab.research.google.com/assets/colab-badge.svg)</a>\n<a target=\"_blank\" href=\"https://gist.github.com/afvanwoudenberg/d6b63c44fdb2a1c6a36aef6529436997\">![GitHub](https://shields.io/badge/-View%20as%20Gist-grey.svg?logo=github&style=flat&logoColor=white&labelColor=black)</a>\n\nYou can also download just the images from [here](images.zip).\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}