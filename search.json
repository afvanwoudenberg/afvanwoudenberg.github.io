[
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html",
    "href": "posts/from-baby-face-to-neanderthal/index.html",
    "title": "From Baby Face to Neanderthal",
    "section": "",
    "text": "Earlier this year, I embarked on the famous pilgrimage Camino de Santiago, walking from my hometown Leeuwarden in the north of the Netherlands all the way to Santiago de Compostela. For three months, I lived out of a backpack and primarily engaged in wild-camping along the trail. Throughout my journey, I visited some of the most awe-inspiring places, met incredible people along the way, and created unforgettable memories that I will cherish forever.\nI didn‚Äôt want people to think I was just on a huge camping trip to get away from the daily grind, so I told them it was a pilgrimage of ‚Äúspiritual growth‚Äù and ‚Äúself-discovery‚Äù. Some just scoffed, others thought I was losing my mind. To convince my less-enlightened friends that this wasn‚Äôt just a three-month hike to nowhere, I took a selfie every day to document my, ehm, transcendence.\nIn this post I‚Äôll show how I turned these daily selfies into a time-lapse video using MediaPipe and OpenCV."
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#import-libraries",
    "href": "posts/from-baby-face-to-neanderthal/index.html#import-libraries",
    "title": "From Baby Face to Neanderthal",
    "section": "Import libraries",
    "text": "Import libraries\nWe start by importing the necessary libraries. We use MediaPipe to detect face landmarks and OpenCV to scale and translate the images to align them with each other.\n\nimport cv2\nimport os\nimport glob\nimport itertools\n\nimport numpy as np\nimport pandas as pd\nimport mediapipe as mp\nimport matplotlib.pyplot as plt\n\nfrom os import listdir\nfrom os.path import isfile, join"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#about-mediapipe",
    "href": "posts/from-baby-face-to-neanderthal/index.html#about-mediapipe",
    "title": "From Baby Face to Neanderthal",
    "section": "About MediaPipe",
    "text": "About MediaPipe\nMediaPipe is a framework developed by Google that bundles several ML solutions to process images and video. The Face Mesh component estimates 468 3D face landmarks. Below I show how this component can be used.\nWe first load an image using the OpenCV 2 library and plot it using Matplotlib.\n\nFILENAME = \"selfie.jpg\"\nimage = cv2.imread(FILENAME)\n\nplt.figure(figsize=(10, 10))\nplt.title(\"Original\")\nplt.axis('off')\nplt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\nplt.show()\n\n\n\n\n\n\n\n\nThen we find the landmarks and draw a mesh on the image.\n\nmp_drawing = mp.solutions.drawing_utils\nmp_drawing_styles = mp.solutions.drawing_styles\nmp_face_mesh = mp.solutions.face_mesh\ndrawing_spec = mp_drawing.DrawingSpec(thickness=1, circle_radius=1)\n\nwith mp_face_mesh.FaceMesh(static_image_mode=True, \n            max_num_faces=1, refine_landmarks=True, min_detection_confidence=0.5) as face_mesh:\n    image = cv2.imread(FILENAME)\n    results = face_mesh.process(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\n\n    # draw face mesh landmarks on the image.\n    for face_landmarks in results.multi_face_landmarks:\n        mp_drawing.draw_landmarks(image=image, landmark_list=face_landmarks, \n            connections=mp_face_mesh.FACEMESH_TESSELATION, landmark_drawing_spec=None,\n            connection_drawing_spec=mp_drawing_styles.get_default_face_mesh_tesselation_style())\n        mp_drawing.draw_landmarks(image=image,\n            landmark_list=face_landmarks, connections=mp_face_mesh.FACEMESH_CONTOURS, landmark_drawing_spec=None, \n            connection_drawing_spec=mp_drawing_styles.get_default_face_mesh_contours_style())\n        mp_drawing.draw_landmarks(image=image, landmark_list=face_landmarks,\n            connections=mp_face_mesh.FACEMESH_IRISES, landmark_drawing_spec=None,\n            connection_drawing_spec=mp_drawing_styles.get_default_face_mesh_iris_connections_style())\n\nINFO: Created TensorFlow Lite XNNPACK delegate for CPU.\n\n\nAnd show the result.\n\nplt.figure(figsize=(10,10))\nplt.title(\"Result\")\nplt.axis('off')\nplt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\nplt.show()"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#selecting-landmarks",
    "href": "posts/from-baby-face-to-neanderthal/index.html#selecting-landmarks",
    "title": "From Baby Face to Neanderthal",
    "section": "Selecting landmarks",
    "text": "Selecting landmarks\nWe‚Äôre only interested in a few specific landmarks to figure out how to scale and translate images so that they can be stitched together into a time-lapse video. More specifically, we are interested in the landmarks corresponding to the nose and the left- and rightmost points of the face. The landmark that corresponds with the tip of the nose is used to align images. The left- and rightmost landmarks are used to determine how much to scale them.\nThe index numbers for the different landmarks can be found in this image.\nWe define some constants including the indexes of the landmarks we‚Äôre interested in. You can experiment with the FPS parameter that tells you how many different frames will be shown per second.\nIMG_PATH = \"selfies/\" # the input directory\nOUTPUT_PATH = \"output/\" # also used for temporary files\nVIDEO_NAME = 'video.avi' # the output filename\nFPS = 3 # frames per second\n\nNOSE_TIP_LANDMARK = 1\nLEFTMOST_LANDMARK = 234\nRIGHTMOST_LANDMARK = 454"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#clearing-old-files",
    "href": "posts/from-baby-face-to-neanderthal/index.html#clearing-old-files",
    "title": "From Baby Face to Neanderthal",
    "section": "Clearing old files",
    "text": "Clearing old files\nTo start, we‚Äôll delete all files in OUTPUT_PATH that might still be there from previous runs.\nfiles = glob.glob(os.path.join(OUTPUT_PATH, \"*\"))\nfor f in files:\n    os.remove(f)"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#defining-helper-functions",
    "href": "posts/from-baby-face-to-neanderthal/index.html#defining-helper-functions",
    "title": "From Baby Face to Neanderthal",
    "section": "Defining helper functions",
    "text": "Defining helper functions\nWe need to define a couple of helper functions.\nMediapipe landmarks are defined as 3D coordinates. The following function converts a landmark into a 2D pixel coordinate.\n\ndef to_pixel_coord(image, landmark):\n    # convert landmark to pixel coordinates\n    [height, width, _] = image.shape\n    return int(landmark.x * width), int(landmark.y * height)\n\nAnother function loops through all files in a directory and tries to determine the landmarks‚Äô pixel coordinates. The result is returned as a Pandas dataframe.\n\ndef read_landmarks(path):\n    # find all files in directory\n    filenames = [f for f in listdir(path) if isfile(join(path, f))]\n    filenames.sort()\n    \n    # create an empty dataframe\n    columns = {\n        \"file\": str(), \n        \"nose_tip_x\": int(), \"nose_tip_y\": int(), \n        \"leftmost_x\": int(), \"leftmost_y\": int(), \n        \"rightmost_x\": int(), \"rightmost_y\": int(),\n        \"width\": int(), \"height\": int()\n    }\n    df = pd.DataFrame(columns, index=[])\n    \n    # find the landmarks' pixel coordinates\n    with mp_face_mesh.FaceMesh(static_image_mode=True, \n                max_num_faces=1, refine_landmarks=True, \n                min_detection_confidence=0.5) as face_mesh:\n        for file in filenames:\n            image = cv2.imread(os.path.join(path, file))\n            results = face_mesh.process(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\n\n            if not len(results.multi_face_landmarks) == 1:\n                # detected less or more than one face -&gt; skip image\n                continue\n            face_landmarks = results.multi_face_landmarks[0]\n            nose_tip_x, nose_tip_y = to_pixel_coord(image, face_landmarks.landmark[NOSE_TIP_LANDMARK])\n            leftmost_x, leftmost_y = to_pixel_coord(image, face_landmarks.landmark[LEFTMOST_LANDMARK])\n            rightmost_x, rightmost_y = to_pixel_coord(image, face_landmarks.landmark[RIGHTMOST_LANDMARK])\n            [height, width, _] = image.shape\n            landmarks_xy = [file, nose_tip_x, nose_tip_y, leftmost_x, leftmost_y, rightmost_x, rightmost_y, width, height]\n            df = pd.concat([df, pd.DataFrame([landmarks_xy], columns=list(columns.keys()))], ignore_index=True)\n    \n    return df\n\nWe also need a function to scale images.\n\ndef scale_image(filename_input, filename_output, factor):\n    # read image from disk\n    image = cv2.imread(filename_input)\n    \n    (height, width) = image.shape[:2]\n\n    res = cv2.resize(image, (int(width * factor), int(height * factor)), interpolation=cv2.INTER_CUBIC)\n  \n    # write image back to disk.\n    cv2.imwrite(filename_output, res)\n\nThe next function translates an image. Translating an image means shifting it within a given frame of reference.\n\ndef translate_image(filename_input, filename_output, x, y):\n    # if the shift is (x, y) then the translation matrix would be\n    # M = [1 0 x]\n    #     [0 1 y]\n    M = np.float32([[1, 0, x], [0, 1, y]])\n    \n    # read image from disk.\n    image = cv2.imread(filename_input)\n    (rows, cols) = image.shape[:2]\n  \n    # warpAffine does appropriate shifting given the translation matrix.\n    res = cv2.warpAffine(image, M, (cols, rows))\n  \n    # write image back to disk.\n    cv2.imwrite(filename_output, res)"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#processing-the-images",
    "href": "posts/from-baby-face-to-neanderthal/index.html#processing-the-images",
    "title": "From Baby Face to Neanderthal",
    "section": "Processing the images",
    "text": "Processing the images\nNow we can process our collection of selfies. This means finding landmarks, scaling, and translating images so that they align properly.\n\nFinding landmarks\nWe can just call the function we define before.\ndf = read_landmarks(IMG_PATH)\n\n\nScaling images\nBy rescaling the images we make the face in each photo of similar size.\nWe first determine the mean size of the face.\nmean_face_size = int(df.rightmost_x.mean()) - int(df.leftmost_x.mean())\nAfter finding the mean face size, we rescale each image to match this.\nfor _, row in df.iterrows():\n    filename = row['file']\n    face_size = row['rightmost_x'] - row['leftmost_x']\n    scale_image(os.path.join(IMG_PATH, filename), os.path.join(OUTPUT_PATH, filename), mean_face_size / face_size)\nAfter rescaling, we need to find the landmarks again as they have changed.\ndf = read_landmarks(OUTPUT_PATH)\n\n\nTranslating images\nIn this step we find the average location of the tip of the nose. Then we translate all images so that the tips of the noses align. We keep track of how much an image is maximally shifted in the horizontal or vertical direction so we can properly crop the images later.\nmean_x = int(df.nose_tip_x.mean())\nmean_y = int(df.nose_tip_y.mean())\ncrop_left = 0\ncrop_right = 0\ncrop_top = 0\ncrop_bottom = 0\nfor _, row in df.iterrows():\n    filename = row['file']\n    shift_x = mean_x - row['nose_tip_x']\n    shift_y = mean_y - row['nose_tip_y']\n    translate_image(os.path.join(OUTPUT_PATH, filename), os.path.join(OUTPUT_PATH, filename), shift_x, shift_y)\n    \n    if shift_x &gt; 0 and shift_x &gt; crop_left:\n        crop_left = shift_x\n    elif shift_x &lt; 0 and abs(shift_x) &gt; crop_right:\n        crop_right = abs(shift_x)\n    elif shift_y &gt; 0 and shift_y &gt; crop_top:\n        crop_top = shift_y\n    elif shift_y &lt; 0 and abs(shift_y) &gt; crop_bottom:\n        crop_bottom = abs(shift_y)\n\n\nCropping images\nBecause of translating we ended up with images with black bars on the sides. We crop images so that these disappear. This way we end up with images that are a bit smaller.\nmin_width = df.width.min()\nmin_height = df.height.min()\n\nfor _, row in df.iterrows():\n    filename = row['file']\n    image = cv2.imread(os.path.join(OUTPUT_PATH, filename))\n    (rows, cols) = image.shape[:2]\n    res = image[crop_top:min_height, crop_left:min_width]\n    cv2.imwrite(os.path.join(OUTPUT_PATH, filename), res)"
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html",
    "href": "posts/exploring-dutch-party-positions/index.html",
    "title": "Exploring Dutch Party Positions",
    "section": "",
    "text": "Dutch general elections are coming up at the end of this month. A lot of people in the Netherlands use the Stemwijzer website to figure out which political party to vote for. You answer 30 statements with Eens (agree), Oneens (disagree), or Geen van beide (neutral), and it shows which parties align most with your answers.\nFor each statement you can see which political parties agree, disagree, or are neutral about it, and why.\nStill, even with tools like this, voting often feels like picking the least bad option. That frustration got me wondering: how different are these parties, really? And in what way? To explore that, I scraped the positions of the various parties on those statements to do some data exploration. I‚Äôll visualize parties in 2D using t-SNE to see if any clusters arise. I‚Äôll also perform a PCA and try to interpret the first two principal components and map them to underlying ideologies."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#how-the-data-was-collected",
    "href": "posts/exploring-dutch-party-positions/index.html#how-the-data-was-collected",
    "title": "Exploring Dutch Party Positions",
    "section": "How the data was collected",
    "text": "How the data was collected\nI wrote a Python script that scrapes the party responses to the 30 statements from the Stemwijzer website. For each statement we get:\n\nThe theme (broad topic label)\nThe statement text\nA short info blurb\nEach party‚Äôs stance: Eens (agree), Oneens (disagree), Geen van beide (neutral)\nA short explanation per party (why they answered that way)\n\nThe script saves the scraped data as tweedekamer2025.json."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#importing-libraries",
    "href": "posts/exploring-dutch-party-positions/index.html#importing-libraries",
    "title": "Exploring Dutch Party Positions",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe are going to need the following dependencies.\n\nfrom PIL import Image\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom wordcloud import WordCloud\nfrom nltk.corpus import stopwords\nfrom sklearn.manifold import TSNE\nfrom sklearn.decomposition import PCA\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport nltk\nimport json"
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#loading-the-json",
    "href": "posts/exploring-dutch-party-positions/index.html#loading-the-json",
    "title": "Exploring Dutch Party Positions",
    "section": "Loading the JSON",
    "text": "Loading the JSON\nWe start our analysis by loading the JSON file produced by the scraper. Each entry contains a statement plus per‚Äëparty responses. We‚Äôll reshape it into a dataframe where each row is one issue and columns hold party positions and their explanation texts.\n\nwith open('tweedekamer2025.json', 'r', encoding='utf-8') as f:\n    data = json.load(f)\n\n# We flatten the 'positions' list, keeping 'theme', 'title', and 'info' as identifying metadata.\ndf_long = pd.json_normalize(\n    data, \n    record_path='positions', \n    meta=['theme', 'title', 'info']\n)\n\n# Rename the columns for clarity before pivoting\ndf_long['position_col'] = df_long['party'] + '_position'\ndf_long['explanation_col'] = df_long['party'] + '_explanation'\n\n# We create one table for 'position' data\ndf_position = df_long.pivot_table(\n    index=['theme', 'title', 'info'], \n    columns='position_col', \n    values='position', \n    aggfunc='first'\n).reset_index()\n\n# We create a second table for 'explanation' data\ndf_explanation = df_long.pivot_table(\n    index=['theme', 'title', 'info'], \n    columns='explanation_col', \n    values='explanation', \n    aggfunc='first'\n).reset_index()\n\n# We merge on the common descriptive columns: 'theme', 'title', and 'info'\ndf_merged = pd.merge(\n    df_position, \n    df_explanation, \n    on=['theme', 'title', 'info']\n)\n\n# Sort the columns to get party columns adjacent (e.g., SP_position, SP_explanation)\nparty_cols = [col for col in df_merged.columns if col not in ['theme', 'title', 'info']]\nparty_cols.sort(key=lambda x: (x.split('_')[0], x.split('_')[1] == 'explanation'))\n\n# Combine the descriptive columns with the sorted party columns\nfinal_columns = ['theme', 'title', 'info'] + party_cols\ndf_final = df_merged[final_columns]"
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#a-quick-peek-at-the-data",
    "href": "posts/exploring-dutch-party-positions/index.html#a-quick-peek-at-the-data",
    "title": "Exploring Dutch Party Positions",
    "section": "A quick peek at the data",
    "text": "A quick peek at the data\nBefore diving into visualizations let‚Äôs sanity‚Äëcheck what we have so far:\nLet‚Äôs look at the first few rows.\n\ndf_final.head()\n\n\n\n\n\n\n\n\ntheme\ntitle\ninfo\n50PLUS_position\n50PLUS_explanation\nBBB_position\nBBB_explanation\nBIJ1_position\nBIJ1_explanation\nBVNL_position\n...\nSP_position\nSP_explanation\nVVD_position\nVVD_explanation\nVolt_position\nVolt_explanation\nVrede voor Dieren_position\nVrede voor Dieren_explanation\nVrij Verbond_position\nVrij Verbond_explanation\n\n\n\n\n0\nAanwezigheid bij demonstratie\nDe politie moet bijhouden wie aanwezig is bij ...\nIn Nederland heb je het recht om te demonstrer...\nEens\nBetere handhaving en strenger optreden bij ove...\nOneens\nStandaard moeten bijhouden wie een verboden de...\nOneens\nIedereen moet veilig kunnen demonstreren. Het ...\nOneens\n...\nOneens\nDemonstreren is een grondrecht. Iedereen heeft...\nEens\nDe VVD wil dat de politie alle mogelijkheden k...\nOneens\nVolt beschermt het recht op protest. Demonstra...\nOneens\nDemonstratierecht is een groot goed.\nOneens\nVrij Verbond kiest voor maximale bescherming v...\n\n\n1\nAbortus\nAbortus moet uit het Wetboek van Strafrecht .\nAbortus is het afbreken van een zwangerschap d...\nEens\n50PLUS ziet abortus niet als strafrecht maar m...\nOneens\nAbortus hoort in het Wetboek van Strafrecht th...\nEens\nAbortus is een mensenrecht en hoort bij basisg...\nOneens\n...\nEens\nAbortuszorg is zorg en hoort daarom niet thuis...\nEens\nAbortus is geen misdrijf. Als VVD vinden we he...\nEens\nVolt vindt dat vrouwen het recht hebben om ove...\nEens\nZelfbeschikking is geen misdaad maar een recht.\nEens\nAbortus is een medische keuze, geen misdaad. V...\n\n\n2\nBouwen op landbouwgrond\nDe regering moet het bouwen van woningen op la...\nGemeentes die woningen willen laten bouwen, mo...\nEens\nAls een paar % van de totale landbouwgrond voo...\nOneens\nOnze vruchtbare landbouwgrond is waardevol. BB...\nEens\nMet name de (melk)veehouderij neemt ontzettend...\nOneens\n...\nEens\nDe woningnood is groot en vraagt om nieuwe bou...\nEens\nDe VVD wil flink schrappen in het aantal bouwr...\nEens\nVolt wil sneller woningen bouwen, ook op landb...\nEens\nWe willen landbouwgrond voor 90% omzetten in n...\nEens\nMeer woningen zijn hard nodig. Laat grondeigen...\n\n\n3\nControle op religieuze les\nDe overheid moet strenger controleren wat jong...\nDe overheid heeft regels gemaakt voor scholen ...\nEens\nOnderwijs controle wordt uitgevoerd door de in...\nEens\nBuitenlandse mogendheden steken graag hun lang...\nOneens\nDe surveillance van religieuze groepen belemme...\nEens\n...\nEens\nIedereen mag geloven wat hij wil, maar onderwi...\nEens\nVoor het aanleren van onvrije waarden is in ge...\nOneens\nVolt staat voor gelijke behandeling. Discrimin...\nOneens\nNederland heeft vrijheid van godsdienst.\nOneens\nVrijheid van onderwijs en geloof staat centraa...\n\n\n4\nEigen risico zorgverzekering\nHet eigen risico bij zorgverzekeringen wordt p...\nIn Nederland ben je verplicht een zorgverzeker...\nOneens\nDit leidt tot toename koopkracht. Zeer wenseli...\nOneens\nHet is belangrijk dat zorg toegankelijk en bet...\nOneens\nWe zetten een Nationaal Zorgfonds op dat de pr...\nEens\n...\nOneens\nHet eigen risico is een boete op ziek zijn. Da...\nEens\nHet eigen risico is voor ons belangrijk om de ...\nEens\nVolt wil dat zorg betaalbaar blijft voor ieder...\nOneens\nDe zorg moet voor iedereen betaalbaar zijn.\nEens\nVrij Verbond kiest voor een eerlijk zorgstelse...\n\n\n\n\n5 rows √ó 51 columns\n\n\n\nEach row equals one statement (issue) from Stemwijzer. For every party we have two columns: one categorical position (_position) and one short text explanation (_explanation).\nWe should have 30 issues for 24 parties.\n\nnum_parties = len([col for col in df_position.columns if col.endswith('_position')])\nnum_issues = df_position.shape[0]\n\nprint(f\"Number of parties: {num_parties}\")\nprint(f\"Number of issues: {num_issues}\")\n\nNumber of parties: 24\nNumber of issues: 30"
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#what-do-the-various-parties-think-about-each-issue",
    "href": "posts/exploring-dutch-party-positions/index.html#what-do-the-various-parties-think-about-each-issue",
    "title": "Exploring Dutch Party Positions",
    "section": "What do the various parties think about each issue?",
    "text": "What do the various parties think about each issue?\nWe‚Äôll plot a bar chart per statement showing counts of parties that agree, disagree, or stay neutral.\nWe add logos to each bar so we can see which party thinks what.\n\n# List of parties in the order they appear in the image\nparties = [\n    'PVV', 'GroenLinks-PvdA', 'VVD', 'NSC', 'D66', 'BBB', 'CDA', \n    'SP', 'DENK', 'Partij voor de Dieren', 'FvD', 'SGP', 'ChristenUnie', \n    'Volt', 'JA21', 'Vrede voor Dieren', 'BVNL', 'BIJ1', 'Libertaire Partij', \n    '50PLUS', 'Piratenpartij', 'FNP', 'Vrij Verbond', 'De Linie'\n]\n\n# Load the image\nimg = Image.open('parties.png')\n\n# Get image dimensions\nwidth, height = img.size\n\n# Find the logo's height:\nnum_parties = len(parties)\nlogo_height = height // num_parties\n\n# Cut each logo and store in a dictionary\nparty_logos = {}\nfor i in range(num_parties):\n    top = i * logo_height\n    bottom = (i + 1) * logo_height\n    logo = img.crop((0, top, width, bottom))\n    party_logos[parties[i]] = logo\n\nNext we create a bar chart for each of the 30 issues.\n\n# Get all party position columns\nposition_cols = [col for col in df_position.columns if col.endswith('_position')]\n\n# Plotting\nfig, axes = plt.subplots(10, 3, figsize=(12, 60), constrained_layout=True)\naxes = axes.flatten()\n\ndef text_wrap(text, width=40):\n    \"\"\"Wrap text at word boundaries.\"\"\"\n    import textwrap\n    return \"\\n\".join(textwrap.wrap(text, width=width))\n\ndef bold_text_with_spaces(text):\n    \"\"\"Make text bold while preserving spaces\"\"\"\n    return ' '.join(f'$\\\\mathbf{{{word}}}$' for word in text.split())\n\ndef add_party_logos(ax, row):\n    \"\"\"Add party logos for each position\"\"\"\n    y_offsets = [0] * 3  # Track y-offset for each column (Eens, Oneens, Geen van beide)\n    \n    # First, count how many parties are in each position to calculate bar heights\n    counts = {'Eens': 0, 'Oneens': 0, 'Geen van beide': 0}\n    for pos in [val for col, val in row.items() if col.endswith('_position')]:\n        if pd.notna(pos):\n            counts[pos] += 1\n    \n    # Draw the bars\n    x = np.arange(3)\n    ax.bar(x, [((counts['Eens'] + 1) // 2) * 2.2, ((counts['Oneens'] + 1) // 2) * 2.2, ((counts['Geen van beide'] + 1) // 2) * 2.2], \n           color='white', edgecolor=['green', 'red', 'grey'], alpha=0.8, width=0.65)\n    # Add counts to the top of each bar (except when count is 0)\n    for idx, (label, count) in enumerate(counts.items()):\n        if count &gt; 0:\n            ax.text(\n                idx, \n                ((count + 1) // 2) * 2.2 + 0.2, \n                str(count), \n                ha='center', \n                va='bottom', \n                fontsize=12, \n                fontweight='bold'\n            )\n    \n    # Now add logos\n    for party, pos in [(col.replace('_position', ''), val) for col, val in row.items() if col.endswith('_position')]:\n        if party in party_logos and pd.notna(pos):\n            if pos == 'Eens':\n                x = 0\n            elif pos == 'Oneens':\n                x = 1\n            else:  # Geen van beide\n                x = 2\n                \n            # Convert logo to array and add to plot\n            logo = party_logos[party]\n            imagebox = OffsetImage(logo, zoom=0.2)\n            if y_offsets[x] % 2 == 0:\n                shift_x = x + 0.15\n            else:\n                shift_x = x - 0.15\n            y = (y_offsets[x] // 2) * 2.2 + 1.1\n            ab = AnnotationBbox(imagebox, (shift_x, y),\n                              frameon=False,\n                              box_alignment=(0.5, 0.5))\n            ax.add_artist(ab)\n            y_offsets[x] += 1\n\nfor i, ax in enumerate(axes):\n    if i &lt; len(df_position.index):\n        row = df_position.iloc[i]\n        \n        # Set theme as main title and wrapped title as subtitle\n        ax.set_title(\n            f\"{bold_text_with_spaces(row['theme'])}\\n{text_wrap(row['title'])}\", \n            fontsize=10, \n            pad=15,\n            wrap=True\n        )\n        \n        # Set up the axes\n        ax.set_xlim(-0.5, 2.5)\n        ax.set_ylim(0.0, len(position_cols))\n        ax.set_xticks([0, 1, 2])\n        ax.set_xticklabels(['Eens', 'Oneens', 'Geen van beide'], rotation=0)\n        \n        # Add party logos\n        add_party_logos(ax, row)\n        \n        # Remove y-axis\n        ax.set_yticks([])\n    else:\n        ax.axis('off')\n\nplt.suptitle('Distribution of party positions per theme', fontsize=16)\nplt.show()\n\n\n\n\n\n\n\n\nThe theme of Illegaal verblijf (‚ÄúIllegal stay‚Äù) is the most divisive issue, with an even split of parties agreeing and disagreeing. Conversely, the Heffing op plastic (‚ÄúPlastic tax‚Äù) is the least divisive, showing a strong consensus among most parties."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#what-reasons-do-parties-give-when-they-explain-their-positions",
    "href": "posts/exploring-dutch-party-positions/index.html#what-reasons-do-parties-give-when-they-explain-their-positions",
    "title": "Exploring Dutch Party Positions",
    "section": "What reasons do parties give when they explain their positions?",
    "text": "What reasons do parties give when they explain their positions?\nTo get an idea of what some reasons are for agreeing or disagreeing with a statement I‚Äôll plot a word cloud for each issue. In word clouds the size of a word indicates how frequently this word is used.\nWe remove stopwords to make sure the word clouds aren‚Äôt crowded with irrelevant words.\n\n# Ensure NLTK stopwords are downloaded and get Dutch stopwords\nnltk.download('stopwords')\ndutch_stopwords = set(stopwords.words('dutch'))\n\n[nltk_data] Downloading package stopwords to /home/aswin/nltk_data...\n[nltk_data]   Package stopwords is already up-to-date!\n\n\nI‚Äôm color coding the words as follows: A word is shown in green if it‚Äôs more frequently used among agreeing parties and in red if disagreeing parties use this word more.\n\ndef generate_color_func(agree_words, disagree_words):\n    \"\"\"Generate a color function based on word frequencies in agree/disagree groups\"\"\"\n    def color_func(word, **kwargs):\n        # Get frequencies (default to 0 if word not in dict)\n        agree_freq = agree_words.get(word, 0)\n        disagree_freq = disagree_words.get(word, 0)\n        \n        # Calculate ratio (avoiding division by zero)\n        total = agree_freq + disagree_freq\n        if total == 0:\n            return 'grey'\n        \n        ratio = agree_freq / total\n        \n        # Create RGB color based on ratio (green to red gradient)\n        r = int(255 * (1 - ratio))\n        g = int(255 * ratio)\n        b = 0\n        \n        return f'rgb({r}, {g}, {b})'\n    return color_func\n\ndef create_word_frequencies(text_list):\n    \"\"\"Create word frequency dictionary from list of texts\"\"\"\n    from collections import Counter\n    import string\n    \n    # Create translation table to remove punctuation\n    translator = str.maketrans('', '', string.punctuation)\n    \n    words = []\n    for text in text_list:\n        if isinstance(text, str):\n            # Remove punctuation and split into words\n            clean_text = text.translate(translator)\n            # Split text into words and filter out stopwords\n            words.extend([word.lower() for word in clean_text.split() \n                         if word.lower() not in dutch_stopwords \n                         and len(word) &gt; 2])\n    return Counter(words)\n\n\n# Create word clouds for each issue\nfig, axes = plt.subplots(6, 5, figsize=(18, 23))\naxes = axes.flatten()\n\nfor idx, (_, row) in enumerate(df_final.iterrows()):\n    if idx &gt;= len(axes):\n        break\n        \n    # Get explanations for parties that agree and disagree\n    agree_explanations = []\n    disagree_explanations = []\n    \n    for party in parties:\n        pos_col = f'{party}_position'\n        exp_col = f'{party}_explanation'\n        \n        if pos_col in row and exp_col in row and pd.notna(row[pos_col]) and pd.notna(row[exp_col]):\n            if row[pos_col] == 'Eens':\n                agree_explanations.append(row[exp_col])\n            elif row[pos_col] == 'Oneens':\n                disagree_explanations.append(row[exp_col])\n    \n    # Create word frequencies for each group\n    agree_words = create_word_frequencies(agree_explanations)\n    disagree_words = create_word_frequencies(disagree_explanations)\n    \n    # Combine all words for the word cloud\n    all_words = {}\n    for word in set(list(agree_words.keys()) + list(disagree_words.keys())):\n        all_words[word] = max(agree_words.get(word, 0), disagree_words.get(word, 0))\n    \n    if all_words:  # Only create word cloud if we have words\n        # Create and generate word cloud\n        wc = WordCloud(width=400, height=300, background_color='white', \n                      color_func=generate_color_func(agree_words, disagree_words),\n                      max_words=50)\n        wc.generate_from_frequencies(all_words)\n        \n        # Display word cloud\n        axes[idx].imshow(wc, interpolation='bilinear')\n        axes[idx].axis('off')\n        axes[idx].set_title(\n            f\"{bold_text_with_spaces(row['theme'])}\\n{text_wrap(row['title'])}\", \n            fontsize=10, \n            pad=15,\n            wrap=True\n        )\n\n# Remove empty subplots\nfor idx in range(len(df_final), len(axes)):\n    axes[idx].axis('off')\n\nplt.suptitle('Words used in party explanations\\n(Green: Words from agreeing parties, Red: Words from disagreeing parties)', \n             fontsize=16, y=0.99)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nWhen we, for instance, look at the word cloud for the issue of kerncentrales (‚Äúnuclear power plants‚Äù), parties that support building extra nuclear power plants, use words like reliable, stable, and clean, while opponents use words like costly, and slow refering to the building process."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#how-similarly-do-parties-answer-across-all-30-statements",
    "href": "posts/exploring-dutch-party-positions/index.html#how-similarly-do-parties-answer-across-all-30-statements",
    "title": "Exploring Dutch Party Positions",
    "section": "How similarly do parties answer across all 30 statements?",
    "text": "How similarly do parties answer across all 30 statements?\nFor each pair we compute the % of statements where both gave the same response (agree, disagree, or neutral).\n\n# Get the raw positions (without encoding)\ndf_positions = df_position[position_cols]\n\n# Clean up party names by removing '_position' suffix\nparty_names = [col.replace('_position', '') for col in position_cols]\n\n# Initialize agreement matrix with zeros, explicitly setting dtype to float64\nagreement_matrix = pd.DataFrame(0.0, index=party_names, columns=party_names, dtype='float64')\n\n# Calculate agreement percentages\nfor i, party1 in enumerate(position_cols):\n    for j, party2 in enumerate(position_cols):\n        # Get positions for both parties where neither is null\n        mask = df_positions[party1].notna() & df_positions[party2].notna()\n        positions1 = df_positions[party1][mask]\n        positions2 = df_positions[party2][mask]\n        \n        if len(positions1) &gt; 0:  # Only calculate if we have valid positions\n            # Count where both agree:\n            # - both Eens\n            # - both Oneens\n            # - both Geen van beide\n            agreements = ((positions1 == 'Eens') & (positions2 == 'Eens')) | \\\n                        ((positions1 == 'Oneens') & (positions2 == 'Oneens')) | \\\n                        ((positions1 == 'Geen van beide') & (positions2 == 'Geen van beide'))\n            \n            # Calculate percentage\n            agreement_pct = (agreements.sum() / len(positions1)) * 100\n            \n            # Store in matrix using cleaned party names\n            agreement_matrix.iloc[i, j] = agreement_pct\n\n# Round to 1 decimal place\nagreement_matrix = agreement_matrix.round(1)\n\nWe use a heatmap to visualize the result.\n\nplt.figure(figsize=(15, 15))\nim = plt.imshow(agreement_matrix, cmap='RdYlBu', vmin=0, vmax=100)\nplt.colorbar(im, fraction=0.046, pad=0.04, label='Agreement %')\nplt.xticks(range(len(party_names)), party_names, rotation=90)\nplt.yticks(range(len(party_names)), party_names)\nplt.title('Percentage of issues on which parties agree')\n\n# Add percentage text to each cell\nfor i in range(len(party_names)):\n    for j in range(len(party_names)):\n        text = plt.text(j, i, f'{agreement_matrix.iloc[i, j]}%',\n                       ha='center', va='center')\n        \nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nCells show % agreement. The 100% values on the main diagonal are expected, as a party always agrees with its own answers."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#what-parties-are-the-most-and-the-least-in-agreement-with-each-other",
    "href": "posts/exploring-dutch-party-positions/index.html#what-parties-are-the-most-and-the-least-in-agreement-with-each-other",
    "title": "Exploring Dutch Party Positions",
    "section": "What parties are the most and the least in agreement with each other?",
    "text": "What parties are the most and the least in agreement with each other?\nIgnoring the 100% self-agreement, what are the highest and lowest agreement pairs?\n\nmin_agreement = agreement_matrix.values.min()\n\n# Find the second largest unique agreement value\nunique_agreements = np.unique(agreement_matrix.values)\nif len(unique_agreements) &gt; 1:\n    max_agreement = unique_agreements[-2]\nelse:\n    max_agreement = unique_agreements[0]\n\nprint(f\"Minimal agreement percentage: {min_agreement}%\")\nprint(f\"Maximal agreement percentage: {max_agreement}%\")\n\nMinimal agreement percentage: 13.3%\nMaximal agreement percentage: 93.3%\n\n\nThese are the parties with highest agreement levels:\n\n# Find all party pairs with the second largest agreement\nsecond_max_pairs = []\nfor i in range(len(party_names)):\n    for j in range(i + 1, len(party_names)):\n        if agreement_matrix.iloc[i, j] == max_agreement:\n            second_max_pairs.append((party_names[i], party_names[j]))\n\nfor p1, p2 in second_max_pairs:\n    print(f\"{p1} ‚ù§Ô∏è {p2}: {max_agreement}%\")\n\nBIJ1 ‚ù§Ô∏è Piratenpartij: 93.3%\n\n\nThe parties with the lowest agreement levels are:\n\n# Find party pairs for min_agreement\nparty_pairs = []\nfor i in range(len(party_names)):\n    for j in range(i + 1, len(party_names)):\n        value = agreement_matrix.iloc[i, j]\n        if value == min_agreement:\n            party_pairs.append((party_names[i], party_names[j]))\n\nfor p1, p2 in party_pairs:\n    print(f\"{p1} üíî {p2}: {min_agreement}%\")\n\nFvD üíî GroenLinks-PvdA: 13.3%\nPVV üíî Volt: 13.3%\n\n\nWe have to take into consideration that the statements on the Stemwijzer website are chosen such that we can differentiate between parties. It‚Äôs likely that on many issues, seemingly very dissimilar parties like the FvD and GroenLinks-PvdA, actually agree with each other. It wouldn‚Äôt make sense to use those issues as statements for Stemwijzer as they wouldn‚Äôt help a voter distinguish between parties."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#squeezing-30-issues-into-2d-using-t-sne",
    "href": "posts/exploring-dutch-party-positions/index.html#squeezing-30-issues-into-2d-using-t-sne",
    "title": "Exploring Dutch Party Positions",
    "section": "Squeezing 30 issues into 2D using t-SNE",
    "text": "Squeezing 30 issues into 2D using t-SNE\nBy encoding Eens (agree) as 1, Oneens (disagree) as -1, and Geen van beide (neutral) as 0, we transform each party‚Äôs stance into a quantifiable, 30-dimensional vector.\n\npd.set_option('future.no_silent_downcasting', True)\n\n# Create encoded dataframe by mapping positions to numerical values\nposition_mapping = {\n    'Eens': 1.0,\n    'Oneens': -1.0,\n    'Geen van beide': 0.0\n}\n\n# Get only the position columns and convert to numeric values\nposition_cols = [col for col in df_position.columns if col.endswith('_position')]\ndf_encoded = df_position[position_cols].copy()\ndf_encoded = df_encoded.replace(position_mapping)\n\n# Convert to float64\ndf_encoded = df_encoded.astype('float64')\n\nWe can now project the parties into 2D using t-SNE (t-distributed Stochastic Neighbor Embedding).\nThe idea behind t-SNE is that local neighborhoods are reserved by making sure that points close together in original space stay close in 2D.\nLet‚Äôs run it to see if clusters emerge.\n\n# Prepare the encoded party positions\nX = df_encoded.values\n\n# Run t-SNE\ntsne = TSNE(n_components=2, random_state=4, perplexity=5)\nX_embedded = tsne.fit_transform(X.T)  # transpose so shape is (n_parties, n_issues)\n\n# Plot the parties in 2D space\nplt.figure(figsize=(10, 10))\n\n# Add party logos and points\nfor i, name in enumerate(party_names):\n    # Add the scatter point\n    plt.scatter(X_embedded[i, 0], X_embedded[i, 1], color='white', edgecolor='black', s=100)\n    \n    # Add the party logo\n    if name in party_logos:\n        imagebox = OffsetImage(party_logos[name], zoom=0.25)\n        ab = AnnotationBbox(imagebox, (X_embedded[i, 0], X_embedded[i, 1]),\n                          frameon=False,\n                          box_alignment=(0.5, 0.5))\n        plt.gca().add_artist(ab)\n    \n    # Add party name below the logo\n    plt.text(X_embedded[i, 0], X_embedded[i, 1] - 5.5, name, \n             fontsize=8, ha='center', va='top')\n\nplt.title('t-SNE visualization of party positions')\nplt.xlabel('t-SNE dimension 1')\nplt.ylabel('t-SNE dimension 2')\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nNothing too surprising here. Parties that were similar in the heatmap above seem to lie closer together in this t-SNE plot as well. Two shortcomings of t-SNE are that it sometimes creates artificial spacing and that axes don‚Äôt really represent anything. Different runs produce different projections."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#doing-a-principal-component-analysis-pca",
    "href": "posts/exploring-dutch-party-positions/index.html#doing-a-principal-component-analysis-pca",
    "title": "Exploring Dutch Party Positions",
    "section": "Doing a Principal Component Analysis (PCA)",
    "text": "Doing a Principal Component Analysis (PCA)\nPCA (Principal Component Analysis) finds orthogonal axes capturing maximal variance. In contrast to t-SNE, axes do have somewhat interpretable meanings. Early components might capture broad ideological splits. Let‚Äôs see if this is the case.\n\n# Prepare the encoded party positions (already created in cell 13)\nX = df_encoded.values\n\n# Run PCA\npca = PCA(n_components=2, random_state=42)\nX_pca = pca.fit_transform(X.T)  # transpose so shape is (n_parties, n_issues)\n\n# Plot the parties in 2D space\nplt.figure(figsize=(10, 10))\nfor i, name in enumerate(party_names):\n    plt.scatter(X_pca[i, 0], X_pca[i, 1])\n\n    # Add the party logo\n    if name in party_logos:\n        imagebox = OffsetImage(party_logos[name], zoom=0.25)\n        ab = AnnotationBbox(imagebox, (X_pca[i, 0], X_pca[i, 1]),\n                          frameon=False,\n                          box_alignment=(0.5, 0.5))\n        plt.gca().add_artist(ab)\n    \n    # Add party name below the logo\n    plt.text(X_pca[i, 0], X_pca[i, 1] - 0.20, name, \n             fontsize=8, ha='center', va='top')\n\nplt.title('PCA visualization of party positions')\nplt.xlabel('PCA dimension 1')\nplt.ylabel('PCA dimension 2')\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nAt first glance PC1 looks like a left‚Äìright axis, but we‚Äôll validate that by inspecting which issues load strongly on it. PC2 might reflect a libertarian‚Äìauthoritarian or progressive‚Äìtraditional divide. We‚Äôll try to interpret these components below."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#how-much-variance-do-components-capture",
    "href": "posts/exploring-dutch-party-positions/index.html#how-much-variance-do-components-capture",
    "title": "Exploring Dutch Party Positions",
    "section": "How much variance do components capture?",
    "text": "How much variance do components capture?\nThe scree plot below shows how much variance is explained by each principal component (PC).\n\n# Fit PCA with all possible components (up to number of parties)\npca_full = PCA(n_components=len(position_cols), random_state=42)\nX = df_encoded.values\npca_full.fit(X.T)  # shape: (n_parties, n_issues)\n\n# Explained variance ratio for each component\nexplained_variance = pca_full.explained_variance_ratio_\n\n# Plot the explained variance ratio\nplt.figure(figsize=(8, 5))\nplt.plot(range(1, len(explained_variance) + 1), explained_variance, marker='o', label='Individual')\nplt.plot(range(1, len(explained_variance) + 1), explained_variance.cumsum(), marker='s', label='Cumulative')\nplt.xlabel('Number of PCA components')\nplt.ylabel('Explained variance ratio')\n\n# Annotate each bar with the percentage of explained variance\nfor i, v in enumerate(explained_variance):\n    plt.text(i + 1, v + 0.005, f\"{v*100:.1f}%\", ha='center', va='bottom', fontsize=9)\nplt.bar(range(1, len(explained_variance) + 1), explained_variance, color='skyblue')\nplt.legend().remove()\nplt.title('Explained variance by PCA components')\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nMost variance is captured by PC1 (38.2%). Explanatory power then drops quickly, but PC2 still captures 13.3% of the variance."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#interpreting-the-axes",
    "href": "posts/exploring-dutch-party-positions/index.html#interpreting-the-axes",
    "title": "Exploring Dutch Party Positions",
    "section": "Interpreting the axes",
    "text": "Interpreting the axes\nLet‚Äôs look at the loading scores of the first two PCs.\n\n# Get PCA loadings (components) for each issue on each factor\n# Create DataFrame with loadings scaled by explained variance\nloadings = pd.DataFrame(\n    data=pca.components_.T * np.sqrt(pca.explained_variance_), \n    columns=[f\"PC{i}\" for i in range(1, pca.n_components_ + 1)],\n    index=df_position['theme']\n)\n\nfig, axs = plt.subplots(2, 1, figsize=(10, 8), sharex=True, sharey=True)\ncolors = [\"#1C3041\", \"#9B1D20\"]\n\nfor i, ax in enumerate(axs):\n    if i &gt;= pca.n_components_:\n        ax.axis('off')\n        continue\n        \n    explained_variance = pca.explained_variance_ratio_[i] * 100\n    pc = f\"PC{i+1}\"\n    bars = ax.bar(range(len(loadings.index)), loadings[pc], color=colors[i], edgecolor=\"#000000\", linewidth=1.2)\n    ax.set_title(f\"{pc} Loading Scores ({explained_variance:.2f}% Explained Variance)\", fontdict={\"weight\": \"bold\"}, pad=20)\n    if i == len(axs) - 1:  # Only add xlabel to the bottom subplot\n        ax.set_xlabel(\"Thema\")\n    ax.set_ylabel(\"Loading Score\")\n    ax.grid(axis=\"y\")\n    ax.set_xticks(range(len(loadings.index)))\n    if i == len(axs) - 1:  # Only add x-tick labels to the bottom subplot\n        ax.set_xticklabels(loadings.index, rotation=90, ha='right', fontsize=9)\n    ax.set_ylim(-1, 1)\n    \n    for j, bar in enumerate(bars):\n        yval = bar.get_height()\n        if abs(yval) &gt; 0.1:  # Only show labels for significant values\n            offset = yval + 0.02 if yval &gt; 0 else yval - 0.02\n            ax.text(bar.get_x() + bar.get_width() / 2, offset, f\"{yval:.2f}\", \n                   ha=\"center\", va=\"bottom\" if yval &gt; 0 else \"top\", fontsize=7)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nStrong loadings tell us which statements ‚Äúpull‚Äù most on a component and can help us discover underlying ideological factors.\nLet‚Äôs look at the five strongest absolute loadings of PC1 and PC2.\n\n# Get absolute loadings for PC1 and PC2\npc1_loadings = loadings['PC1'].abs()\npc2_loadings = loadings['PC2'].abs()\n\n# Get top 5 themes for each component\ntop5_pc1 = pc1_loadings.sort_values(ascending=False).head(5)\ntop5_pc2 = pc2_loadings.sort_values(ascending=False).head(5)\n\nprint(\"Top 5 most important themes for PC1:\")\nfor theme in top5_pc1.index:\n    print(f\"- {theme} (loading: {loadings.loc[theme, 'PC1']:.2f})\")\n\nprint(\"\\nTop 5 most important themes for PC2:\")\nfor theme in top5_pc2.index:\n    print(f\"- {theme} (loading: {loadings.loc[theme, 'PC2']:.2f})\")\n\nTop 5 most important themes for PC1:\n- Illegaal verblijf (loading: 0.88)\n- Geld naar publieke omroep (loading: 0.87)\n- Minder stikstof (loading: -0.87)\n- Wolven (loading: 0.79)\n- Profileren op nationaliteit (loading: -0.77)\n\nTop 5 most important themes for PC2:\n- Leeftijdsgrens sociale media (loading: 0.65)\n- Sekswerk (loading: 0.61)\n- Aanwezigheid bij demonstratie (loading: 0.59)\n- Meer geld voor defensie (loading: 0.51)\n- Meer geld voor ontwikkelingshulp (loading: 0.51)\n\n\nPC1 loads strongly on issues like immigration, environmental rules, and cultural liberalism. In the past, ‚Äúleft‚Äù and ‚Äúright‚Äù mainly referred to views on how much the state should intervene in the market. Today, though, these terms also seem to cover social and cultural topics like immigration, religion, and the environment. So I would say that PC1 does indeed reflect a Left-Right divide, however not the classic economic one.\nPC2 loads primarily on issues involving social regulation, moral permissiveness, and authority (e.g., restrictions on social media use, sex work, and protest). I would therefor interpret it as an Libertarian-Authoritarian dimension, reflecting preferences for individual freedom and permissiveness versus state control and traditional morality."
  },
  {
    "objectID": "posts/exploring-dutch-party-positions/index.html#some-final-remarks",
    "href": "posts/exploring-dutch-party-positions/index.html#some-final-remarks",
    "title": "Exploring Dutch Party Positions",
    "section": "Some final remarks",
    "text": "Some final remarks\nI want to end this post with a few remarks, a disclaimer of sorts.\nI am not a political scientist. I tried to interpret the PCs to the best of my understanding, but someone more knowledgable might interpret the loading scores differently and come up with more accurate labels for the PCs.\nI don‚Äôt know how the 30 issues on the Stemwijzer website are selected but it‚Äôs unlikely that they are an accurate representation of a party‚Äôs viewpoints. By reducing positions to three possible answers we lose any nuance in a party‚Äôs stance. Furthermore, the 30 issues are selected in such a way that they are discriminative: They‚Äôre meant to help you choose between parties. It‚Äôs likely that parties are more similar than the distance matrix/heatmap above suggests.\nAnother thing to keep in mind is that when parties supply their positions to the Stemwijzer website, they likely do so strategically by aligning with what they think most voters would prefer. They‚Äôre trying to rake in votes and might misrepresent their actual stance on certain issues. Politicians can be manipulative and dishonest. Shocking, I know.\nDespite these shortcomings, I did find it insightful to see how the Stemwijzer data shows underlying left-right and libertarian-authoritarian axes. It helped me realize that my vote shouldn‚Äôt just be about agreeing or disagreeing with a list of statements, but also about what level of left-right/libertarian-authoritarian I‚Äôm comfortable with.\nYou can find the code for both the analysis and webscraper in the following GitHub repository:\n\nDon‚Äôt forget to vote!"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html",
    "href": "posts/musikalisches-wuerfelspiel/index.html",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "",
    "text": "In generative AI, music composition is one of the areas in which there has been remarkable progress. Models like Magenta‚Äôs Music Transformer, MuseNet, AIVA, and Riffusion are able to create musical pieces, further blurring the line between human and machine creativity.\nPerhaps surprisingly, the idea of using algorithms for composing music can be traced back to as early as the second half of the 18th century. During this period, the musical dice game, or ‚ÄúMusikalisches W√ºrfelspiel‚Äù, gained popularity in Western Europe. This game allowed anyone, regardless of musical expertise, to compose by rolling dice and consulting charts to pick musical elements and craft original compositions.\nWhile various musical dice games were published during this period, one of the most famous instances is attributed to Wolfgang Amadeus Mozart. It is unclear whether it was Mozart whom actually created this particular version, as it was released by his publisher posthumously. It‚Äôs for the sake of convenience that I‚Äôll refer to this version as Mozart‚Äôs musical dice game, even though it‚Äôs uncertain whether he was the actual creator.\nIn this blog post, we‚Äôll explore Mozart‚Äôs musical dice game and I‚Äôll present a Python implementation. Using this implementation, we‚Äôll be able to generate MIDI messages for playback in digital audio workstations or with MIDI instruments."
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#from-rolling-dice-to-a-musical-composition",
    "href": "posts/musikalisches-wuerfelspiel/index.html#from-rolling-dice-to-a-musical-composition",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "From rolling dice to a musical composition",
    "text": "From rolling dice to a musical composition\nTo play Mozart‚Äôs musical dice game, we‚Äôd need the following:\n\ntwo six-sided dice\na two-part reference chart (Zahlentafel / Table de Chiffres)\n176 music fragments (Table de Musique of which only the first page is shown below)\n\n\n\n\n\n\n\n\n\n\n\nThe numbers in the reference chart (the first image) refer to the music fragments (in the second image). Only the first page containing the first 48 music fragments is shown. You can find the full document containing both the reference chart and all 176 music fragments here.\nThe steps involved in creating a composition are as follows:\nStep 1: Roll a pair of dice 16 times\nFor each roll, note the sum (ranging from 2 to 12) obtained from the two six-sided dice.\nStep 2: Select the corresponding measures from the reference chart and assemble the musical composition.\nUsing the reference chart and the 176 musical fragments, look up the pre-composed music fragment associated with each of your 16 rolls. Each of these fragments becomes a measure in your composition.\nThe first 8 measures will need to be played twice. For this reason you can add the repeat sign ùÑá to the 8th measure. The music fragments under column H (30, 81, 24, 100, 107, 91, 127, 94, 123, 33, and 5) all contain a second variation that needs to be played the second time. For instance, music fragment 30 looks like this:\n\n\n\n\n\nYou can see that the left hand staff for this fragment contains two variations. Variation 1 is played the first time, variation 2 the second time. A cleaner way to represent this is by using volta brackets.\n\n\n\n\n\nThe last 8 measures aren‚Äôt repeated so you can add the final barline symbol ùÑÇ to the last measure.\nCongratulations! You are now a composer.\nThrowing dice and looking up fragments repeatedly is boring. However, before automating this with Python, there‚Äôs one more thing left to explain."
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#whats-midi",
    "href": "posts/musikalisches-wuerfelspiel/index.html#whats-midi",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "What‚Äôs MIDI?",
    "text": "What‚Äôs MIDI?\nMIDI stands for ‚ÄúMusical Instrument Digital Interface‚Äù. It‚Äôs both a file format and a protocol used to communicate with and control various musical instruments, computers, and other electronic devices. MIDI data does not contain actual audio; instead, it consists of instructions that tell devices what sound to produce.\nMIDI messages include information such as note-on and note-off commands, which indicate when a musical note should start and stop playing, as well as data for controlling parameters like pitch, velocity, tempo, and volume.\nWe‚Äôll use MIDI to play back Mozart‚Äôs musical dice game compositions on a digital piano and a digital audio workstation (DAW). The mido library is used to work with MIDI data in Python.\nFun fact: The first version of the MIDI specification was published in August, 1983, which means the standard will be 40 years old next month!"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#importing-libraries",
    "href": "posts/musikalisches-wuerfelspiel/index.html#importing-libraries",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe‚Äôre now ready to implement Mozart‚Äôs musical dice game using Python. Let‚Äôs start by importing the necessary modules:\n\nfrom matplotlib.colors import ListedColormap\nfrom IPython.display import display\n\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nimport numpy as np\nimport mido\nimport time\n\nNote how we import the aforementioned mido module."
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#reference-chart-and-dice-rolls",
    "href": "posts/musikalisches-wuerfelspiel/index.html#reference-chart-and-dice-rolls",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "Reference chart and dice rolls",
    "text": "Reference chart and dice rolls\nThe two part reference chart is represented by a 11x16 numpy array. The numbers in the array indicate the music fragment to be played for each combination of dice rolls.\n\nnumber_table = np.array([\n    [ 96,  22, 141,  41, 105, 122,  11,  30,  70, 121,  26,   9, 112,  49, 109,  14],\n    [ 32,   6, 128,  63, 146,  46, 134,  81, 117,  39, 126,  56, 174,  18, 116,  83],\n    [ 69,  95, 158,  13, 153,  55, 110,  24,  66, 139,  15, 132,  73,  58, 145,  79],\n    [ 40,  17, 113,  85, 161,   2, 159, 100,  90, 176,   7,  34,  67, 160,  52, 170],\n    [148,  74, 163,  45,  80,  97,  36, 107,  25, 143,  64, 125,  76, 136,   1,  93],\n    [104, 157,  27, 167, 154,  68, 118,  91, 138,  71, 150,  29, 101, 162,  23, 151],\n    [152,  60, 171,  53,  99, 133,  21, 127,  16, 155,  57, 175,  43, 168,  89, 172],\n    [119,  84, 114,  50, 140,  86, 169,  94, 120,  88,  48, 166,  51, 115,  72, 111],\n    [ 98, 142,  42, 156,  75, 129,  62, 123,  65,  77,  19,  82, 137,  38, 149,   8],\n    [  3,  87, 165,  61, 135,  47, 147,  33, 102,   4,  31, 164, 144,  59, 173,  78],\n    [ 54, 130,  10, 103,  28,  37, 106,   5,  35,  20, 108,  92,  12, 124,  44, 131]\n])\n\nLet‚Äôs now define a function that displays the reference chart and dice rolls.\n\ndef plot_number_table(number_table, dice_rolls=None):\n    highlight = np.zeros((11, 16))\n    if dice_rolls is not None:\n        row_indices = dice_rolls - 2\n        column_indices = np.arange(16)\n        highlight[row_indices, column_indices] = 1\n\n    plt.figure(\"Musikalisches W√ºrfelspiel\", figsize=(9.6, 7.2))\n    plt.imshow(highlight, cmap=ListedColormap([\"white\", \"lightseagreen\"]))\n    for y in range(number_table.shape[0]):\n        for x in range(number_table.shape[1]):\n            plt.text(x, y, '%d' % number_table[y, x], fontsize=14, \n                horizontalalignment='center', verticalalignment='center')\n\n    plt.xticks(list(range(0,16)), list(range(1, 17)))\n    plt.yticks(list(range(0,11)), list(range(2, 13)))\n    plt.xlabel(\"Measure\")\n    plt.ylabel(\"Dice roll\")\n    plt.show()\n\nThis function takes two parameters: the reference chart and the dice rolls. If the dice rolls are not provided, the reference chart is displayed without highlighting any cells.\nBefore calling this function, let‚Äôs simulate rolling two dice 16 times. We do that using the following code:\n\n# Throw two dice 16 times\ndice_rolls = np.sum(np.random.randint(1, 7, size=(2, 16)), axis=0)\n\nYou might be wondering why we don‚Äôt simply write:\ndice_rolls = np.random.randint(2, 13, size=(1, 16))\nThe reason is that this would result in values being drawn from a discrete uniform distribution. The sum of a roll of two dice however isn‚Äôt uniformly distributed. The probability distribution of the sum of two dice is instead given by:\n\\[p(x) = \\begin{cases}\n  \\frac{x - 1}{36} & \\text{if $x \\in \\{2, 3, 4, 5, 6, 7\\}$}\\\\\n  \\frac{13 - x}{36} & \\text{if $x \\in \\{7, 8, 9, 10, 11, 12\\}$}\\\\\n  0 & \\text{otherwise}\n  \\end{cases}\n\\]\nThis may be called a discrete triangular distribution. It‚Äôs perfectly fine to draw from either distribution, but the triangular distribution is more akin to rolling actual dice.\nLet‚Äôs now display the reference chart and the dice rolls.\n\nplot_number_table(number_table, dice_rolls)"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#music-fragments",
    "href": "posts/musikalisches-wuerfelspiel/index.html#music-fragments",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "Music fragments",
    "text": "Music fragments\nI used MuseScore to digitize all music fragments into one MIDI file. Each fragment consists of one measure, except fragments 30, 81, 24, 100, 107, 91, 127, 94, 123, 33, and 5. They contain a second variation which has been put into a separate measure immediately following the measure that contain the first variation. This gives us a total of 187 measures. Let‚Äôs now read in this MIDI file.\n\nmidi_file = mido.MidiFile('musikalisches_wuerfelspiel.mid')\n\nAs described above, a MIDI file consists of MIDI messages. The following function extracts the MIDI messages between two time stamps. It is used to extract the MIDI messages corresponding to a single measure. There are different kinds of messages, but we are only interested in the note_on and note_off messages.\n\ndef get_fragment(midi_file, time_start, time_end):\n    proc_time = 0.0\n    \n    for msg in midi_file:\n        if not isinstance(msg, mido.MetaMessage) and msg.type != 'control_change':\n            proc_time += msg.time\n            if proc_time &gt;= time_start and proc_time &lt;= time_end:\n                yield msg                \n\nWe use MIDI control change messages to initialize the receiving instrument or DAW. The following function extracts them from our MIDI file.\n\ndef get_control_change_messages(midi_file):\n    for msg in midi_file:\n        if not isinstance(msg, mido.MetaMessage) and msg.type == 'control_change':\n            yield msg\n\nThe following helper function returns the index of the measure that contains a given fragment. Because some fragments are split into two measures (the ones with a variation, the 8th dice roll), the fragments that come after these all shift one up.\n\ndef get_measure_index(number_table, number):\n    eighth_column = number_table[:, 7]  # 7 represents the 8th column\n    count = np.sum(eighth_column &lt; number)\n    return number + count\n\nThe following function first generates the control change messages, and then the MIDI messages for the fragments corresponding to each dice roll.\nIt starts by calculating the duration of one measure and uses this to determine the time stamps for the start and end of each measure. It then extracts the MIDI messages for each fragment and yields them.\n\ndef get_dice_roll_fragments(midi_file, number_table, dice_rolls):\n    measure_duration = sum([msg.time for msg in midi_file if not isinstance(msg, mido.MetaMessage)]) / (number_table.shape[0] * (number_table.shape[1]+1))\n    measures = number_table[dice_rolls - 2, np.arange(16)]\n\n    yield from get_control_change_messages(midi_file)\n    \n    for i in range(2): # repeat measures 1 to 8\n        for j in range(0, 8):\n            index = get_measure_index(number_table, measures[j]) + (i if j == 7 else 0)\n            yield from get_fragment(midi_file, measure_duration * (index-1), measure_duration * index)\n    for j in range(8, 16):\n        index = get_measure_index(number_table, measures[j])\n        yield from get_fragment(midi_file, measure_duration * (index-1), measure_duration * index)\n\nThe next function calculates the time stamps for the start of each MIDI message. It then waits until the current time is equal to or greater than the time stamp for the next MIDI message before yielding it. We use this function to play the MIDI messages at the correct speed to a MIDI output port.\n\ndef play_dice_roll_fragments(midi_file, number_table, dice_rolls):\n    # generate all MIDI messages in advance\n    messages = list(get_dice_roll_fragments(midi_file, number_table, dice_rolls))\n    \n    start_time = time.time()\n    input_time = 0.0\n\n    for msg in messages:\n        input_time += msg.time\n    \n        playback_time = time.time() - start_time\n        duration_to_next_event = input_time - playback_time\n    \n        if duration_to_next_event &gt; 0.0:\n            time.sleep(duration_to_next_event)\n    \n        yield msg"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#building-a-gui",
    "href": "posts/musikalisches-wuerfelspiel/index.html#building-a-gui",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "Building a GUI",
    "text": "Building a GUI\nFinally, we can create a simple GUI that allows us to generate compositions and send the MIDI messages to a DAW or MIDI instrument.\noutput_dropdown = widgets.Dropdown(\n    options=np.unique(mido.get_output_names()),\n    description='MIDI output:',\n    disabled=False,\n)\n\nrandomize_button = widgets.Button(icon='dice', description='Throw dice')\nplay_button = widgets.Button(icon='play', description='Play')\n\noutput = widgets.Output()\n\nhbox = widgets.HBox([randomize_button, play_button])\nvbox = widgets.VBox([output_dropdown, hbox, output])\nOne button is to roll the dice and the other is to play the composition. The output is a plot of the dice rolls. We use a dropdown to select which MIDI output port to use.\n\ndef randomize_button_clicked(b=None):\n    global dice_rolls\n    dice_rolls = np.sum(np.random.randint(1, 7, size=(2, 16)), axis=0)\n    with output:\n        output.clear_output(wait=True)\n        plot_number_table(number_table, dice_rolls)\n\nrandomize_button.on_click(randomize_button_clicked)\n\ndef play_button_clicked(b):    \n    midi_output = mido.open_output(output_dropdown.value)\n    \n    for msg in play_dice_roll_fragments(midi_file, number_table, dice_rolls):\n        midi_output.send(msg)\n    \nplay_button.on_click(play_button_clicked)\n\nFinally we display the GUI.\nrandomize_button_clicked()\n\ndisplay(vbox)"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#sending-midi-messages-to-a-daw",
    "href": "posts/musikalisches-wuerfelspiel/index.html#sending-midi-messages-to-a-daw",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "Sending MIDI messages to a DAW",
    "text": "Sending MIDI messages to a DAW\nNow we can send the MIDI messages to a DAW to play (and optionally record) our masterpieces. I‚Äôm using the free DAW LMMS here but any DAW should work.\n\n\n\nIf you record the MIDI messages, make sure you set the tempo to 80 BPM and the time signature to 3/8 so the notes get quantized correctly.\nJust listen to this gem!\n\n\nBeautiful, wouldn‚Äôt you agree?!"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#a-piano-performance",
    "href": "posts/musikalisches-wuerfelspiel/index.html#a-piano-performance",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "A piano performance",
    "text": "A piano performance\nLet me perform a composition for you on my piano.\n\nNot only am I a composer, I‚Äôm a performer too. Carnegie Hall, here I come! (Don‚Äôt mind the MIDI cable running from my laptop to the piano.)"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#conclusion",
    "href": "posts/musikalisches-wuerfelspiel/index.html#conclusion",
    "title": "Musikalisches W√ºrfelspiel",
    "section": "Conclusion",
    "text": "Conclusion\nWhether or not the pieces created using this method can be called original is a matter of perspective.\nDespite the random assembly, the musical dice game was designed in such a way that the chord progressions and harmonic structure would remain consistent throughout the pieces. This ensures that the musical phrases fit together harmoniously, creating a sense of coherence and musical flow. Furthermore, Mozart (or the actual composer) likely incorporated musical rules and guidelines while creating the precomposed measures. These rules would ensure that the resulting compositions maintain a certain level of musical quality and avoid dissonance or jarring transitions.\nThe resulting compositions may sound pretty good, but after a while they start to become repetitive. Nonetheless, Mozart‚Äôs Musikalisches W√ºrfelspiel and similar musical dice games remain a fascinating historical example of how composers experimented with generative techniques long before the advent of computers and sophisticated software.\nIf you want to create your own pieces, you can find the code in the following GitHub repository:\n\nHappy ‚Äúcomposing‚Äù!"
  },
  {
    "objectID": "posts/word-search-clock/index.html",
    "href": "posts/word-search-clock/index.html",
    "title": "Word Search Clock",
    "section": "",
    "text": "A few weeks ago, my clock stopped working, and I wasn‚Äôt inclined to invest in a replacement. After futile attempts to revive it, I decided to get crafty. I had an unused photo frame collecting dust and realized it could be turned into a clock by making it display images that show the time of the day. I‚Äôd need one image for every minute of the day and display each of them for 60 seconds before transitioning to the next one.\nUsing pictures that show a digital clock seemed too mundane. Analog faces felt a bit lackluster. Then it hit me‚Äîwhy not combine the charm of word clocks with the visuals of a word search puzzle? The outcome: a word clock that shows words not just horizontally but also vertically and diagonally. Brilliant, if I may say so myself.\nEvery minute, the photo frame displays an image featuring a different set of highlighted words that indicate the current time.\nCurious about how I generated these images? Dive into the details below."
  },
  {
    "objectID": "posts/word-search-clock/index.html#design-decisions",
    "href": "posts/word-search-clock/index.html#design-decisions",
    "title": "Word Search Clock",
    "section": "Design decisions",
    "text": "Design decisions\n\nArranging words in a grid\nMy intention was to position words both horizontally, vertically, and diagonally, similar to word search puzzles, allowing for occasional partial overlaps. To ensure a singular way of reading the time, I established the following criteria:\n\nEach letter can only be the first letter in a word once.\nWords should follow a specific order.\nDue to varying word orientations, the first letter in each word dictates the reading sequence.\n\nIn simpler terms, by scanning the grid left to right and top to bottom and identifying whether each letter marks the beginning of a word, one can deduce the time. Applying this method to the image above reveals the time as ‚ÄúIt is twenty-four minutes past four.‚Äù\n\n\nTelling time in English\nFor time expression, I adopted the following format:\n\nTop of the hour:\n\n‚ÄúIt is [number] o‚Äôclock.‚Äù\n\nExample: ‚ÄúIt is two o‚Äôclock.‚Äù\n\n\nTimes after the top of the hour:\n\n‚ÄúIt is [minutes] past [number].‚Äù\n\nExample: ‚ÄúIt is eleven minutes past three.‚Äù\n\n\nTimes before the top of the hour:\n\n‚ÄúIt is [minutes] to [next hour].‚Äù\n\nExample: ‚ÄúIt is twenty-three minutes to five.‚Äù\n\n\n\n(Note: We use ‚Äúhalf‚Äù for thirty minutes and ‚Äúa quarter‚Äù for fifteen minutes.)\n\n\nLanguage nuances\nAccording to the Cambridge dictionary, for multiplies of five, the word ‚Äúminutes‚Äù can be omitted. This might be a British-English specific convention but I decided to follow it anyways.\nWhile Americans might use ‚Äúafter‚Äù instead of ‚Äúpast,‚Äù and many English speakers tend to omit the word ‚Äúminutes‚Äù in everyday speech, I opted for ‚Äúpast‚Äù and excluded ‚Äúminutes‚Äù only for multiples of five.\n\n\nSimplifications\nI decided against adding phrases like ‚Äúin the morning‚Äù or ‚Äúin the afternoon‚Äù, limiting the generation to only 720 images (12 hours * 60 minutes).\nThe word ‚Äúfourteen‚Äù contains ‚Äúfour,‚Äù and likewise, ‚Äúsixteen‚Äù encompasses ‚Äúsix.‚Äù By positioning ‚Äúfourteen,‚Äù ‚Äúsixteen,‚Äù ‚Äúseventeen,‚Äù ‚Äúeighteen,‚Äù and ‚Äúnineteen,‚Äù we inherently include ‚Äúfour,‚Äù ‚Äúsix,‚Äù ‚Äúseven,‚Äù ‚Äúeight,‚Äù and ‚Äúnine.‚Äù This ensures the grid remains compact."
  },
  {
    "objectID": "posts/word-search-clock/index.html#importing-libraries",
    "href": "posts/word-search-clock/index.html#importing-libraries",
    "title": "Word Search Clock",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe‚Äôll start by importing libraries. We use matplotlib to draw the images.\n\nimport matplotlib.pyplot as plt\nimport string\nimport os"
  },
  {
    "objectID": "posts/word-search-clock/index.html#specifying-the-word-order",
    "href": "posts/word-search-clock/index.html#specifying-the-word-order",
    "title": "Word Search Clock",
    "section": "Specifying the word order",
    "text": "Specifying the word order\nThe following graph specifies the order in which words must be placed on the grid.\n\n\n\n\n\n\n\n\n\n\nn0\n\n\n\n\nit\n\nit\n\n\n\nn0-&gt;it\n\n\n\n\n\n\n\nis\n\nis\n\n\n\nit-&gt;is\n\n\n\n\n\ntwenty\n\ntwenty\n\n\n\nis-&gt;twenty\n\n\n\n\n\nhalf\n\nhalf\n\n\n\nis-&gt;half\n\n\n\n\n\nten\n\nten\n\n\n\nis-&gt;ten\n\n\n\n\n\neleven\n\neleven\n\n\n\nis-&gt;eleven\n\n\n\n\n\ntwelve\n\ntwelve\n\n\n\nis-&gt;twelve\n\n\n\n\n\nthirteen\n\nthirteen\n\n\n\nis-&gt;thirteen\n\n\n\n\n\nfourteen\n\nfourteen\n\n\n\nis-&gt;fourteen\n\n\n\n\n\nsixteen\n\nsixteen\n\n\n\nis-&gt;sixteen\n\n\n\n\n\nseventeen\n\nseventeen\n\n\n\nis-&gt;seventeen\n\n\n\n\n\neighteen\n\neighteen\n\n\n\nis-&gt;eighteen\n\n\n\n\n\nnineteen\n\nnineteen\n\n\n\nis-&gt;nineteen\n\n\n\n\n\na\n\na\n\n\n\nis-&gt;a\n\n\n\n\n\none\n\none\n\n\n\ntwenty-&gt;one\n\n\n\n\n\ntwo\n\ntwo\n\n\n\ntwenty-&gt;two\n\n\n\n\n\nthree\n\nthree\n\n\n\ntwenty-&gt;three\n\n\n\n\n\nfive\n\nfive\n\n\n\ntwenty-&gt;five\n\n\n\n\n\npast\n\npast\n\n\n\ntwenty-&gt;past\n\n\n\n\n\nto\n\nto\n\n\n\ntwenty-&gt;to\n\n\n\n\n\nhalf-&gt;past\n\n\n\n\n\nten-&gt;past\n\n\n\n\n\nten-&gt;to\n\n\n\n\n\nminutes\n\nminutes\n\n\n\neleven-&gt;minutes\n\n\n\n\n\ntwelve-&gt;minutes\n\n\n\n\n\nthirteen-&gt;minutes\n\n\n\n\n\nfourteen-&gt;minutes\n\n\n\n\n\nsixteen-&gt;minutes\n\n\n\n\n\nseventeen-&gt;minutes\n\n\n\n\n\neighteen-&gt;minutes\n\n\n\n\n\nnineteen-&gt;minutes\n\n\n\n\n\nquarter\n\nquarter\n\n\n\na-&gt;quarter\n\n\n\n\n\nquarter-&gt;past\n\n\n\n\n\nquarter-&gt;to\n\n\n\n\n\none-&gt;minutes\n\n\n\n\n\ntwo-&gt;minutes\n\n\n\n\n\nthree-&gt;minutes\n\n\n\n\n\nfive-&gt;past\n\n\n\n\n\nfive-&gt;to\n\n\n\n\n\nminutes-&gt;past\n\n\n\n\n\nminutes-&gt;to\n\n\n\n\n\nonehour\n\none\n\n\n\npast-&gt;onehour\n\n\n\n\n\ntwohour\n\ntwo\n\n\n\npast-&gt;twohour\n\n\n\n\n\nthreehour\n\nthree\n\n\n\npast-&gt;threehour\n\n\n\n\n\nfourhour\n\nfour\n\n\n\npast-&gt;fourhour\n\n\n\n\n\nfivehour\n\nfive\n\n\n\npast-&gt;fivehour\n\n\n\n\n\nsixhour\n\nsix\n\n\n\npast-&gt;sixhour\n\n\n\n\n\nsevenhour\n\nseven\n\n\n\npast-&gt;sevenhour\n\n\n\n\n\neighthour\n\neight\n\n\n\npast-&gt;eighthour\n\n\n\n\n\nninehour\n\nnine\n\n\n\npast-&gt;ninehour\n\n\n\n\n\ntenhour\n\nten\n\n\n\npast-&gt;tenhour\n\n\n\n\n\nelevenhour\n\neleven\n\n\n\npast-&gt;elevenhour\n\n\n\n\n\ntwelvehour\n\ntwelve\n\n\n\npast-&gt;twelvehour\n\n\n\n\n\nto-&gt;onehour\n\n\n\n\n\nto-&gt;twohour\n\n\n\n\n\nto-&gt;threehour\n\n\n\n\n\nto-&gt;fourhour\n\n\n\n\n\nto-&gt;fivehour\n\n\n\n\n\nto-&gt;sixhour\n\n\n\n\n\nto-&gt;sevenhour\n\n\n\n\n\nto-&gt;eighthour\n\n\n\n\n\nto-&gt;ninehour\n\n\n\n\n\nto-&gt;tenhour\n\n\n\n\n\nto-&gt;elevenhour\n\n\n\n\n\nto-&gt;twelvehour\n\n\n\n\n\noclock\n\no'clock\n\n\n\nonehour-&gt;oclock\n\n\n\n\n\ntwohour-&gt;oclock\n\n\n\n\n\nthreehour-&gt;oclock\n\n\n\n\n\nfourhour-&gt;oclock\n\n\n\n\n\nfivehour-&gt;oclock\n\n\n\n\n\nsixhour-&gt;oclock\n\n\n\n\n\nsevenhour-&gt;oclock\n\n\n\n\n\neighthour-&gt;oclock\n\n\n\n\n\nninehour-&gt;oclock\n\n\n\n\n\ntenhour-&gt;oclock\n\n\n\n\n\nelevenhour-&gt;oclock\n\n\n\n\n\ntwelvehour-&gt;oclock\n\n\n\n\n\n\n\n\n\n\nIn code this can be specified as follows:\n\n# Words to fill. Each tuple is (ID, word, preceding)\nwords = [\n    (0, \"it\", []), \n    (1, \"is\", [0]),\n    (2, \"twenty\", [1]),\n    (3, \"half\", [1]),\n    (4, \"ten\", [1]),\n    (5, \"eleven\", [1]),\n    (6, \"twelve\", [1]),\n    (7, \"thirteen\", [1]),\n    (8, \"fourteen\", [2]),\n    (9, \"sixteen\", [2]),\n    (10, \"seventeen\", [2]),\n    (11, \"eighteen\", [2]),\n    (12, \"nineteen\", [2]),\n    (13, \"a\", [1]),\n    (14, \"quarter\", [13]),\n    (15, \"one\", [2]),\n    (16, \"two\", [2]),\n    (17, \"three\", [2]),\n    (18, \"five\", [2]),\n    (19, \"minutes\", [15, 16, 17, 8, 9, 10, 11, 12, 5, 6, 7]),\n    (20, \"past\", [19, 18, 4, 14, 2, 3]),\n    (21, \"to\", [19, 18, 4, 14, 2]),\n    (22, \"one\", [20, 21]),\n    (23, \"two\", [20, 21]),\n    (24, \"three\", [20, 21]),\n    (25, \"four\", [20, 21]),\n    (26, \"five\", [20, 21]),\n    (27, \"six\", [20, 21]),\n    (28, \"seven\", [20, 21]),\n    (29, \"eight\", [20, 21]),\n    (30, \"nine\", [20, 21]),\n    (31, \"ten\", [20, 21]),\n    (32, \"eleven\", [20, 21]),\n    (33, \"twelve\", [20, 21]),\n    (34, \"oclock\", [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])\n]\n\nEach word is specified by a tuple of the form (id, word, preceding). The id is an integer that uniquely identifies the word. The word is the word to be placed. The preceding is a list of integers that specify which words must be placed before this word."
  },
  {
    "objectID": "posts/word-search-clock/index.html#filling-the-grid",
    "href": "posts/word-search-clock/index.html#filling-the-grid",
    "title": "Word Search Clock",
    "section": "Filling the grid",
    "text": "Filling the grid\nWe ensure that each word is readable in either a left-to-right or top-down direction, never in reverse.\n\ndirections = [(1, 0), (0, 1), (1, 1), (1, -1)]\n\nThe following function returns a list of identifiers of words that are ready to be placed in the grid. This is done by checking if all preceding words are placed in the grid. If so, the word is ready to be placed. At first, the only word that can be placed is the word it because its list of preceding words is empty.\n\ndef placeable_word_ids(words):\n    unplaced_word_ids = [id for (id, _, loc, _, _) in words if loc is None]\n    return [id for (id, _, loc, _, prec) in words if not any(prec_id in unplaced_word_ids for prec_id in prec) and loc is None]\n\nThe following function checks is a word can be placed in the grid in a given direction and location.\n\ndef can_place_word(word, grid, dir, r, c):\n    height = len(grid)\n    width = len(grid[0])\n    d_x, d_y = dir\n    if c + len(word) * d_x &gt; width or r + len(word) * d_y &gt; height or c + len(word) * d_x &lt; 0 or r + len(word) * d_y &lt; 0:\n        return False\n    for i, ch in enumerate(word):\n        if grid[r + i * d_y][c + i * d_x] not in ['?', ch]: \n            return False\n    return True\n\nIf a word can be placed, we call the following function to place it. The original content is returned so we can backtrack later.\n\ndef replace_characters(word, grid, dir, r, c):\n    height = len(grid)\n    width = len(grid[0])\n    previous = \"\"\n    d_x, d_y = dir\n    for i, ch in enumerate(word):\n        previous += grid[r + i * d_y][c + i * d_x]\n        grid[r + i * d_y][c + i * d_x] = ch\n    return previous\n\nA recursive generator function attempts to fill a grid with words. It uses backtracking to explore possible word placements in different directions.\n\ndef fill_grid_(grid, words, i=0):\n    height = len(grid)\n    width = len(grid[0])\n    ids = placeable_word_ids(words)\n    \n    if not ids:\n        yield grid, words\n    elif i &lt; height * width:\n        row = i // width\n        col = i % width\n        for id in ids:\n            dir_length = len(directions)\n            for d in range(dir_length):\n                dir = directions[(i + d) % dir_length]\n                if can_place_word(words[id][1], grid, dir, row, col):\n                    previous = replace_characters(words[id][1], grid, dir, row, col)\n                    words[id] = (id, words[id][1], (col, row), dir, words[id][4])\n                    yield from fill_grid_(grid, words, i+1)\n                    words[id] = (id, words[id][1], None, None, words[id][4])\n                    replace_characters(previous, grid, dir, row, col)\n        else:\n            yield from fill_grid_(grid, words, i+1)\n\nThe function fill_grid is a wrapper function that initializes the grid and calls fill_grid_.\n\ndef fill_grid(width, height):\n    loc_dir_words = [(id, word, None, None, prec) for (id, word, prec) in words]\n    grid = [['?' for c in range(width)] for r in range(height)]\n    yield from fill_grid_(grid, loc_dir_words, 0)\n\nWe call this wrapper function as follows:\n\ngen = fill_grid(15, 11)\n(g, w) = next(gen)\n\nThis returns a filled grid with a width of 15 and a height of 11. These dimensions were found experimentally. The digital photo frame that I‚Äôm using has an aspect ratio of 4:3. It makes sense to use a grid with a similar aspect ratio. I started with a width of 16 and height of 12, but that yielded grids with too many unoccupied spaces. Using 15 by 11 deviates only slightly from a 4:3 aspect ratio.\nLet‚Äôs look at the grid.\n\ng\n\n[['i', 't', 'i', 't', 'w', 'e', 'n', 't', 'y', 'h', 'a', 'o', 'n', 'e', 't'],\n ['t', 'f', 's', 's', '?', 'l', 'q', 'i', 'e', 't', 'a', '?', '?', 'i', 'w'],\n ['h', 'o', 'i', 't', 'e', 'e', 'f', 'u', 'n', 'n', 'w', 'l', '?', 'g', 'e'],\n ['i', 'u', 'x', 'h', 'm', 'v', 'p', 'i', 'a', 'e', 't', 'o', 'f', 'h', 'l'],\n ['r', 'r', 't', 'r', 'i', 'e', 'e', 'a', 'v', 'r', 't', 'n', 'i', 't', 'v'],\n ['t', 't', 'e', 'e', 'n', 'n', 'i', 'n', 's', 'e', 't', 'e', 'v', 'e', 'e'],\n ['e', 'e', 'e', 'e', 'u', 'i', 't', 'g', 't', 't', 'l', 'e', 'e', 'e', 'f'],\n ['e', 'e', 'n', 's', 't', '?', 'n', 'w', 'h', 'e', 'h', 'e', 'r', 'n', 'o'],\n ['n', 'n', '?', 'i', 'e', '?', '?', 'e', 'o', 't', 'e', 'r', 'v', '?', 'u'],\n ['?', '?', '?', 'x', 's', 'e', 'v', 'e', 'n', '?', '?', 'n', 'e', 'e', 'r'],\n ['t', 'w', 'e', 'l', 'v', 'e', 'o', 'c', 'l', 'o', 'c', 'k', '?', 'e', 'n']]\n\n\nAnd how the words are placed.\n\nw\n\n[(0, 'it', (0, 0), (1, 0), []),\n (1, 'is', (2, 0), (1, 1), [0]),\n (2, 'twenty', (3, 0), (1, 0), [1]),\n (3, 'half', (9, 0), (1, 1), [1]),\n (4, 'ten', (7, 0), (1, 1), [1]),\n (5, 'eleven', (5, 0), (0, 1), [1]),\n (6, 'twelve', (14, 0), (0, 1), [1]),\n (7, 'thirteen', (0, 1), (0, 1), [1]),\n (8, 'fourteen', (1, 1), (0, 1), [2]),\n (9, 'sixteen', (2, 1), (0, 1), [2]),\n (10, 'seventeen', (3, 1), (1, 1), [2]),\n (11, 'eighteen', (13, 0), (0, 1), [2]),\n (12, 'nineteen', (6, 0), (1, 1), [2]),\n (13, 'a', (10, 0), (1, 1), [1]),\n (14, 'quarter', (6, 1), (1, 1), [13]),\n (15, 'one', (11, 0), (1, 0), [2]),\n (16, 'two', (9, 1), (1, 1), [2]),\n (17, 'three', (3, 2), (0, 1), [2]),\n (18, 'five', (6, 2), (1, 1), [2]),\n (19, 'minutes', (4, 3), (0, 1), [15, 16, 17, 8, 9, 10, 11, 12, 5, 6, 7]),\n (20, 'past', (6, 3), (1, 1), [19, 18, 4, 14, 2, 3]),\n (21, 'to', (10, 3), (1, 0), [19, 18, 4, 14, 2]),\n (22, 'one', (11, 3), (0, 1), [20, 21]),\n (23, 'two', (6, 6), (1, 1), [20, 21]),\n (24, 'three', (9, 6), (1, 1), [20, 21]),\n (25, 'four', (14, 6), (0, 1), [20, 21]),\n (26, 'five', (12, 3), (0, 1), [20, 21]),\n (27, 'six', (3, 7), (0, 1), [20, 21]),\n (28, 'seven', (4, 9), (1, 0), [20, 21]),\n (29, 'eight', (5, 4), (1, 1), [20, 21]),\n (30, 'nine', (4, 5), (1, 1), [20, 21]),\n (31, 'ten', (0, 5), (1, 1), [20, 21]),\n (32, 'eleven', (9, 5), (1, 1), [20, 21]),\n (33, 'twelve', (0, 10), (1, 0), [20, 21]),\n (34,\n  'oclock',\n  (6, 10),\n  (1, 0),\n  [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])]"
  },
  {
    "objectID": "posts/word-search-clock/index.html#occupying-vacant-spaces-in-the-grid",
    "href": "posts/word-search-clock/index.html#occupying-vacant-spaces-in-the-grid",
    "title": "Word Search Clock",
    "section": "Occupying vacant spaces in the grid",
    "text": "Occupying vacant spaces in the grid\nNot all spaces in the grid are filled as indicated by the question marks. Let‚Äôs see how many are empty.\n\nsum(row.count('?') for row in g)\n\n15\n\n\nWe can fill these spaces with some sage words.\n\ndef remove_spaces_and_punctuation(input_string):\n    # Remove spaces\n    no_spaces = input_string.replace(\" \", \"\")\n    \n    # Remove punctuation\n    translator = str.maketrans(\"\", \"\", string.punctuation)\n    no_punctuation = no_spaces.translate(translator)\n    \n    return no_punctuation\n\n\ndef replace_question_marks(grid, phrase):\n    chars = remove_spaces_and_punctuation(phrase)\n    i = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == '?' and i &lt; len(chars):\n                grid[row][col] = chars[i]\n                i += 1\n\n\nreplace_question_marks(g, \"Time keeps moving\")\n\nSpaces and interpunctions are removed before the phrase is placed in the grid."
  },
  {
    "objectID": "posts/word-search-clock/index.html#plotting-the-grid",
    "href": "posts/word-search-clock/index.html#plotting-the-grid",
    "title": "Word Search Clock",
    "section": "Plotting the grid",
    "text": "Plotting the grid\nNow, we‚Äôre ready to visualize the grid using matplotlib. To do so, I defined a few helper functions.\nThe following function converts a time to a sentence. The time is given in hours and minutes. The function returns a sentence that describes the time.\n\ndef time_to_sentence(hours, minutes):\n    # Define words for numbers\n    time_words = [\"twelve\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \n             \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"a quarter\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\",\n             \"twenty-one\", \"twenty-two\", \"twenty-three\", \"twenty-four\", \"twenty-five\", \"twenty-six\", \"twenty-seven\", \"twenty-eight\", \"twenty-nine\", \"half\"]\n\n    # Convert hours and minutes to words\n    if minutes &lt;= 30:\n        hour_word = time_words[hours % 12]\n        minute_word = time_words[minutes]\n    else:\n        hour_word = time_words[(hours+1) % 12]\n        minute_word = time_words[60 - minutes]\n        \n    # Determine whether it's past or to\n    if minutes == 0:\n        time_phrase = f\"it is {hour_word} o'clock\"\n    elif minutes in [5, 10, 15, 20, 25, 30]:\n        time_phrase = f\"it is {minute_word} past {hour_word}\"\n    elif minutes in [35, 40, 45, 50, 55]:\n        time_phrase = f\"it is {minute_word} to {hour_word}\"\n    elif minutes == 1:\n        time_phrase = f\"it is {minute_word} minute past {hour_word}\"\n    elif minutes == 59:\n        time_phrase = f\"it is {minute_word} minute to {hour_word}\"\n    elif minutes &lt; 30:\n        time_phrase = f\"it is {minute_word} minutes past {hour_word}\"\n    else:\n        time_phrase = f\"it is {minute_word} minutes to {hour_word}\"\n\n    return time_phrase\n\nLet‚Äôs test this function.\n\nprint(time_to_sentence(10, 23))\nprint(time_to_sentence(0, 8))\n\nit is twenty-three minutes past ten\nit is eight minutes past twelve\n\n\nWe use a helper function that returns the word at a given location.\n\ndef word_at_location(words, r, c):\n    for (id, word, (x, y), dir, prec) in words:\n        if x == c and y == r:\n            return (id, word, (x, y), dir, prec)\n    return None        \n\nThe following function then finally plots the grid using matplotlib. It calls the time_to_sequence function to get a sentence that describes the time. This sentence is then split into words and the words are then highlighted in the grid. It loops through the positions in the grid from top-left to bottom-right and checks, using word_at_location, whether the word that starts at that position matches the next word in the sentence. If so, the word is highlighted.\n\ndef plot_grid(grid, words=None, hours=None, minutes=None, ax=None):\n    if not ax:\n        # Create a figure and axes\n        fig, ax = plt.subplots(figsize=(12,9))\n    else:\n        fig = None\n    \n    # Give all cells the same value/color\n    ax.imshow([[0 for cell in row] for row in grid], cmap='gray')\n\n    ax.patch.set_edgecolor('black')\n    ax.patch.set_linewidth(2)\n    \n    # Display the letters\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            ax.text(j, i, grid[i][j].upper(), ha='center', va='center', fontsize=32, color='white')\n\n    # Highlight the time\n    if not None in [hours, minutes, words]:\n        # Highlight the time\n        time_sentence = time_to_sentence(hours, minutes)\n        time_sentence = time_sentence.replace(\"-\", \" \")\n        time_sentence = time_sentence.replace(\"'\", \"\")\n\n        time_words = time_sentence.split()\n        i = 0\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                word_at_loc = word_at_location(words, r, c)\n                if word_at_loc:\n                    (_, word, (x, y), (d_x, d_y), _) = word_at_loc\n                    if i &lt; len(time_words) and time_words[i] == word[:len(time_words[i])]:\n                        x_values = [x, x + d_x * (len(time_words[i])-1) + 0.01]\n                        y_values = [y - 0.05, y + d_y * (len(time_words[i])-1) - 0.05]\n                        ax.plot(x_values, y_values, linewidth=35, solid_capstyle='round', alpha=0.5)\n                        i += 1\n    \n    # Remove the axes ticks\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    if fig:\n        fig.tight_layout()\n\nLet‚Äôs plot the grid with the time fourteen minutes past four.\n\nplot_grid(g, w, 4, 14)\nplt.show()"
  },
  {
    "objectID": "posts/word-search-clock/index.html#saving-images-to-file",
    "href": "posts/word-search-clock/index.html#saving-images-to-file",
    "title": "Word Search Clock",
    "section": "Saving images to file",
    "text": "Saving images to file\nWe can now generate all images and save them to file. We loop through all hours and minutes and call plot_grid to plot the grid and save it to disk.\noutput_directory = 'images'\nos.makedirs(output_directory, exist_ok=True)\n\nfor h in range(12):\n    for m in range(60):\n        plot_grid(g, w, h, m)\n        file_name = f\"time_{h:02d}_{m:02d}.jpg\"\n        file_path = os.path.join(output_directory, file_name)\n        plt.savefig(file_path, bbox_inches='tight')\n        plt.close()\nThe files are saved as JPEG to the images folder.\nFinally, the images need to be transfered to an SD card or USB flash drive for displaying them on the digital photo frame. I own a Braun DigiFrame 88 photo frame, but any photo frame that allows you to set the display interval of the slideshow should work."
  },
  {
    "objectID": "posts/word-search-clock/index.html#reflecting-on-the-outcome",
    "href": "posts/word-search-clock/index.html#reflecting-on-the-outcome",
    "title": "Word Search Clock",
    "section": "Reflecting on the outcome",
    "text": "Reflecting on the outcome\nI‚Äôm happy with how it turned out. It works pretty well, and I think it looks nice on my desk.\nThere‚Äôs some minor drift as the images don‚Äôt switch exactly after 60 seconds. I deal with it by adjusting the image manually once a week or so which is easy enough using the buttons on the back of the device.\nIf you want to play with the code to perhaps make a version for another language, check out one of the following links:\n  \nYou can also download just the images from here."
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html",
    "href": "posts/a-custom-sudoku-widget/index.html",
    "title": "A Custom Sudoku Widget",
    "section": "",
    "text": "In this post I‚Äôll demonstrate how to build a custom Jupyter widget for displaying and editing Sudoku puzzles. I‚Äôll also show how to create a Sudoku solver that uses this widget."
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#how-to-play-sudoku",
    "href": "posts/a-custom-sudoku-widget/index.html#how-to-play-sudoku",
    "title": "A Custom Sudoku Widget",
    "section": "How to play Sudoku",
    "text": "How to play Sudoku\nOnly read this if you‚Äôve been living under a rock, otherwise skip to the good stuff.\nIn Sudoku, the objective is to fill a 9x9 grid with digits so that each column, each row, and each of the nine 3x3 blocks that compose the grid contain all of the digits from 1 to 9.\nAn example Sudoku puzzle:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8\n\n\n5\n\n\n\n\n6\n\n\n1\n\n\n\n\n\n\n\n\n\n\n9\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n3\n\n\n\n\n8\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n7\n\n\n\n\n\n\n\n\n9\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\nThe solution to this puzzle looks like this:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n8\n\n\n5\n\n\n9\n\n\n6\n\n\n1\n\n\n4\n\n\n2\n\n\n7\n\n\n\n\n9\n\n\n2\n\n\n4\n\n\n8\n\n\n7\n\n\n3\n\n\n1\n\n\n5\n\n\n6\n\n\n\n\n1\n\n\n6\n\n\n7\n\n\n5\n\n\n4\n\n\n2\n\n\n3\n\n\n9\n\n\n8\n\n\n\n\n\n\n5\n\n\n4\n\n\n3\n\n\n1\n\n\n8\n\n\n7\n\n\n9\n\n\n6\n\n\n2\n\n\n\n\n7\n\n\n1\n\n\n8\n\n\n2\n\n\n9\n\n\n6\n\n\n5\n\n\n4\n\n\n3\n\n\n\n\n2\n\n\n9\n\n\n6\n\n\n4\n\n\n3\n\n\n5\n\n\n8\n\n\n7\n\n\n1\n\n\n\n\n\n\n4\n\n\n7\n\n\n1\n\n\n6\n\n\n5\n\n\n8\n\n\n2\n\n\n3\n\n\n9\n\n\n\n\n8\n\n\n3\n\n\n9\n\n\n7\n\n\n2\n\n\n4\n\n\n6\n\n\n1\n\n\n5\n\n\n\n\n6\n\n\n5\n\n\n2\n\n\n3\n\n\n1\n\n\n9\n\n\n7\n\n\n8\n\n\n4\n\n\n\n\nThe first row (3 8 5 9 6 1 4 2 7) contains all digits from 1 to 9. Also the first column (3 9 1 5 7 2 4 8 6) contains all digits from 1 to 9, as does the first subblock (3 8 5 - 9 2 4 - 1 6 7) and all the other ones."
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#creating-the-widget",
    "href": "posts/a-custom-sudoku-widget/index.html#creating-the-widget",
    "title": "A Custom Sudoku Widget",
    "section": "Creating the widget",
    "text": "Creating the widget\nThere are two ways to create Jupyter widgets - an easy way and a more complicated way. For this post, we will be using the easy way, which involves creating two cells in a Jupyter notebook. The first cell contains the Python code for the back-end of the widget, while the second cell contains the JavaScript for the front-end.\nIf you want to create a proper Python package that can be installed with pip install, you can follow the more complicated way. A good resource is this tutorial.\nFor this post, we‚Äôll stick with the easy way.\n\nThe Python back-end\nThe following code defines a Python class named Sudoku that extends the DOMWidget class from the ipywidgets library.\n\nfrom traitlets import Unicode, Bool, Int, List, validate, observe, TraitError, All\nfrom ipywidgets import DOMWidget, register\nimport copy\n\n@register\nclass Sudoku(DOMWidget):\n    _view_name = Unicode('SudokuView').tag(sync=True)\n    _view_module = Unicode('sudoku_widget').tag(sync=True)\n    _view_module_version = Unicode('0.1.0').tag(sync=True)\n    \n    # Attributes\n    fixed = List(trait=Bool(), default_value=[False] * 81, minlen=81, maxlen=81, help=\"A list of booleans that indicate whether a value is part of the puzzle.\").tag(sync=True)\n    _value = List(trait=Int(), default_value=[0] * 81, minlen=81, maxlen=81, help=\"A list of integers for each cell.\").tag(sync=True)\n    disabled = Bool(False, help=\"Enable or disable user changes.\").tag(sync=True)\n\n    # Basic validator for value\n    @validate('_value')\n    def _valid_value(self, proposal):\n        for i in proposal['value']:\n            if i &lt; 0 or i &gt; 9:\n                raise TraitError('Invalid value: all elements must be numbers from 0 to 9')\n        return proposal['value']\n    \n    @property\n    def value(self):\n        return copy.deepcopy(self._value)\n    \n    @value.setter\n    def value(self, v):\n        self._value = v\n\n    def __init__(self,*args,**kwargs):\n        kwargs['_value'] = kwargs.pop('value', [0]*81)\n        DOMWidget.__init__(self,*args,**kwargs)\n    \n    def __getitem__(self,index):\n        return self._value[index]\n    \n    \n    def __setitem__(self,index,val):\n        vals = self.value\n        vals[index] = val\n        self._value = vals\n\nThis Sudoku class has the following attributes:\n\nvalue: A list of integers that represents the current state of the puzzle.\nfixed: A list of booleans that indicates whether a value is part of the original puzzle and cannot be changed by the user.\ndisabled: A boolean that enables or disables user changes to the puzzle.\n\nThe fixed and value attributes are defined using the List trait from the traitlets library. The validate decorator is used to define a validator for the value attribute that checks that all elements are numbers from 0 to 9.\nThe __getitem__ and __setitem__ methods are implemented to allow indexing and assignment of elements in the value attribute.\nThe @register decorator registers the Sudoku class as an ipywidget, which allows it to be displayed and interacted with in a Jupyter environment.\n\n\nThe JavaScript front-end\nThe front-end contains a bit more code.\n\n%%javascript\nrequire.undef('sudoku_widget');\n\ndefine('sudoku_widget', [\"@jupyter-widgets/base\"], function(widgets) {\n    \n    // Define the SudokuView\n    class SudokuView extends widgets.DOMWidgetView {\n        \n        // Render the view.\n        render() {\n            this.sudoku_table = document.createElement('table');\n            this.sudoku_table.style.borderCollapse = 'collapse';\n            this.sudoku_table.style.marginLeft = '0';\n            \n            for (let i=0; i&lt;3; i++) {\n                let colgroup = document.createElement('colgroup');\n                colgroup.style.border = 'solid medium';\n                for (let j=0; j&lt;3; j++) {\n                    let col = document.createElement('col');\n                    col.style.border = 'solid thin';\n                    col.style.width = '2em';\n                    colgroup.appendChild(col);\n                }\n                this.sudoku_table.appendChild(colgroup);\n            }\n            \n            for (let t=0; t&lt;3; t++) {\n                let tbody = document.createElement('tbody');\n                tbody.style.border = 'solid medium';\n                for (let r=0; r&lt;3; r++) {\n                    let tr = document.createElement('tr');\n                    tr.style.height = '2em';\n                    tr.style.border = 'solid thin';\n                    for (let c=0; c&lt;9; c++) {\n                        let td = document.createElement('td');\n                        tr.appendChild(td);\n                    }\n                    tbody.appendChild(tr);\n                }\n                this.sudoku_table.appendChild(tbody);\n            }\n            \n            this.el.appendChild(this.sudoku_table);\n            \n            this.model_changed();\n        \n            // Python -&gt; JavaScript update\n            this.model.on('change', this.model_changed, this);\n        }\n\n        model_changed() {\n            let tds = this.sudoku_table.getElementsByTagName('td');\n            let disabled = this.model.get('disabled');\n                        \n            for (let i=0; i &lt; 81; i++) {\n                let td = tds[i];\n                td.innerText = ''; // Delete td contents\n                td.style.textAlign = 'center';\n                td.style.height = '2em';\n                let value = this.model.get('_value')[i];\n                let fixed = this.model.get('fixed')[i];\n\n                if (fixed && value &gt; 0) {\n                    let b = document.createElement('b');\n                    b.innerText = value;\n                    td.appendChild(b);\n                } else if (disabled && value &gt; 0) {\n                    td.innerText = value;\n                } else if (!disabled && !fixed) {\n                    let input = document.createElement('input');\n                    input.type = 'text';\n                    input.maxLength = 1;\n                    input.style.top = 0;\n                    input.style.left = 0;\n                    input.style.margin = 0;\n                    input.style.height = '100%';\n                    input.style.width = '100%';\n                    input.style.border = 'none';\n                    input.style.textAlign = 'center';\n                    input.style.marginTop = 0;\n                    input.style.padding = 0;\n                    input.value = (value &gt; 0 ? value : '');\n                    input.oninput = this.input_input.bind(this, i);\n                    input.onchange = this.input_changed.bind(this, i); // JavaScript -&gt; Python update\n                    td.appendChild(input);\n                }\n            }\n            \n        }\n        \n        input_input(i) {\n            this.sudoku_table.getElementsByTagName('td')[i].getElementsByTagName('input')[0].value = \n                this.sudoku_table.getElementsByTagName('td')[i].\n                    getElementsByTagName('input')[0].value.replace(/[^1-9]/g,'');\n        }\n        \n        input_changed(i) {\n            this.sudoku_table.getElementsByTagName('td')[i].getElementsByTagName('input')[0].value = \n                this.sudoku_table.getElementsByTagName('td')[i].\n                    getElementsByTagName('input')[0].value.replace(/[^1-9]/g,'');\n            let v = parseInt(this.sudoku_table.getElementsByTagName('td')[i].getElementsByTagName('input')[0].value) || 0;\n            let value = this.model.get('_value').slice();\n            value[i] = v;\n            this.model.set('_value', value);\n            this.model.save_changes();\n        }\n        \n    }\n\n    return {\n        SudokuView: SudokuView\n    }\n    \n});\n\n\n\n\nThe define function defines the sudoku_widget module, which depends on the @jupyter-widgets/base module. It creates a SudokuView class that extends the base class widgets.DOMWidgetView, which is responsible for rendering and updating the widget.\nThe render method of the SudokuView class creates a table element with 9 rows and 9 columns, representing the Sudoku game board. It adds the table to the widget‚Äôs HTML element, and registers a listener for model changes. The model_changed method is called when the model changes, and it updates the widget‚Äôs HTML to reflect the new model state.\nThe input_input and input_changed methods are event handlers that respond to user input on the Sudoku board. They update the model and the widget‚Äôs HTML to reflect the new user input."
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#how-to-use-this-widget",
    "href": "posts/a-custom-sudoku-widget/index.html#how-to-use-this-widget",
    "title": "A Custom Sudoku Widget",
    "section": "How to use this widget",
    "text": "How to use this widget\nOnce we have executed these two cells, we‚Äôre good to use our widget.\n\nimport ipywidgets as widgets\n\npuzzle = [\n    0,8,5, 0,6,1, 0,0,0,\n    9,0,4, 0,0,0, 0,0,0,\n    0,0,0, 0,0,2, 3,0,8,\n    \n    0,4,0, 0,0,0, 0,0,2,\n    7,0,0, 0,9,0, 5,0,0,\n    0,0,0, 0,3,0, 8,0,0,\n    \n    0,0,0, 0,5,8, 0,0,0,\n    0,0,0, 7,0,0, 0,1,0,\n    6,0,0, 0,0,0, 0,0,4]\n\nfixed_digits = [v &gt; 0 for v in puzzle]\n\nsudoku = Sudoku(value=puzzle, fixed=fixed_digits, disabled=False)\n\ndisplay(sudoku)\n\n\n\n\nThe widget accepts three parameters: value, fixed and disabled. The parameter value is a list of digits. A digit of 0 means empty. The parameter fixed is a list of boolean values, where True means a digit can‚Äôt be edited and will be printed in bold. The boolean disabled indicates whether a user can edit digits.\nOne can read the values in a grid like this:\n\nprint(sudoku.value)\n\n[0, 8, 5, 0, 6, 1, 0, 0, 0, 9, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 8, 0, 4, 0, 0, 0, 0, 0, 0, 2, 7, 0, 0, 0, 9, 0, 5, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 5, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 4]\n\n\nRunning the next cell would show the solution by updating the widget.\nsolution = [\n    3,8,5, 9,6,1, 4,2,7,\n    9,2,4, 8,7,3, 1,5,6,\n    1,6,7, 5,4,2, 3,9,8,\n    \n    5,4,3, 1,8,7, 9,6,2,\n    7,1,8, 2,9,6, 5,4,3,\n    2,9,6, 4,3,5, 8,7,1,\n\n    4,7,1, 6,5,8, 2,3,9,\n    8,3,9, 7,2,4, 6,1,5,\n    6,5,2, 3,1,9, 7,8,4]\n\nsudoku.value = solution"
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#creating-a-sudoku-solver",
    "href": "posts/a-custom-sudoku-widget/index.html#creating-a-sudoku-solver",
    "title": "A Custom Sudoku Widget",
    "section": "Creating a Sudoku solver",
    "text": "Creating a Sudoku solver\nNow that we have this widget to our disposal, we‚Äôll create a Sudoku solver.\n\nBuilding the user interface\nFirst, let‚Äôs tackle the easy part: creating the user interface for our Sudoku solver. We‚Äôll use the Sudoku widget along with some other widgets to make it easy for the user to select from pre-made puzzles or enter their own.\n\npuzzle1 = [\n    0,8,5, 0,6,1, 0,0,0,\n    9,0,4, 0,0,0, 0,0,0,\n    0,0,0, 0,0,2, 3,0,8,\n    \n    0,4,0, 0,0,0, 0,0,2,\n    7,0,0, 0,9,0, 5,0,0,\n    0,0,0, 0,3,0, 8,0,0,\n    \n    0,0,0, 0,5,8, 0,0,0,\n    0,0,0, 7,0,0, 0,1,0,\n    6,0,0, 0,0,0, 0,0,4]\n\npuzzle2 = [\n    3,6,0, 0,0,0, 0,0,5,\n    0,1,0, 0,9,0, 2,0,8,\n    0,5,0, 1,8,0, 0,0,7,\n    \n    5,0,0, 0,0,6, 4,0,0,\n    2,4,6, 0,5,0, 7,0,0,\n    0,0,0, 0,7,0, 0,0,0,\n    \n    0,0,0, 0,0,7, 1,0,3,\n    0,0,3, 9,4,0, 0,0,0,\n    0,0,0, 0,0,1, 0,0,0]\n\npuzzle3 = [\n    0,2,0, 0,4,0, 0,0,5,\n    0,5,8, 0,0,0, 0,0,0,\n    0,1,0, 8,0,0, 4,0,0,\n    \n    7,0,0, 0,0,8, 0,4,0,\n    0,0,1, 9,0,5, 7,0,0,\n    0,3,0, 7,0,0, 0,0,2,\n    \n    0,0,4, 0,0,3, 0,1,0,\n    0,0,0, 0,0,0, 9,6,0,\n    2,0,0, 0,1,0, 0,5,0\n]\n\nsudoku = Sudoku(value=puzzle1, fixed=[v &gt; 0 for v in puzzle1], disabled=False)\nexample_dropdown = widgets.Dropdown(\n    options=[('Empty', [0] * 81), ('Example 1', puzzle1), ('Example 2', puzzle2), ('Example 3', puzzle3)], \n    value=puzzle1,\n    layout=widgets.Layout(margin='10px 0px 0px 20px', width='150px')\n)\nsolve_button = widgets.Button(\n    description=\"Solve\", \n    layout=widgets.Layout(margin='20px 0px 0px 20px', width='150px')\n)\nnext_button = widgets.Button(\n    description=\"Next\", \n    layout=widgets.Layout(margin='20px 0px 0px 20px', width='150px', display='none')\n)\nvbox = widgets.VBox([example_dropdown, solve_button, next_button])\nhbox = widgets.HBox([sudoku, vbox])\nlabel = widgets.Label()\n\nThe Sudoku widget displays a Sudoku board.\nThere is also a Dropdown widget for selecting pre-made puzzles or an empty board, and two Button widgets for solving the puzzle and showing the next solution (if there are multiple solutions).\nFinally, there is a Label widget that can be used to display messages to the user. All of these widgets are arranged in a layout using VBox and HBox widgets.\n\n\nWriting the event handlers\nThe widgets are not functional on their own; we need to write code to make them responsive to user input.\n\n# global variables\ngen = None\nsolution = None\n\ndef on_example_dropdown_change(change):\n    if change['type'] == 'change' and change['name'] == 'value':\n        value = change['new']\n        fixed = [v &gt; 0 for v in value]\n        sudoku.value = value\n        sudoku.fixed = fixed\n        label.value = \"\"\n        solve_button.layout.display = 'inline-block'\n        next_button.layout.display = 'none'\n\nexample_dropdown.observe(on_example_dropdown_change)\n\ndef on_solve_button_clicked(b):\n    global gen\n    global solution\n    \n    val = sudoku.value.copy()\n    sudoku.fixed = [v &gt; 0 for v in val]\n    gen = solve_sudoku(val)\n    try:\n        solution = next(gen)\n        sudoku.value = solution\n    except StopIteration:\n        label.value = \"This sudoku has no solution.\"\n        sudoku.fixed = [False] * 81\n        return\n    \n    try:\n        solution = next(gen).copy()\n        label.value = \"This sudoku has multiple solutions.\"\n        solve_button.layout.display = 'none'\n        next_button.layout.display = 'inline-block'\n    except StopIteration:\n        label.value = \"\"\n        solve_button.layout.display = 'none'\n    \nsolve_button.on_click(on_solve_button_clicked)\n\ndef on_next_button_clicked(b):\n    global gen\n    global solution\n    \n    sudoku.value = solution\n    try:\n        solution = next(gen)\n    except StopIteration:\n        label.value = \"\"\n        next_button.layout.display = 'none'\n\nnext_button.on_click(on_next_button_clicked)\n\nThe on_example_dropdown_change function is called when the user selects an example puzzle from a dropdown menu, and it sets up the Sudoku grid with the selected puzzle and clears any previous solutions.\nThe on_solve_button_clicked function is called when the user clicks a button to solve the puzzle, and it generates a Sudoku solver object and attempts to find a solution to the puzzle. If a solution is found, it updates the Sudoku grid with the solution and enables a button to find the next solution if there are multiple solutions. If no solution is found, it displays an error message.\nThe on_next_button_clicked function is called when the user clicks the ‚Äúnext‚Äù button to find the next solution to a puzzle with multiple solutions, and it updates the Sudoku grid with the next solution if there is one, or disables the ‚Äúnext‚Äù button if there are no more solutions.\nThe gen and solution variables are used to keep track of the state of the Sudoku solver object and the next solution.\n\n\nThe solver\nWe can easily solve puzzles using backtracking. The solve_sudoku function utilizes recursion to generate solutions. It is called by the on_solve_button_clicked function above.\n\ndef solve_sudoku(puzzle, index=0):\n    if index == 81:\n        # Solution found\n        yield puzzle\n    elif puzzle[index] &gt; 0:\n        # Already filled\n        yield from solve_sudoku(puzzle, index + 1)\n    else:\n        for v in range(1,10):\n            # Fill in a digit and check constraints\n            puzzle[index] = v\n            if is_valid_square(puzzle, index):\n                yield from solve_sudoku(puzzle, index + 1)\n            puzzle[index] = 0\n\nThe solve_sudoku function takes in a puzzle parameter which is a list of length 81, representing the 9x9 Sudoku grid with empty squares represented as 0s. The function yields solutions as they are found.\nThe following functions are used to check the constraints.\n\ndef get_column(puzzle, k):\n    column = []\n    for i in range(9):\n        column.append(puzzle[i*9 + k])\n    return column\n\ndef get_row(puzzle, r):\n    return puzzle[r*9:(r+1)*9]\n\ndef get_block(puzzle, b):\n    block = []\n    for r in range(3):\n        for k in range(3):\n            block.append(puzzle[[0,3,6,27,30,33,54,57,60][b]+9*r+k])\n    return block\n\ndef is_valid(l):\n    # Check for duplicate values\n    digits = [v for v in l if v &gt; 0]\n    s = set(digits)\n    return len(digits) == len(s)\n\ndef is_valid_square(puzzle, i):\n    k = i % 9\n    r = int(i / 9)\n    b = int(r / 3) * 3 + int(k / 3)\n    \n    return is_valid(get_row(puzzle, r)) and is_valid(get_column(puzzle, k)) and is_valid(get_block(puzzle, b))\n\nThe get_column, get_row, and get_block functions are used to retrieve the values in the columns, rows, and 3x3 blocks that a given index belongs to.\nThe is_valid function checks if a list of values contains duplicate values. It returns True if the list contains no duplicates (excluding 0s) and False otherwise.\nThe is_valid_square function checks if a value can be placed in a given square of the Sudoku grid without violating the rules of the game. It uses the get_row, get_column, get_block, and is_valid functions.\n\n\nDisplaying the user interface\nIt‚Äôs time to show the user interface.\n\ndisplay(hbox, label)\n\n\n\n\n\n\n\nTo play with an interactive version, you‚Äôll need to run it in Jupyter Notebook. Sadly, it won‚Äôt work in JupyterLab. It does work in Voil√† in case you wish to turn it into a web app. The corresponding gist can be found here."
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#conclusion",
    "href": "posts/a-custom-sudoku-widget/index.html#conclusion",
    "title": "A Custom Sudoku Widget",
    "section": "Conclusion",
    "text": "Conclusion\nIn this post, we saw how to create a custom widget in Jupyter Notebook. It‚Äôs worth noting that the approach I presented here is more of a quick fix. Originally, I developed this code as part of a Sudoku programming assignment for my students, and I had control over the environment they were using (Jupyter Notebook and Voila).\nFor creating Jupyter widgets, it is recommended to use widget-cookiecutter (for JavaScript) or widget-ts-cookiecutter (for TypeScript). These tools offer a more robust and reliable approach to building widgets in Jupyter."
  },
  {
    "objectID": "posts/call-me-maybe/index.html",
    "href": "posts/call-me-maybe/index.html",
    "title": "Call Me Maybe?",
    "section": "",
    "text": "Understanding program structure and concepts like recursion can be challenging, especially for students just starting their coding journey.\nTo facilitate the understanding of program execution, I created a Python decorator that can log function calls, including the function name, input parameters, and return values.\nIn addition to a decorator for logging function calls, I also wrote a custom logging handler. This logging handler generates call graphs, providing a visualization of the function call hierarchy.\nFinally, to further enhance comprehension of program flow, I‚Äôll show how to animate these call graphs. By animating the call graphs, we can visualize the order in which functions are called.\nLet‚Äôs dive in!"
  },
  {
    "objectID": "posts/call-me-maybe/index.html#importing-libraries",
    "href": "posts/call-me-maybe/index.html#importing-libraries",
    "title": "Call Me Maybe?",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing the necessary modules.\n\nimport logging\nimport graphviz\nimport re\nimport ipywidgets as widgets\n\nfrom logging import StreamHandler\nfrom functools import wraps, partial\n\nThe standard way of doing logging in Python is by using the logging module, which is part of the Python standard library. This module is quite flexible and allows us to control the log levels, log formatting, log destinations, and more.\nThe decorator uses the wraps and partial functions from the functools module. The graphviz module is used to create the call graphs."
  },
  {
    "objectID": "posts/call-me-maybe/index.html#the-logging-decorator",
    "href": "posts/call-me-maybe/index.html#the-logging-decorator",
    "title": "Call Me Maybe?",
    "section": "The logging decorator",
    "text": "The logging decorator\nIn Python, decorators provide a powerful way of enhancing the behavior of functions or classes without having to make direct modifications to their source code. Decorators are indicated by the @ symbol followed by the name of the decorator function, and they are commonly placed immediately before the target function or class declaration.\nA decorator is essentially a higher-order function that takes a function or class as input and returns a modified version of that function or class.\nThe function decorator I created is named fun_logger. Besides the calls and exits of a function, is also logs any exceptions that might occur. In addition, it logs the arguments and return value. It also keeps track of the indentation level for log messages which is incremented and decremented based on the nesting depth of function calls within the decorated functions.\n\ndef fun_logger(func=None, *, logging=logging, indent='  ', exit=False):\n    if func is None:\n        return partial(fun_logger,logging=logging, indent=indent, exit=exit)\n    \n    global indent_level\n    indent_level = 0\n    \n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        global indent_level\n        \n        args_repr = [repr(a) for a in args]\n        kwargs_repr = [f\"{k}={v!r}\" for k, v in kwargs.items()]\n        signature = \", \".join(args_repr + kwargs_repr)\n        logging.debug(f\"function {func.__qualname__} called with args {signature}\", extra={\n            'func': func.__qualname__, \n            'args_': args, \n            'kwargs': kwargs, \n            'indent': indent_level * indent,\n            'indent_level': indent_level\n        })\n        try:\n            indent_level += 1\n            result = func(*args, **kwargs)\n        except Exception as e:\n            logging.exception(f\"function {func.__qualname__} raised exception {str(e)}\", extra={\n                'func': func.__qualname__, \n                'exception': e,\n                'indent': indent_level * indent,\n                'indent_level': indent_level\n            })\n            if indent_level &gt; 0:\n                indent_level -= 1\n            raise e\n        if indent_level &gt; 0:\n            indent_level -= 1\n        if exit:\n            logging.debug(f\"function {func.__qualname__} exited with result {result}\", extra={\n                'func': func.__qualname__,\n                'result': result,\n                'indent': indent_level * indent,\n                'indent_level': indent_level\n            })        \n        return result\n    return wrapper\n\nThe decorator can be used with or without arguments.\nLike most function decorators it returns a wrapper function that calls the original function while adding additional functionality. In this case the wrapper function does the following:\n\nThe function‚Äôs arguments and keyword arguments are converted into string representations.\nA debug log message is logged, including the function‚Äôs name and arguments.\nThe wrapped function is executed within a try-except block.\n\nIf an exception occurs, an exception log message is logged. After this, the exception is re-raised to maintain the original behavior.\nIf no exception occurs, a debug log message may be logged to indicate the function‚Äôs exit and result. Finally, the result of the wrapped function is returned."
  },
  {
    "objectID": "posts/call-me-maybe/index.html#the-logging-handler",
    "href": "posts/call-me-maybe/index.html#the-logging-handler",
    "title": "Call Me Maybe?",
    "section": "The logging handler",
    "text": "The logging handler\nA logging handler in the Python logging framework processes log records generated by the application and sends them to the desired output destination. It captures, filters, formats, and routes log records, enabling control over where and how logs are stored or displayed.\nThe fun_logger decorator introduced above generates log records for every decorated function call. We can print those log records. What we want however, is to turn these log records into a call graph. For this we can create a custom logging handler that processes the log records and produces the graph.\n\nclass CallGraphHandler(StreamHandler):\n    \"\"\"\n    A handler class which allows the drawing of call graphs\n    \"\"\"    \n    def __init__(self, name=None, comment=None):\n        StreamHandler.__init__(self)\n        self.name = name\n        self.comment = comment\n        \n        self.gv = graphviz.Digraph(name, comment)\n        self.clear()\n    \n    @property\n    def source(self):\n        return self.gv.source\n    \n    def clear(self):\n        self.gv.clear()        \n        self.nodes = []\n        self.edges = []\n        self.stack = []\n        \n        # insert empty node\n        self.gv.node('start', label='', shape='none')\n    \n    def emit(self, record):\n        if hasattr(record, 'indent_level'):\n            current = None\n            while len(self.stack) &gt; record.indent_level:\n                current = self.stack.pop()\n        if hasattr(record, 'args_'): # A function was called\n            args_repr = [repr(a) for a in record.args_]\n            kwargs_repr = [f\"{k}={v!r}\" for k, v in record.kwargs.items()]\n            signature = \", \".join(args_repr + kwargs_repr)\n            node_id = str(len(self.nodes))\n            self.gv.node(node_id, f\"{record.func}({signature})\", fontcolor='black', color='black')\n            self.nodes.append(node_id)\n            self.stack.append(node_id)\n            if len(self.stack) == 1:\n                self.gv.edge('start', node_id, fontcolor='black', color='black:black')\n            else:\n                self.gv.edge(self.stack[-2], node_id, fontcolor='black', color='black')\n        if hasattr(record, 'result'): # A function returned\n            if len(self.stack) == 0:\n                self.gv.edge(current, 'start', fontcolor='blue', pencolor='blue', labelfontcolor='blue', color='blue', label=str(record.result))\n            else:\n                self.gv.edge(current, self.stack[-1], fontcolor='blue', pencolor='blue', labelfontcolor='blue', color='blue', label=str(record.result))\n        if hasattr(record, 'exception'): # An exception occurred\n            if not current:\n                current = record.exception.__class__.__name__\n                self.gv.node(current, shape='diamond', fontcolor='red', pencolor='red', labelfontcolor='red', color='red')\n                self.gv.edge(self.stack[-1], current, fontcolor='red', pencolor='red', labelfontcolor='red', color='red')\n\nThis custom logging handler class does the following:\n\nThe CallGraphHandler class inherits from StreamHandler, which is a built-in logging handler that sends log records to a specified output stream (e.g., stdout). Instead of sending log records to an output stream, we will build a Graphviz DOT string that can be displayed or saved to file.\nThe __init__ method initializes the CallGraphHandler object. It takes optional arguments for a name and comment for the resulting Graphviz plot and sets them as attributes. It also initializes an ampty graphviz.Digraph object.\nIt has an emit() method that is called when a log record is emitted to the handler. It processes the log record and updates the call graph accordingly. Depending on the contents of the log records it will add nodes and/or arrows to the call graph indicating a call, a function return, or an exception.\nThe clear() method clears the call graph."
  },
  {
    "objectID": "posts/call-me-maybe/index.html#using-the-decorator-and-logging-handler",
    "href": "posts/call-me-maybe/index.html#using-the-decorator-and-logging-handler",
    "title": "Call Me Maybe?",
    "section": "Using the decorator and logging handler",
    "text": "Using the decorator and logging handler\nWe firstly create a new object based on the Logger class that we‚Äôll write our log messages to.\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\nThe log level is set to DEBUG.\nWe‚Äôll write logging records to both a StreamHandler and a CallGraphHandler. We‚Äôll initialize the StreamHandler first. This will output the log records to stdout.\n\nstream_handler = logging.StreamHandler()\nformatter = logging.Formatter('%(indent)s%(message)s')\nstream_handler.setFormatter(formatter)\n\nlogger.addHandler(stream_handler)\n\nWe define a custom log format so that an indentation (%(indent)) is added to show the call depth. If we don‚Äôt do this all log messages will be left-aligned. The stream_handler is added to the logger object.\nNext we initialize a CallGraphHandler object and add it to logger object as well.\n\ncall_graph_handler = CallGraphHandler(\"Call graph\", \"An example call trace of a recursive function\")\nlogger.addHandler(call_graph_handler)\n\n\nTower of Hanoi\nThe Tower of Hanoi problem has an elegant recursive solution that breaks down the problem into subproblems and using recursion to solve them. Let‚Äôs see what its logging output looks like.\n\n@fun_logger(logging=logger)\ndef hanoi(n, source, destination, helper):\n    if n==1:\n        print(\"Move disk 1 from peg\", source, \"to peg\", destination)\n        return\n    hanoi(n-1, source, helper, destination)\n    print(\"Move disk\", n, \"from peg\", source, \"to peg\", destination)\n    hanoi(n-1, helper, destination, source)\n\nNote how we have added the decorator and given it our logger object.\nNow we‚Äôre ready to call the function. In this case we tell it to produce a solution for four disks.\n\nn = 4 # number of disks\nhanoi(n, 'A', 'B', 'C')\n\nfunction hanoi called with args 4, 'A', 'B', 'C'\n\n\n  function hanoi called with args 3, 'A', 'C', 'B'\n\n\n    function hanoi called with args 2, 'A', 'B', 'C'\n\n\n      function hanoi called with args 1, 'A', 'C', 'B'\n\n\n      function hanoi called with args 1, 'C', 'B', 'A'\n\n\n    function hanoi called with args 2, 'B', 'C', 'A'\n\n\n      function hanoi called with args 1, 'B', 'A', 'C'\n\n\n      function hanoi called with args 1, 'A', 'C', 'B'\n\n\n  function hanoi called with args 3, 'C', 'B', 'A'\n\n\n    function hanoi called with args 2, 'C', 'A', 'B'\n\n\n      function hanoi called with args 1, 'C', 'B', 'A'\n\n\n      function hanoi called with args 1, 'B', 'A', 'C'\n\n\n    function hanoi called with args 2, 'A', 'B', 'C'\n\n\n      function hanoi called with args 1, 'A', 'C', 'B'\n\n\n      function hanoi called with args 1, 'C', 'B', 'A'\n\n\nMove disk 1 from peg A to peg C\nMove disk 2 from peg A to peg B\nMove disk 1 from peg C to peg B\nMove disk 3 from peg A to peg C\nMove disk 1 from peg B to peg A\nMove disk 2 from peg B to peg C\nMove disk 1 from peg A to peg C\nMove disk 4 from peg A to peg B\nMove disk 1 from peg C to peg B\nMove disk 2 from peg C to peg A\nMove disk 1 from peg B to peg A\nMove disk 3 from peg C to peg B\nMove disk 1 from peg A to peg C\nMove disk 2 from peg A to peg B\nMove disk 1 from peg C to peg B\n\n\nBesides the output caused by the print statements in the function itself, the stream_handler object also writes to the stdout.\n\nShowing the call graph\nThe stream_handler writes directly to stdout. To visualize the call graph we need to get the Graphviz DOT string from the call_graph_handler object, create a Graphviz object and display it.\n\ngraph = graphviz.Source(call_graph_handler.source)\ngraph\n\n\n\n\n\n\n\n\n\n\nClearing the call graph\nOnce we‚Äôve created our Graphviz object we can clear the Graphviz string in the call_graph_handler object.\n\ncall_graph_handler.clear()\n\nIf we skip this step subsequent function calls will be drawn in the same Graphviz image.\n\n\n\nFibonacci sequence\nOur next example will be the famous Fibonacci sequence. The following function will return the nth Fibonacci number.\n\n@fun_logger(logging=logger, exit=True)\ndef fib(n):\n    if n in [0, 1]:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nAgain we add the decorator. Because we‚Äôre also interested in the return values of the function we set exit=True. This will cause the decorator to also output logging records when the function exits.\n\nfib(5)\n\nfunction fib called with args 5\n\n\n  function fib called with args 4\n\n\n    function fib called with args 3\n\n\n      function fib called with args 2\n\n\n        function fib called with args 1\n\n\n        function fib exited with result 1\n\n\n        function fib called with args 0\n\n\n        function fib exited with result 0\n\n\n      function fib exited with result 1\n\n\n      function fib called with args 1\n\n\n      function fib exited with result 1\n\n\n    function fib exited with result 2\n\n\n    function fib called with args 2\n\n\n      function fib called with args 1\n\n\n      function fib exited with result 1\n\n\n      function fib called with args 0\n\n\n      function fib exited with result 0\n\n\n    function fib exited with result 1\n\n\n  function fib exited with result 3\n\n\n  function fib called with args 3\n\n\n    function fib called with args 2\n\n\n      function fib called with args 1\n\n\n      function fib exited with result 1\n\n\n      function fib called with args 0\n\n\n      function fib exited with result 0\n\n\n    function fib exited with result 1\n\n\n    function fib called with args 1\n\n\n    function fib exited with result 1\n\n\n  function fib exited with result 2\n\n\nfunction fib exited with result 5\n\n\n5\n\n\nAgain we see the log messages.\n\nShowing the call graph\nLet‚Äôs show the call graph.\n\ngraph = graphviz.Source(call_graph_handler.source)\ngraph\n\n\n\n\n\n\n\n\nBecause we also logged the function exits, the call graph includes blue edges that show the return values.\n\n\nAnimating the call graph\nBy tracing the arrows, first traversing the left subtree and then the right subtree of each node starting with the root node, we can figure out the call sequence. A somewhat hacky way of animating this call order is taking the Graphviz DOT string and update the colors of the nodes and edges. The nodes and edges in the DOT string we get from the call_graph_handler all have the color black, blue, or red (in case of an exception). We can create ‚Äòframes‚Äô by setting a certain number of colors to lightgray starting from the end of this DOT string. How many colors we set to lightgray depends on the ‚Äòframe‚Äô we‚Äôre in.\n\ndot = call_graph_handler.source\n\n\nframes = dot.count(\"color=\")\n\nslider = widgets.IntSlider(\n    value=0,\n    min=0,\n    max=frames,\n    step=4,\n    orientation='horizontal',\n    readout=False\n)\noutput = widgets.Output()\n\ndef on_value_change(change):\n    with output:\n        output.clear_output(wait=True)\n        grey_dot = re.sub(\"([ \\]]).*?=roloc\", \"\\\\1yergthgil=roloc\",dot[::-1], frames-slider.value)[::-1] if frames-slider.value &gt; 0 else dot\n        graph = graphviz.Source(grey_dot)\n        display(graph)\n\nslider.observe(on_value_change)\non_value_change(None)\n\nThe [::-1] part reverses the DOT string so the regular expression can substitute from the back to the front of the string. Note how in the regular expression yergthgil=roloc is color=lightgrey spelled backwards. We use a slider to set the frame number. We set the stepsize in the slider to 4 because that‚Äôs how many colors are updated in each frame.\nI told you it was hacky.\n\ndisplay(slider, output)\n\n\n\n\n\n\n\n\n\nClearing the call graph\nFor good practice we clear the call graph again.\n\ncall_graph_handler.clear()\n\nIf you actually want multiple calls to appear in the same call graph you can skip this step.\nIt‚Äôs important to note that only functions that are decorated will appear in the graph. Say you have a function foo that calls function bar that calls function baz and you only decorate foo. Only calls to foo will be drawn in the call graph. To include bar and baz you‚Äôll have to decorate them as well."
  },
  {
    "objectID": "posts/call-me-maybe/index.html#logging-your-own-functions",
    "href": "posts/call-me-maybe/index.html#logging-your-own-functions",
    "title": "Call Me Maybe?",
    "section": "Logging your own functions",
    "text": "Logging your own functions\nIf you want to try this on your own functions you can grab the source code from here.\nHappy coding!"
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "",
    "text": "If you‚Äôre a programmer then you must be a masochist. After all, what kind of person enjoys staring at a screen for hours on end, squinting at lines of code that seem to blend together like a modern art painting? What kind of person willingly submits themselves to the endless frustration of debugging, only to find that the solution was something as simple as a missing semicolon?\nIf this is you then you‚Äôre going to love Brainfuck - the programming language that‚Äôs minimalistic to the point of absurdity. With only eight commands, Brainfuck is both challenging and frustrating for even the most experienced programmers.\nIn this post I‚Äôll give a brief overview of the language and then describe how to use the Brainfuck interpreter I wrote."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#how-does-brainfuck-work",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#how-does-brainfuck-work",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "How does Brainfuck work?",
    "text": "How does Brainfuck work?\nBrainfuck programs operate on a memory tape consisting of an array of cells, each containing a single byte. With the tape initially set to zero, Brainfuck programs modify the values in the memory cells, move the pointer left and right along the tape, and perform input and output operations using its eight commands."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#commands",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#commands",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "Commands",
    "text": "Commands\nHere‚Äôs a breakdown of the available commands in Brainfuck:\n\n&lt;: Move the pointer one cell to the left.\n&gt;: Move the pointer one cell to the right.\n+: Increment the value of the cell the pointer is pointing to by one.\n-: Decrement the value of the cell the pointer is pointing to by one.\n.: Output the value of the cell the pointer is pointing to.\n,: Input a byte and store its value in the cell the pointer is pointing to.\n[: If the value of the cell the pointer is pointing to is zero, jump forward to the corresponding ] command.\n]: If the value of the cell the pointer is pointing to is non-zero, jump back to the corresponding [ command.\n\nDue to its minimalistic syntax, Brainfuck is used to challenge and amuse programmers. I‚Äôll be honest - programming in Brainfuck is an absolute nightmare. Writing an interpreter for it is easy though."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#using-the-interpreter",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#using-the-interpreter",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "Using the interpreter",
    "text": "Using the interpreter\nYou can download my Brainfuck interpreter here.\nThe Prolog program provided, bf.pl, is the interpreter. It defines a number of Prolog predicates that can be used to interpret Brainfuck programs. The interpreter uses a list to represent the memory tape, and provides predicates for setting and getting the values of cells, as well as for incrementing and decrementing cell values.\nThe main predicate, run(Prog), takes a list of Brainfuck commands as input and interprets the program. It uses a helper predicate, sequence/4, to recursively process each command in the program, updating the memory tape and pointer as necessary.\nMy interpreter isn‚Äôt the fastest, but it does have dynamic memory tape length. Most other interpreters have a fixed tape length of (usually) 30,000 cells."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#running-brainfuck-programs",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#running-brainfuck-programs",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "Running Brainfuck programs",
    "text": "Running Brainfuck programs\nI‚Äôve included a couple of example programs taken from The Brainfuck Archive, including a ‚ÄúHello World!‚Äù program. To execute a Brainfuck program using the interpreter, you can use the run_bf_program/1 predicate which in turn uses the run/1 predicate.\nFor example, to run the ‚ÄúHello World!‚Äù program, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the Brainfuck interpreter by typing:\n[bf].\nThis loads the bf.pl file into the interpreter. You can then run a Brainfuck program using the run_bf_program/1 predicate, like so:\nrun_bf_program('hellobf.bf').\nThis will run the hellobf.bf program and output the famous ‚ÄúHello World!‚Äù message to the console.\nAlternatively, you can execute these three steps at once by typing:\nswipl -s bf.pl -g \"run_bf_program('hellobf.bf'), halt.\"\nAdding halt will make the Prolog interpreter exit after the Brainfuck run_bf_program/1 predicate has finished.\nYou can also run Brainfuck code directly like this:\nswipl -s bf.pl -g \"atom_chars('++++[++++&gt;---&lt;]&gt;-.---[-----&gt;+&lt;]&gt;-.+++[-&gt;+++&lt;]&gt;++.++++++++.+++++.--------.---[-&gt;+++&lt;]&gt;+.-[---&gt;+&lt;]&gt;.++++++++.',Chars), run(Chars), halt.\"\nHappy coding and good luck with your sanity!"
  },
  {
    "objectID": "posts/embedding-pictures-into-magic-squares/index.html",
    "href": "posts/embedding-pictures-into-magic-squares/index.html",
    "title": "Embedding Pictures into Magic Squares",
    "section": "",
    "text": "A magic square is a square grid of numbers in which all numbers are distinct and each row, column and diagonal adds up to the same constant.\nMany algorithms have been developed to generate magic squares, and the website https://www.magischvierkant.com showcases quite a few of them. While exploring the site, I came across a cool concept: embedding pictures into magic squares.\nHere‚Äôs one of the examples they showed:\nThe center 32x32 square contains a picture of Benjamin Franklin within a larger 128x128 magic square. The numbers in the 32√ó32 center range from 1 (white) to 1024 (black), and the surrounding space is filled with numbers (1025 to 16384) that complete the magic square. You might want to zoom in on the picture above to see the numbers.\nThis magic square was made by Ot Ottenheim, a fellow Dutchman, who has created a variety of magic squares. You can find his blog here.\nNo details were provided on how to create these magic squares, but reverse engineering the process wasn‚Äôt too hard. Read on to see what I learned and how you can embed your own pictures into magic squares."
  },
  {
    "objectID": "posts/embedding-pictures-into-magic-squares/index.html#clarifying-some-jargon",
    "href": "posts/embedding-pictures-into-magic-squares/index.html#clarifying-some-jargon",
    "title": "Embedding Pictures into Magic Squares",
    "section": "Clarifying some jargon",
    "text": "Clarifying some jargon\nBefore we go into understanding how to create magic squares containing a picture, let‚Äôs further clarify some terms. At the same time, we‚Äôll write code that will help us visualize, understand, and check our magic squares.\nAs defined above, a magic square is a square grid filled with distinct numbers. It typically contains consecutive integers starting from 1. Its fundamental property is that the sum of the numbers in each row, each column, and both main diagonals is identical. This consistent sum is known as the magic constant.\nFor instance, consider this 3√ó3 square:\n\nimport numpy as np\n\nms3 = np.array([\n    [8, 1, 6], \n    [3, 5, 7], \n    [4, 9, 2]\n])\n\nThe following code prints a magic square in a more readable format:\n\nfrom IPython.core.display import HTML\n\ndef print_square(m):\n    table = \"&lt;table border='1' cellspacing='0' cellpadding='10'&gt;\"\n    for r in m:\n        table += \"&lt;tr&gt;\"\n        for c in r:\n            table += \"&lt;td&gt;\" + str(c) + \"&lt;/td&gt;\"\n        table += \"&lt;/tr&gt;\"\n    table += \"&lt;/table&gt;\"\n    display(HTML(table))\n\n\nprint_square(ms3)\n\n816357492\n\n\nHere, every row (8+1+6=15, 3+5+7=15, 4+9+2=15), every column (8+3+4=15, 1+5+9=15, 6+7+2=15), and both main diagonals (8+5+2=15, 6+5+4=15) sum to 15 (the magic constant). This type is generally called an ordinary magic square.\nIf an ordinary magic square strictly uses consecutive integers from \\(1\\) up to \\(N^2\\) (where N is the side length of the square, e.g., 1 to 9 for a 3√ó3 square), it is then classified as a normal magic square. The 3√ó3 example provided above is therefor a normal magic square.\nA semimagic square is a less stringent variation where only the sums of the numbers in each row and each column are equal to the magic constant; the main diagonals do not necessarily sum to this constant.\nLet‚Äôs write some functions to check for these properties:\n\ndef is_semimagic(m, c=None):\n    row_sums = np.sum(m, axis=1)\n    col_sums = np.sum(m, axis=0)\n    mc = row_sums[0] if not c else c\n    return np.all(row_sums == mc) and np.all(col_sums == mc)\n\n\ndef is_magic(m, c=None):\n    diag_sum1 = np.sum(np.diag(m))  # sum of first diagonal  \n    diag_sum2 = np.sum(np.diag(np.fliplr(m)))  # sum of second diagonal\n    mc = diag_sum1 if not c else c\n    return is_semimagic(m, mc) and diag_sum1 == mc and diag_sum2 == mc\n\n\ndef is_normal(m):\n    n = m.shape[0]\n    unique_values = np.unique(m)\n    return np.min(unique_values) == 1 and np.max(unique_values) == n**2 and len(unique_values) == n**2\n\nThese will come in handy later when we create our own magic squares. For now, let‚Äôs verify that our 3√ó3 example is indeed a normal magic square:\n\nis_magic(ms3) and is_normal(ms3)\n\nTrue\n\n\nMoving on to more complex types, a panmagic square (also known as a diabolic or pandiagonal magic square) builds upon the ordinary definition. In addition to the main rows, columns, and diagonals, all broken diagonals also sum to the magic constant. A broken diagonal forms by starting at a cell, moving diagonally to an edge, and then wrapping around to continue from the opposite edge.\nConsider the following 4√ó4 panmagic square, with a magic constant of 34:\n\nms4 = np.array([\n    [ 1,  8, 10, 15],\n    [12, 13,  3,  6],\n    [ 7,  2, 16,  9],\n    [14, 11,  5,  4]\n])\n\nprint_square(ms4)\n\n18101512133672169141154\n\n\nHere, not only do rows, columns, and main diagonals sum to 34, but so do diagonals like (12+2+5+15) and (14+8+3+9). Just for fun, let‚Äôs write a function to check if a square is panmagic and test it on our example:\n\ndef is_panmagic(m):\n    n = m.shape[0]\n    sums = []\n    # Top-left to bottom-right\n    for offset in range(n):\n        s = 0\n        for i in range(n):\n            j = (i + offset) % n\n            s += m[i, j]\n        sums.append(s)\n    # Top-right to bottom-left\n    for offset in range(n):\n        s = 0\n        for i in range(n):\n            j = (offset - i) % n\n            s += m[i, j]\n        sums.append(s)\n\n    mc = sums[0]  # Magic constant from the first sum\n    return np.all(sums == mc) and is_magic(m, mc)\n\n\nis_panmagic(ms4)\n\nTrue\n\n\nA property of panmagic squares is that if you move the first column(s) to the end, the resulting square remains panmagic. In the same way, if you move the first row(s) from the top to the bottom, the square also remains panmagic. This property is not true for ordinary magic squares.\nWe can demonstrate this property with our 4√ó4 panmagic square.\n\nms4_reordered = np.hstack((ms4[:, 1:], ms4[:, [0]]))\nprint_square(ms4_reordered)\n\n81015113361221697115414\n\n\nAfter moving the first column to the end, we get a new square that is still panmagic.\n\nis_panmagic(ms4_reordered)\n\nTrue"
  },
  {
    "objectID": "posts/embedding-pictures-into-magic-squares/index.html#exploring-the-structure-of-magic-squares-that-contain-pictures",
    "href": "posts/embedding-pictures-into-magic-squares/index.html#exploring-the-structure-of-magic-squares-that-contain-pictures",
    "title": "Embedding Pictures into Magic Squares",
    "section": "Exploring the structure of magic squares that contain pictures",
    "text": "Exploring the structure of magic squares that contain pictures\nLet‚Äôs look at the structure of the magic square that contains a picture. From the page where I found the Benjamin Franklin example, we can also download the numbers that make up the square as a file. Let‚Äôs start by loading this file into a NumPy array.\n\nfranklin = np.genfromtxt('franklin.csv', delimiter=';', dtype=int)\n\nThe following function plots the magic square as a heatmap, which gives us a visual representation of the numbers in the square.\n\nimport matplotlib.pyplot as plt\n\ndef plot_square(m, center_only=True, show_values=True, figsize=(4, 4)):\n    plt.figure(figsize=figsize)\n\n    nrows, ncols = m.shape\n    block_size = nrows // 4\n\n    if center_only:\n        c0, c1 = 3 * (block_size // 2), 5 * (block_size // 2)\n        block = m[c0:c1, c0:c1]\n        plt.imshow(block, cmap='grey_r', interpolation='nearest', extent=(c0 - 0.5, c1 - 0.5, c1 - 0.5, c0 - 0.5))\n    else:\n        plt.imshow(m, cmap='grey_r', interpolation='nearest')\n    \n    plt.xlim(-0.5, ncols)\n    plt.ylim(nrows, -0.5)\n    plt.axis('off')\n\n    if show_values:        \n        ax = plt.gca()\n        fig = plt.gcf()\n        bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n        width, height = bbox.width * fig.dpi, bbox.height * fig.dpi\n        cell_width = width / ncols\n        n_digits = len(str(abs(ncols * nrows)))\n\n        for (j, i), label in np.ndenumerate(m):\n            plt.text(i, j, label, ha='center', va='center', color='black', fontsize=cell_width / n_digits)\n\n    plt.show()\n\nBy default it shows the numbers in the square, and only shows the center 32x32 square in the heatmap.\n\nplot_square(franklin, figsize=(10, 10))\n\n\n\n\n\n\n\n\nLet‚Äôs verify that this is indeed a magic square by checking the properties using the functions we defined above.\n\nis_magic(franklin) and is_panmagic(franklin) and is_normal(franklin)\n\nTrue\n\n\nWe can see that the square is not only magic, but also panmagic!\nNote that the center 32x32 square isn‚Äôt a magic square.\n\nis_magic(franklin[48:80, 48:80])\n\nFalse\n\n\nThe numbers in the center square do range from 1 to 1024.\n\nis_normal(franklin[48:80, 48:80])\n\nTrue\n\n\nBy looking at the entire magic square as a heatmap, we can get a better understanding of how the magic square is structured.\n\nplot_square(franklin, center_only=False, figsize=(10, 10))\n\n\n\n\n\n\n\n\nFranklin‚Äôs picture seems to not only be contained in the center 32x32 square, but repeats itself in the surrounding area. Furthermore, half of the pictures appear to be inverted.\nThe key to understanding how to create these was actually another example from Ot Ottenheim‚Äôs blog.\n\n\n\nAnother magic square featuring Benjamin Franklin\n\n\nThis magic square shows the same picture of Benjamin Franklin, but this time in a 4x4 grid. It made me realize that the magic square that shows the picture of Franklin in the center is actually the same 4x4 grid but scrambled.\nBy zooming in on the 4x4 grid, and looking at the ranges of numbers in each subsquare, I found out that these magic squares are actually constructed from the same 4x4 panmagic square we looked at earlier.\n\nprint_square(ms4)\n\n18101512133672169141154"
  },
  {
    "objectID": "posts/embedding-pictures-into-magic-squares/index.html#creating-a-magic-square-from-an-image-step-by-step",
    "href": "posts/embedding-pictures-into-magic-squares/index.html#creating-a-magic-square-from-an-image-step-by-step",
    "title": "Embedding Pictures into Magic Squares",
    "section": "Creating a magic square from an image step by step",
    "text": "Creating a magic square from an image step by step\nNow let‚Äôs try to understand the process by taking a picture and creating a magic square. We‚Äôll use a 16x16 sprite of Mario to create a 64x64 magic square.\n\nLoading the image\nWe start by loading the image from disk.\n\nfrom PIL import Image\n\nmario_sprite = Image.open('mario.png')\n\nThis is what the image looks like in color:\n\nplt.imshow(mario_sprite)\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nConverting the image to grayscale\nIn order to embed the image into a magic square, we need to convert it to grayscale. We also want 0 to represent white and 255 to represent black, so we need to invert the colors.\n\nmario_grayscale = mario_sprite.convert('L')\nmario_grayscale = 255 - np.array(mario_grayscale, dtype=int)\n\nIn greyscale, the image looks like this:\n\nplt.imshow(mario_grayscale, cmap='gray_r', interpolation='nearest')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nMapping pixel values to a range from 1 to 256\nWe need to convert the pixel values to a range from 1 to 256, without duplicate values, so we can use them in a magic square. We can do this by ordering the pixels from light to dark and then give each pixel a new value starting from 1.\n\ndef relabel_unique(arr):\n    n = arr.shape[0]\n    flat = arr.flatten()\n    # Get sorted indices for stable relabeling\n    sorted_indices = np.argsort(flat, kind='stable')\n    # Create an empty array for the relabeled values\n    relabeled = np.empty_like(flat)\n    # Assign numbers 1 to n^2 in the order of sorted values\n    relabeled[sorted_indices] = np.arange(1, n*n + 1)\n    # Reshape back to original shape\n    return relabeled.reshape(arr.shape)\n\n\nmario_relabeled = relabel_unique(mario_grayscale)\n\n\nplot_square(mario_relabeled, center_only=False, show_values=True, figsize=(5, 5))\n\n\n\n\n\n\n\n\nNow no two pixels have the same value.\n\n\nTiling the image into a magic square\nWe can now start composing the actual magic square. Remember that we‚Äôll use the 4x4 panmagic square shown earlier as our base.\n\nprint_square(ms4)\n\n18101512133672169141154\n\n\nWe want to tile copies of the image into a 4x4 grid. The 4x4 panmagic square will tell us the range of numbers that will be used in each of these copies.\nThe top left value of the 4x4 panmagic square is 1, so the top left copy of the image in the 4x4 grid of tiles will contain the pixels with values from 1 to 256. The value 2 in the panmagic square indicates that the copy of the image in the third row/second column will contain pixels with values from 257 to 512, and so on.\nThe following code takes care of this tiling process.\n\nmario_tiled = np.kron(ms4 - 1, np.ones(mario_relabeled.shape, dtype=int)) * np.max(mario_relabeled) + np.tile(mario_relabeled, ms4.shape)\n\n\nplot_square(mario_tiled, center_only=False, show_values=True, figsize=(10, 10))\n\n\n\n\n\n\n\n\n\n\nInverting half the tiles\nOur magic square is not yet complete. We still need to invert half of the tiles, as we saw in the example with Franklin‚Äôs picture.\nThe following function replaces each number in the square with its complementary number. The complementary number is defined as \\(n^2 + 1 - x\\) where \\(x\\) is the number in the cell and \\(n\\) is the size of the tile (in this case 16).\n\ndef complement_square(m):\n    min_val = np.min(m)\n    max_val = np.max(m)\n    comp_sum = min_val + max_val\n    return comp_sum - m\n\nThe next function applies this transformation to the tiles based on a boolean mask that indicates which tiles to invert.\n\ndef conditional_complement_blocks(bool_mask, arr):\n    n_blocks = 4\n    block_size = arr.shape[0] // 4\n    out = arr.copy()\n    for i in range(n_blocks):\n        for j in range(n_blocks):\n            if bool_mask[i, j]:\n                r0, r1 = i * block_size, (i + 1) * block_size\n                c0, c1 = j * block_size, (j + 1) * block_size\n                out[r0:r1, c0:c1] = complement_square(arr[r0:r1, c0:c1])\n    return out\n\nWe want to invert 2 tiles in each row and column. One easy way to do this is to invert the tiles where the value in the panmagic square is larger than 8.\n\nmario16x = conditional_complement_blocks(ms4 &gt; 8, mario_tiled)\n\nLet‚Äôs see if we indeed ended up with a magic square.\n\nis_magic(mario16x) and is_panmagic(mario16x) and is_normal(mario16x)\n\nTrue\n\n\nAnd indeed, the square is magic and panmagic, just like we wanted!\n\n\nPlotting the tiled images\nThe following function plots the magic square as a heatmap, where each tile is plotted in a different color.\n\nfrom matplotlib.colors import LinearSegmentedColormap\nimport matplotlib.colors as mcolors\n\ndef plot_square_colored_blocks(m, show_values=True, figsize=(8, 8)):\n    invert = ms4 &gt; 8\n\n    n = m.shape[0]\n    block_size = n // 4\n    \n    # Define a list of colors to cycle through\n    tab_colors = list(mcolors.TABLEAU_COLORS.keys())\n    \n    plt.figure(figsize=figsize)\n    plt.xlim(-0.5, n)\n    plt.ylim(n, -0.5)\n\n    for i in range(4):\n        for j in range(4):\n            r0, r1 = i * block_size, (i + 1) * block_size\n            c0, c1 = j * block_size, (j + 1) * block_size\n            block = m[r0:r1, c0:c1]\n\n            color = tab_colors[(i * 4 + j) % len(tab_colors)]\n            colors = ['white', color] if not invert[i, j] else [color, 'white']\n            cmap = LinearSegmentedColormap.from_list(f'cmap_{i}_{j}', colors)\n\n            plt.imshow(block, cmap=cmap, interpolation='nearest', extent=(c0 - 0.5, c1 - 0.5, r1 - 0.5, r0 - 0.5))\n\n    if show_values:        \n        ax = plt.gca()\n        fig = plt.gcf()\n        bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\n        width, height = bbox.width * fig.dpi, bbox.height * fig.dpi\n        cell_width = width / n\n        n_digits = len(str(abs(n * n)))\n\n        for (j, i), label in np.ndenumerate(m):\n            plt.text(i, j, label, ha='center', va='center', color='black', fontsize=cell_width / n_digits)\n\n\n    plt.axis('off')\n    plt.show()\n\n\nplot_square_colored_blocks(mario16x, figsize=(10, 10))\n\n\n\n\n\n\n\n\nWe can save this magic square to a file if we want.\n\nnp.savetxt(\"mario16x.csv\", mario16x, fmt='%d', delimiter=\";\")\n\n\n\nCentering the image\nAs mentioned before, a property of panmagic squares is that moving columns from the left side to the right side, or moving top rows to the bottom, will always yield another panmagic square.\nWe can use this property to center the image.\n\nd = mario16x.shape[0] // 8 * 5\nmario_shifted = np.hstack((mario16x[:, d:], mario16x[:, :d]))\nmario1x = np.vstack((mario_shifted[d:, :], mario_shifted[:d, :]))\n\n\nplot_square(mario1x, center_only=True, show_values=True, figsize=(10, 10))\n\n\n\n\n\n\n\n\nAs expected, the resulting magic square is still panmagic.\n\nis_magic(mario1x) and is_panmagic(mario1x) and is_normal(mario1x)\n\nTrue\n\n\nAmazing! Now let‚Äôs save it to a file.\n\nnp.savetxt(\"mario1x.csv\", mario1x, fmt='%d', delimiter=\";\")"
  },
  {
    "objectID": "posts/embedding-pictures-into-magic-squares/index.html#all-steps-in-one-function",
    "href": "posts/embedding-pictures-into-magic-squares/index.html#all-steps-in-one-function",
    "title": "Embedding Pictures into Magic Squares",
    "section": "All steps in one function",
    "text": "All steps in one function\nFor convenience, we define a function that combines all steps. The function takes an image file path, resizes it to the provided size, and returns a magic square that contains the image. Centering the image is optional.\n\ndef create_magic_square_from_image(image_path, image_size=(32, 32), center_image=True):\n    # Load and process the image\n    sprite = Image.open(image_path).resize(image_size, Image.LANCZOS)\n    sprite_gray = sprite.convert('L')\n    sprite_array = 255 - np.array(sprite_gray, dtype=int)\n    \n    # Relabel the unique values in the image\n    relabeled_sprite = relabel_unique(sprite_array)\n    \n    # Create a tiled magic square\n    tiled_magic_square = np.kron(ms4 - 1, np.ones(relabeled_sprite.shape, dtype=int)) * np.max(relabeled_sprite) + np.tile(relabeled_sprite, ms4.shape)\n    \n    # Apply conditional complement blocks\n    complemented_magic_square = conditional_complement_blocks(ms4 &gt; 8, tiled_magic_square)\n    \n    # Center the image in the magic square if required\n    if center_image:\n        d = complemented_magic_square.shape[0] // 8 * 5\n        shifted_magic_square = np.hstack((complemented_magic_square[:, d:], complemented_magic_square[:, :d]))\n        centered_magic_square = np.vstack((shifted_magic_square[d:, :], shifted_magic_square[:d, :]))\n        return centered_magic_square\n    \n    return complemented_magic_square"
  },
  {
    "objectID": "posts/embedding-pictures-into-magic-squares/index.html#creating-some-more-magic-squares",
    "href": "posts/embedding-pictures-into-magic-squares/index.html#creating-some-more-magic-squares",
    "title": "Embedding Pictures into Magic Squares",
    "section": "Creating some more magic squares",
    "text": "Creating some more magic squares\nNow that we have a function to create magic squares from images, let‚Äôs create some more. I‚Äôve chosen images of people who have, like Benjamin Franklin, created, or studied magic squares.\n\nSrinivasa Ramanujan\n\nSrinivasa Ramanujan was an Indian mathematician who made significant contributions to mathematical analysis, number theory, infinite series, and continued fractions.\nRamanujan also came up with the following magic square:\n\n\n\n22\n\n\n12\n\n\n18\n\n\n87\n\n\n\n\n88\n\n\n17\n\n\n9\n\n\n25\n\n\n\n\n10\n\n\n24\n\n\n89\n\n\n16\n\n\n\n\n19\n\n\n86\n\n\n23\n\n\n11\n\n\n\nIn it, the sum of each row, column, and diagonal is 139. In addition, the sum of any 2x2 box is also 139. As the cells are not consecutive integers starting from 1, this is not a normal magic square. The first row shows his birthdate (22/12/1887).\n\nramanujan1x = create_magic_square_from_image('ramanujan.jpg', image_size=(64, 64), center_image=True)\nplot_square(ramanujan1x, center_only=True, show_values=True, figsize=(10, 10))\nnp.savetxt(\"ramanujan1x.csv\", ramanujan1x, fmt='%d', delimiter=\";\")\n\n\n\n\n\n\n\n\nThe resulting file can be found here.\n\n\nJohn Horton Conway\n\nJohn Conway made contributions to many branches of recreational mathematics. He‚Äôs likely best known for inventing the Game of Life.\nHe also thought up an interesting method to construct magic squares of order 4n+2, where n is a natural number, which he called the Conway‚Äôs LUX method.\n\nconway1x = create_magic_square_from_image('conway.jpg', image_size=(64, 64), center_image=True)\nplot_square(conway1x, center_only=True, show_values=True, figsize=(10, 10))\nnp.savetxt(\"conway1x.csv\", conway1x, fmt='%d', delimiter=\";\")\n\n\n\n\n\n\n\n\nThis file is the result of saving this magic square.\n\n\nLeonhard Euler\n\nLeonhard Euler was a Swiss mathematician and physicist who made important discoveries in fields like calculus, graph theory, topology, mechanics, fluid dynamics, astronomy, and number theory.\nIn 1770 Euler found a magic square of order 4 filled with squares.\n\n\n\n68¬≤\n\n\n29¬≤\n\n\n41¬≤\n\n\n37¬≤\n\n\n\n\n17¬≤\n\n\n31¬≤\n\n\n79¬≤\n\n\n32¬≤\n\n\n\n\n59¬≤\n\n\n28¬≤\n\n\n23¬≤\n\n\n61¬≤\n\n\n\n\n11¬≤\n\n\n77¬≤\n\n\n8¬≤\n\n\n49¬≤\n\n\n\n\neuler16x = create_magic_square_from_image('euler.png', image_size=(32, 32), center_image=False)\nplot_square_colored_blocks(euler16x, show_values=True, figsize=(10, 10))\nnp.savetxt(\"euler16x.csv\", euler16x, fmt='%d', delimiter=\";\")\n\n\n\n\n\n\n\n\nThis time I chose to not center the image. Download the resulting file from here."
  },
  {
    "objectID": "posts/embedding-pictures-into-magic-squares/index.html#try-it-using-your-own-images",
    "href": "posts/embedding-pictures-into-magic-squares/index.html#try-it-using-your-own-images",
    "title": "Embedding Pictures into Magic Squares",
    "section": "Try it using your own images",
    "text": "Try it using your own images\nWant to turn your own image into a magic square? You can find my code as a GitHub gist:\n\nEnjoy!"
  },
  {
    "objectID": "posts/supercharging-the-nabaztag/index.html",
    "href": "posts/supercharging-the-nabaztag/index.html",
    "title": "Supercharging the Nabaztag",
    "section": "",
    "text": "The Nabaztag is a WiFi enabled ambient device shaped like a bunny. It has moveable ears, a speaker, several LEDs, and a button on its head. The second generation (the one I have) also has a microphone, an RFID sensor, and supports MP3 audio streams.\nThese Nabaztag bunnies rely on a server to function. Originally the company that produced these things provided for one but after they went bankrupt in 2009, thousands of these devices were rendered useless.\nLuckily, various alternative servers were developed. These servers often make use of plugins to give the connected bunnies certain abilities. Extending your bunny with new capabilities requires some programming skills if there is no existing plugin that already does what you want.\nI developed my own Nabaztag server in Prolog that you can download from this repository. Instead of making use of plugins to extend a Nabaztag‚Äôs capabilities, my server simply forwards all events to an IFTTT webhook. The server also exposes an API to do things like play audio, flash LEDs, move the ears, do TTS, etc. This API can be called from the IFTTT platform."
  },
  {
    "objectID": "posts/supercharging-the-nabaztag/index.html#about-the-ifttt-plaform",
    "href": "posts/supercharging-the-nabaztag/index.html#about-the-ifttt-plaform",
    "title": "Supercharging the Nabaztag",
    "section": "About the IFTTT plaform",
    "text": "About the IFTTT plaform\nIn case you don‚Äôt know, IFTTT (which stands for IF This Then That) is a platform that allows you to connect certain actions to certain triggers. You can for instance setup a ‚Äòrecipe‚Äô to turn on your Philips Hue lights (the action) when you phone connects to your home WiFi network (the trigger). Another example would be a recipe that sends you a Telegram message (the action) when the weather forecast predicts it‚Äôs going to rain (the trigger). By making use of IFTTT webhooks we can integrate triggers and actions of the Nabaztag into our recipes."
  },
  {
    "objectID": "posts/supercharging-the-nabaztag/index.html#example-recipes",
    "href": "posts/supercharging-the-nabaztag/index.html#example-recipes",
    "title": "Supercharging the Nabaztag",
    "section": "Example recipes",
    "text": "Example recipes\nI‚Äôll describe a few recipes that I setup to give you an idea of the possibilities. In the recipes below I assume the Nabaztag server is running and reachable at IP address 123.123.123.123.\n\nText to speech\nOne recipe makes the Nabaztag greet me when I get home. For this you need to have the IFTTT app installed on your phone.\n\nTrigger: Android device, Connects to a specific WiFi Network\n\nNetwork name: SSID_of_your_home_WiFi\n\nAction: Webhooks, make a web request\n\nURL: http://123.123.123.123/vl/api/tts.jsp\nMethod: POST\nContent Type: application/x-www-form-urlencoded\nBody: sn=0013d3123456&text=Welcome%20home\n\n\nReplace the parts in italics (the network name, IP address in the URL, and bunny‚Äôs serial number in the body) with your specifics.\n\n\nPlay sounds\nI also wanted the bunny to strike the hour like a cuckoo clock. For this I added 24 recipes, one for each hour. This is the one for 5PM.\n\nTrigger: Date & Time, Every day at\n\nTime: 05 PM, 00 minutes\n\nAction: Webhooks, make a web request\n\nURL: http://123.123.123.123/vl/api/play.jsp\nMethod: POST\nContent Type: application/x-www-form-urlencoded\nBody: sn=0013d3123456&url=http://123.123.123.123/vl/sounds/cuckoo5.mp3\n\n\nAgain, change the options in italics to your specifics.\n\n\nShow ambient patterns\nThe Nabaztag has various built-in ambient LED patterns that it can show when not doing anything else. There are built-in patterns that show the state of the weather, the market, traffic, messages, and air quality. We can set these ambient patterns on receiving certain triggers. For instance, we can set the ambient weather pattern to rain when the forecast for a certain location is rain:\n\nTrigger: Weather Underground, Current condition changes to\n\nCurrent Condition: Rain\nLocation: Your location\n\nAction: Webhooks, make a web request\n\nURL: http://123.123.123.123/vl/api/ambient.jsp?sn=0013d3123456&weather=rain\nMethod: POST\nContent Type: text/plain\nBody:\n\n\nAdd similar recipes for other weather conditions. Similarly one can make the bunny show ambient patterns that indicate what‚Äôs going on in the financial market if you‚Äôre keen on keeping track of that.\n\n\nRecord a message\nOne can also record a message on the Nabaztag by keeping the button on its head pressed. After the bunny beeps, you can speak into its microphone. On release, the recorded message is sent to the server. The server saves the message to a WAV file and sends the location of that file to the IFTTT platform where it can be caught using a webhook. The following recipe shows how this can be used to send an email every time a message is recorded.\n\nTrigger: Webhooks, Receive a web request\n\n0013d3123456_record_click\n\nAction: Email, Send me an email\n\nSubject: New message from your Nabaztag\nBody: Dear owner,&lt;br&gt;&lt;br&gt;On {{OccurredAt}} a message was recorded on your Nabaztag. Click &lt;a href=‚Äù{{Value1}}‚Äù&gt;here to download&lt;/a&gt;.&lt;br&gt;&lt;br&gt;Sincerely,&lt;br&gt;&lt;br&gt;Your favourite bunny"
  },
  {
    "objectID": "posts/supercharging-the-nabaztag/index.html#conclusion",
    "href": "posts/supercharging-the-nabaztag/index.html#conclusion",
    "title": "Supercharging the Nabaztag",
    "section": "Conclusion",
    "text": "Conclusion\nThese examples should be enough to get you started.\nRead the README.md file in the repository for details on how to configure the server and how to use the API. Take note that before running the server you‚Äôll need to enter the Nabaztag‚Äôs serial number, your IFTTT Webhook key, and server details into the config.pl file.\nShare your recipe ideas in the comments below!"
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html",
    "href": "posts/prettifying-my-phone/index.html",
    "title": "Prettifying My Phone",
    "section": "",
    "text": "Did you know the average Dutch person spends 2 hours and 46 minutes daily consuming content on their phone? Surprisingly, this is still quite a bit below the global average as people worldwide spend an average of 3 hours and 50 minutes on their mobiles each day. The Filipinos top the chart, with a whopping 5 hours and 20 minutes spent daily on their smartphones. For statistics on other countries, click here.\nGiven the insane amount of time we spend on our phones, it‚Äôs only logical to consider its mental health effects organize your apps in the neatest way possible. In this post, I‚Äôll show how to do just that using some math and Python."
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#the-best-way-to-organize-ones-apps",
    "href": "posts/prettifying-my-phone/index.html#the-best-way-to-organize-ones-apps",
    "title": "Prettifying My Phone",
    "section": "The best way to organize one‚Äôs apps",
    "text": "The best way to organize one‚Äôs apps\nThere are different ways to organize apps on the home screen of your phone. You can:\n\ngroup apps into categories such as travel, chat, or social media; or\narrange them alphabetically; or\norganize apps by color.\n\nWhile some people may claim that the first two ways of organizing helps you find apps faster, I couldn‚Äôt care less about issues like speed or usability. I just want my home screen to look pretty. Organizing by color is clearly the superior choice. Who needs efficiency when you can have aesthetics?\nHowever, organizing apps by color is challenging because many apps have multiple colors in various shades. This makes it difficult to group them. To make our home screens look good, we want to arrange our apps in such a way that the color difference between adjacent icons is minimal.\nThe solution I describe in this post is based on the following ideas:\n\nWe can quantify color differences between icons using the Chamfer distance function.\nFinding the best arrangement of apps (where color differences are minimized) is equivalent to finding the shortest Hamiltonian path through a graph. In this graph, vertices are the app icons, and edges are the color differences.\nTo decide which apps should be placed together on the same home screen, we can use hierarchical clustering.\n\nRead on to see how it all comes together."
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#importing-libraries",
    "href": "posts/prettifying-my-phone/index.html#importing-libraries",
    "title": "Prettifying My Phone",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe‚Äôll start by importing some dependencies.\n\nimport numpy as np\nimport glob\nimport random\nimport math\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\n\nfrom PIL import Image, ImageDraw\nfrom scipy.spatial import KDTree\nfrom ipywidgets import interact, interact_manual\nfrom scipy.cluster.hierarchy import linkage, dendrogram, fcluster\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\nfrom mpl_toolkits.mplot3d import Axes3D"
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#getting-the-icons",
    "href": "posts/prettifying-my-phone/index.html#getting-the-icons",
    "title": "Prettifying My Phone",
    "section": "Getting the icons",
    "text": "Getting the icons\nTo organize our apps by color, we first need to get the icons for all the apps installed on our phones. I found that the easiest and most reliable way to do this (on Android) is by using the Apk Analyzer app.\nOnce you have saved all icons, transfer them to your computer and place them in a folder called app_icons.\n\nApk Analyzer saves the icon files as JPEGs, which don‚Äôt support transparency. As can be seen in the image above, this will cause each icon to have a black background. We‚Äôll need to remove this programmatically later.\nThe following code finds all JPEG files in the app_icons folder and saves their names to a list.\n\nfiles = glob.glob(\"app_icons/*.jpeg\")"
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#loading-all-images-and-removing-the-background",
    "href": "posts/prettifying-my-phone/index.html#loading-all-images-and-removing-the-background",
    "title": "Prettifying My Phone",
    "section": "Loading all images and removing the background",
    "text": "Loading all images and removing the background\nNow that we have a list of file names, we can load the images. As mentioned above, we‚Äôll need to remove the black background. To do this, we‚Äôll create a mask that can be applied to each image. The following functions will handle creating and applying this mask to each image.\n\ndef create_mask(size):\n    # Create a mask image with a transparent (black) background\n    mask = Image.new(\"L\", size, 0)\n\n    margin = int(size[0] * 0.03)\n    radius = int(size[0] * 0.37)\n        \n    # Draw a white rounded rectangle on the mask\n    draw = ImageDraw.Draw(mask)\n    draw.rounded_rectangle([(margin, margin), (size[0] - margin, size[1] - margin)], radius=radius, fill=255)\n\n    return mask\n\n\ndef apply_mask(image, mask):\n    # Create a white background image\n    white_bg = Image.new(\"RGBA\", image.size, (255, 255, 255, 255))\n\n    # Composite the images using the mask\n    result = Image.composite(image, white_bg, mask)\n    \n    return result.convert(\"RGB\")\n\n\ndef remove_background(image):\n    mask = create_mask(image.size)\n    return apply_mask(image, mask)\n\nWe‚Äôll resize each image to 64x64 to ensure they all have the same size.\n\nsize = (64, 64)\n\nThe mask that is applied to each image looks like this:\n\nmask = create_mask((265,265)).resize(size)\nmask\n\n\n\n\n\n\n\n\nNext, let‚Äôs load all images and remove their backgrounds.\n\nimages = [remove_background(Image.open(f)).resize(size) for f in files]"
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#plotting-all-images-in-a-grid",
    "href": "posts/prettifying-my-phone/index.html#plotting-all-images-in-a-grid",
    "title": "Prettifying My Phone",
    "section": "Plotting all images in a grid",
    "text": "Plotting all images in a grid\nThe helper function below will display all the images in a grid.\n\ndef plot_image_grid(images, ncols=None, title=''):\n    ncols = ncols or int(np.sqrt(len(images)))\n    nrows, ncols = (len(images) + ncols - 1) // ncols, ncols\n    imgs = images + [None] * (nrows * ncols - len(images))\n    fig, axes = plt.subplots(nrows, ncols, figsize=(ncols, nrows))\n    if title:\n        fig.suptitle(title, x=0.125, ha='left')\n    for img, ax in zip(imgs, axes.flatten()): \n        if img is not None:\n            ax.imshow(img)\n        ax.axis('off')\n\nLet‚Äôs call this function to display our loaded images.\n\nplot_image_grid(images, 15)\n\n\n\n\n\n\n\n\nSuch a chaotic look! Let‚Äôs quickly move on to organizing this mess!"
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#the-chamfer-distance",
    "href": "posts/prettifying-my-phone/index.html#the-chamfer-distance",
    "title": "Prettifying My Phone",
    "section": "The Chamfer distance",
    "text": "The Chamfer distance\nIn order to quantify the difference in color palette between two app icons we will use the Chamfer distance. This particular distance metric is a measure of dissimilarity between two sets of points. It calculates how far points in one set are from the nearest points in another set, averaged over all points.\nIn our case, each set represents all the pixels in one image. Each pixel has an RGB value that represents one point. The smaller the Chamfer distance, the more similar in color the two images are.\nIts symmetric version can be defined as follows:\n\\[d_{\\text{CD}}(A, B) = \\frac{1}{|A|} \\sum_{a \\in A} \\min_{b \\in B} \\| a - b \\|_2 + \\frac{1}{|B|} \\sum_{b \\in B} \\min_{a \\in A} \\| b - a \\|_2\\]\nwhere\n\n\\(\\| \\cdot \\|_2\\) denotes the Euclidean distance.\n\\(\\min_{b \\in B} \\| a - b \\|_2\\) represents the minimum Euclidean distance from a point \\(a \\in A\\) to any point in \\(b \\in B\\).\n\\(\\min_{a \\in A} \\| b - a \\|_2\\) represents the minimum Euclidean distance from a point \\(b \\in B\\) to any point in \\(a \\in A\\).\n\\(|A|\\) and \\(|B|\\) denote the number of points in sets \\(A\\) and \\(B\\), respectively.\n\nN.B.: You might see variations of this distance metric. When used as a loss function the Euclidian distances are generally squared. This makes the resulting function smooth and differentiable which is useful in gradient-based optimization algorithms. This isn‚Äôt needed in our situation.\nThe following function calculates the Chamfer distance. It was taken from here. It uses KDTree for efficient nearest neighbor searches.\n\ndef chamfer_distance(a, b):\n    tree = KDTree(b)\n    dist_a = tree.query(a)[0]\n    tree = KDTree(a)\n    dist_b = tree.query(b)[0]\n    return np.mean(dist_a) + np.mean(dist_b)"
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#computing-the-chamfer-distance-between-two-images",
    "href": "posts/prettifying-my-phone/index.html#computing-the-chamfer-distance-between-two-images",
    "title": "Prettifying My Phone",
    "section": "Computing the Chamfer distance between two images",
    "text": "Computing the Chamfer distance between two images\nLet‚Äôs explore a bit more visually how the Chamfer distance is used to quantify the dissimilarity between the color palettes of two images.\nAs an example we‚Äôll compute the Chamfer distance between the first two images we have loaded.\n\nplot_image_grid([images[0],images[1]], 2)\n\n\n\n\n\n\n\n\nThe following function creates a 3D scatterplot to visualize the RGB values of an image‚Äôs pixels. In this plot, the x-axis, y-axis, and z-axis represent the red, green, and blue color values, respectively. Each point in the scatterplot corresponds to a pixel, and its position is determined by the pixel‚Äôs RGB values.\n\ndef plot_image_colors(image, ax=None, title=''):\n    boolean_mask = np.array(mask).astype(bool).flatten()\n    data = np.array(image).reshape((64*64, -1))[boolean_mask]\n\n    R, G, B = data[:, 0], data[:, 1], data[:, 2]\n    colors = data / 255.0\n    \n    if not ax:\n        fig = plt.figure(figsize=(7, 6))\n        ax = fig.add_subplot(111, projection='3d')\n    else:\n        fig = ax.get_figure()\n    \n    scatter = ax.scatter(R, G, B, c=colors, s=100)\n    ax.set_xlabel('Red')\n    ax.set_ylabel('Green')\n    ax.set_zlabel('Blue', labelpad=0)\n    ax.zaxis.label.set_rotation(90)\n    ax.xaxis.set_ticks(np.arange(0, 256, 50))\n    ax.yaxis.set_ticks(np.arange(0, 256, 50))\n    ax.zaxis.set_ticks(np.arange(0, 256, 50))\n    ax.set_title(title)\n    \n    # Add inset axis for the image\n    inset_ax = fig.add_axes([ax.get_position().x0, ax.get_position().y1 - 0.15, 0.1, 0.1])\n    inset_ax.imshow(image)\n    inset_ax.axis('off')\n\nIf we plot the colors of the first image, we get the following:\n\nplot_image_colors(images[0])\n\n\n\n\n\n\n\n\nNow let‚Äôs do the same for the second image:\n\nplot_image_colors(images[1])\n\n\n\n\n\n\n\n\nAs you can see, in this case, the points in one scatterplot are, on average, quite far from the nearest point in the other scatterplot. Calculating the Chamfer distance between the two sets of points gives us a relatively high value.\n\n# Create a boolean mask\nboolean_mask = np.array(mask).astype(bool).flatten()\n\n# The number of pixels\nnum_pixels = math.prod(size)\n\nchamfer_distance(np.array(images[0]).reshape((num_pixels, -1))[boolean_mask], np.array(images[1]).reshape((num_pixels, -1))[boolean_mask])\n\n226.8853693815226\n\n\nNote how a boolean mask is applied to exclude the pixels that are not part of the actual icon. In other words, we exclude all pixels that lie outside the rounded rectangle. Furthermore, the image is converted to a numpy array and reshaped in such a way that each row represents the RGB value of one pixel as this is how the chamfer_distance function expects it."
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#comparing-images-pairwise",
    "href": "posts/prettifying-my-phone/index.html#comparing-images-pairwise",
    "title": "Prettifying My Phone",
    "section": "Comparing images pairwise",
    "text": "Comparing images pairwise\nThe code below allows us to interactively compare pairs of images side-by-side.\nnp_images_foreground = [np.array(image).reshape((num_pixels, -1))[boolean_mask] for image in images]\n\ndef plot_images_colors_side_by_side(image_num1, image_num2):\n    image1 = images[image_num1]\n    image2 = images[image_num2]\n    \n    fig = plt.figure(figsize=(14, 6))\n    \n    # First subplot\n    ax1 = fig.add_subplot(121, projection='3d')\n    plot_image_colors(image1, ax1, 'Image 1')\n    \n    # Second subplot\n    ax2 = fig.add_subplot(122, projection='3d')\n    plot_image_colors(image2, ax2, 'Image 2')\n\n    fig.text(0.5, 0.02, f'Chamfer distance: {chamfer_distance(np_images_foreground[image_num1], np_images_foreground[image_num2])}', ha='center', va='center', fontsize=12)\n    \n    plt.show()\n\n_ = interact(plot_images_colors_side_by_side, \n    image_num1=widgets.IntSlider(min=0, max=len(images) - 1, step=1, value=0, description=\"Image 1: \"), \n    image_num2=widgets.IntSlider(min=0, max=len(images) - 1, step=1, value=1, description=\"Image 2: \")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe sliders allow us to select and compare different icons. The Chamfer distance between the two images selected above is in this case quite small. You can see how that makes sense as points in one scatterplot are closer, on average, to a nearest point in the other scatterplot."
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#computing-the-distance-matrix",
    "href": "posts/prettifying-my-phone/index.html#computing-the-distance-matrix",
    "title": "Prettifying My Phone",
    "section": "Computing the distance matrix",
    "text": "Computing the distance matrix\nThe distance matrix contains the Chamfer distance between each pair of images and is computed using the following code:\n# Initialize the distance matrix\nnum_sets = len(np_images_foreground)\ndistance_matrix = np.zeros((num_sets, num_sets))\n\n# Populate the distance matrix\nfor i in range(num_sets):\n    for j in range(i + 1, num_sets):\n        distance = chamfer_distance(np_images_foreground[i], np_images_foreground[j])\n        distance_matrix[i, j] = distance\n        distance_matrix[j, i] = distance  # Use symmetry\nComputing the Chamfer distance between each pair of images may take a minute or so depending on the speed of your hardware.\nThe maximum value in the distance matrix tells us which two images are most dissimilar.\n\nstart, end = np.unravel_index(np.argmax(distance_matrix), distance_matrix.shape)\n\n\nplot_image_grid([images[start],images[end]], 2)\n\n\n\n\n\n\n\n\nIt‚Äôs between these two images that we want to find a Hamiltonian path."
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#finding-the-shortest-hamiltonian-path",
    "href": "posts/prettifying-my-phone/index.html#finding-the-shortest-hamiltonian-path",
    "title": "Prettifying My Phone",
    "section": "Finding the shortest Hamiltonian path",
    "text": "Finding the shortest Hamiltonian path\nThe shortest Hamiltonian path traverses all vertices in a graph exactly once while minimizing the total distance traveled. Here each vertex corresponds to an image, and the edges are weighted based on the Chamfer distance between these images. Such a path should yield a visually pleasing sequence of app icons.\nThe following code applies simulated annealing to attempt to find the shortest Hamiltonian path in a graph represented by a distance matrix.\n\ndef total_distance(path, distance_matrix):\n    return sum(distance_matrix[path[i], path[i + 1]] for i in range(len(path) - 1))\n\ndef shortest_hamiltonian_path(distance_matrix, start, end, initial_temp, cooling_rate, stopping_temp, initial_path=None):\n    current_path = initial_path or list(range(distance_matrix.shape[0]))\n    current_path.remove(start)\n    if start != end:\n        current_path.remove(end)\n    current_path = [start] + current_path + [end]\n    \n    n = len(current_path)\n\n    current_distance = total_distance(current_path, distance_matrix)\n    temperature = initial_temp\n    \n    while temperature &gt; stopping_temp:\n        # Generate a neighbor by reversing a subtour (excluding start and end)\n        i, j = sorted(random.sample(range(1, n - 1), 2))\n        new_path = current_path[0:i] + current_path[i:j+1][::-1] + current_path[j+1:]\n        \n        new_distance = total_distance(new_path, distance_matrix)\n        \n        # Acceptance probability\n        if new_distance &lt; current_distance or random.random() &lt; np.exp((current_distance - new_distance) / temperature):\n            current_path, current_distance = new_path, new_distance\n        \n        temperature *= cooling_rate\n    \n    return current_path, current_distance\n\nWe will use shortest_hamiltonian_path to find a path between the two app icons with the most dissimilar color schemes. This function requires three parameters to control the temperature schedule: initial temperature (initial_temp), cooling rate (cooling_rate), and stopping temperature (stopping_temp). The initial temperature starts high to allow broad exploration of the search space, accepting worse solutions to avoid local minima. The cooling rate gradually reduces the temperature, shifting focus to refining the solution. The process continues until the temperature drops below the stopping temperature, ensuring the algorithm terminates efficiently while aiming for an optimal solution.\ninitial_temp = 400000\ncooling_rate = 0.99995\nstopping_temp = 1e-8\n\npath, distance = shortest_hamiltonian_path(distance_matrix, start, end, initial_temp, cooling_rate, stopping_temp)\nprint(\"Shortest Hamiltonian path:\", path)\nprint(\"Distance:\", distance)\n\n\nShortest Hamiltonian path: [23, 72, 5, 35, 53, 63, 44, 78, 8, 11, 22, 65, 77, 39, 51, 4, 33, 10, 38, 19, 0, 14, 27, 60, 40, 66, 87, 32, 83, 30, 9, 37, 82, 34, 17, 61, 75, 15, 49, 55, 2, 25, 62, 69, 26, 46, 74, 68, 24, 54, 57, 80, 71, 7, 86, 59, 21, 29, 28, 79, 70, 56, 41, 31, 81, 3, 13, 16, 42, 12, 36, 84, 58, 6, 18, 50, 45, 76, 52, 85, 73, 64, 20, 47, 1, 48, 43, 67]\nDistance: 2201.440737366966\n\n\nOnce the function returns a path we can use this to reorder the images into a more visually pleasing sequence.\n\nsorted_images = [images[i] for i in path]\n\n\nplot_image_grid(sorted_images, 15)\n\n\n\n\n\n\n\n\nDoesn‚Äôt this look amazing!? Honestly, this belongs in a museum.\nThere‚Äôs one issue though. This many apps won‚Äôt fit on the same home screen and distributing these apps over several screens breaks the visual flow. It just won‚Äôt look as good.\nWhat we want to do is first cluster the apps by color scheme, and following that, choose which of these clusters can be placed on the same home screen. Then we try to find a shortest Hamiltonian path per screen. We‚Äôll use hierarchical clustering to find a good grouping."
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#grouping-apps-using-hierarchical-clustering",
    "href": "posts/prettifying-my-phone/index.html#grouping-apps-using-hierarchical-clustering",
    "title": "Prettifying My Phone",
    "section": "Grouping apps using hierarchical clustering",
    "text": "Grouping apps using hierarchical clustering\nWe can use the previously calculated distance matrix to perform hierarchical clustering. I decided to go with Ward‚Äôs linkage which tends to create more compact and spherical clusters.\n\n# Convert the distance matrix to a condensed distance matrix\n# The condensed distance matrix contains the upper triangular part of the distance matrix\ncondensed_distance_matrix = distance_matrix[np.triu_indices_from(distance_matrix, k=1)]\n\n# Perform hierarchical clustering using the linkage method\nZ = linkage(condensed_distance_matrix, method='ward')\n\nWard‚Äôs linkage is an agglomerative method which means that it starts with each image as its own cluster and merges pairs based on minimal variance increase. This process forms a hierarchical cluster sequence that can be visualized in a dendrogram.\n\ndef plot_dendrogram(max_d=0):\n    fig, ax = plt.subplots(figsize=(18, 6))\n    dendrogram(Z, ax=ax)\n    ax.set_title('Hierarchical Clustering Dendrogram')\n    ax.set_ylabel('Distance')\n\n    if max_d:\n        ax.axhline(y=max_d, linestyle='--', color='grey')\n    \n    tick_labels = ax.xaxis.get_ticklabels()\n    for i in range(len(images)):\n        ib = OffsetImage(images[int(tick_labels[i].get_text())], zoom=.18)\n        ib.image.axes = ax\n        ab = AnnotationBbox(ib, tick_labels[i].get_position(), frameon=False, box_alignment=(0.5, 1.2))\n        ax.add_artist(ab)\n    ax.set_xticks([])\n    \n    plt.show()\n\n\nplot_dendrogram()\n\n\n\n\n\n\n\n\nAs you can tell from the dendrogram shown above, the apps have been clustered based on color palette similarity. By selecting a distance threshold we can determine a suitable set of clusters."
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#selecting-clusters-and-ordering-apps",
    "href": "posts/prettifying-my-phone/index.html#selecting-clusters-and-ordering-apps",
    "title": "Prettifying My Phone",
    "section": "Selecting clusters and ordering apps",
    "text": "Selecting clusters and ordering apps\nThe code below allows us to interactively adjust a distance threshold using a slider to determine the number of clusters. We can then press Show clusters to see which images belong to each cluster. Finally, we can select specific clusters and press Find path to find the shortest Hamiltonian path through the icons in these clusters.\n@interact(max_d=widgets.IntSlider(min=0, max=int(np.max(Z)), step=1, value=int(np.max(Z) / 2), description=\"Distance: \"))\ndef plot_dendrogram_with_threshold(max_d):\n    plot_dendrogram(max_d)\n\n    @interact_manual.options(manual_name=\"Show clusters\")\n    def plot_clusters():\n        clusters = fcluster(Z, max_d, criterion='distance')\n        \n        for cluster_label in range(1, max(clusters) + 1):\n            indices = np.where(clusters == cluster_label)[0]\n            plot_image_grid([images[i] for i in indices], 25, f'Cluster {cluster_label}')\n\n        find_path_interact_manual = interact_manual.options(manual_name=\"Find path\")\n        @find_path_interact_manual(cluster_labels=widgets.widgets.SelectMultiple(options=[(f'Cluster {cl}', cl) for cl in range(1, max(clusters) + 1)], description='Clusters: '))\n        def find_hamiltonian_path(cluster_labels):\n            selected_indices = np.where(np.isin(clusters, cluster_labels))[0]\n            if selected_indices.size &gt; 0:\n                distance_submatrix = distance_matrix[np.ix_(selected_indices, selected_indices)]\n                max_value = np.max(distance_submatrix)\n                result = np.where(distance_matrix == max_value)\n                start, end = result[0][0], result[1][0]\n\n                initial_temp = 400000\n                cooling_rate = 0.99995\n                stopping_temp = 1e-8\n                path, _ = shortest_hamiltonian_path(distance_matrix, start, end, initial_temp, cooling_rate, stopping_temp, list(selected_indices))\n                \n                sorted_images = [images[i] for i in path]\n                plot_image_grid(sorted_images, 5)\n            else:\n                print(\"Select on or more clusters.\")        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere I‚Äôve selected 192 as the threshold. Clusters 1 and 2 contain red, orange, and yellow icons that go well together on the same home screen. We can see that the Hamiltonian path through all icons in these two clusters yields an aesthetically pleasing sequence.\nCluster 4 and 5 both contain blueish icons and also go well together. Each screen on my phone contains 25 app icons at most so this is something I took into consideration when selecting clusters. Cluster 8 also contains some blue icons but because only 25 apps fit on the same screen I decided to keep them apart. Because they‚Äôre a bit darker too I figured they‚Äôd go well with cluster 7.\nWe can see that cluster 3 contains two green icons that would fit better with the app icons in cluster 6. By sliding the threshold to a slightly lower value, I moved these two green icons into a seperate cluster and then selected all green clusters to be put together on another screen.\nThe icons that combine red, green, blue, and yellow (mostly Google apps) are placed on one screen as well."
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#the-final-result",
    "href": "posts/prettifying-my-phone/index.html#the-final-result",
    "title": "Prettifying My Phone",
    "section": "The final result",
    "text": "The final result\nAfter rearranging all apps, my home screens look simply amazing!\n\nBeautiful! Wouldn‚Äôt you agree?"
  },
  {
    "objectID": "posts/prettifying-my-phone/index.html#prettifying-your-own-phone",
    "href": "posts/prettifying-my-phone/index.html#prettifying-your-own-phone",
    "title": "Prettifying My Phone",
    "section": "Prettifying your own phone",
    "text": "Prettifying your own phone\nIf you want to prettify your own home screens, you can find all the code in the following GitHub gist:\n\nHappy organizing!"
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html",
    "href": "posts/bridge-and-torch-puzzle/index.html",
    "title": "Bridge and Torch Puzzle",
    "section": "",
    "text": "The Bridge and torch puzzle goes like this:\nIn this blog post I give a solution and some code for finding all solutions in Prolog."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html#solving-the-puzzle",
    "href": "posts/bridge-and-torch-puzzle/index.html#solving-the-puzzle",
    "title": "Bridge and Torch Puzzle",
    "section": "Solving the puzzle",
    "text": "Solving the puzzle\nOne might guess that an obvious solution would be to let the fastest person (A) shuttle each other person over the bridge and return alone with the torch. This would give the following schedule:\n\n\n\nA, B\n\\(\\rightarrow\\)\n2 minutes\n\n\nA\n\\(\\leftarrow\\)\n1 minutes\n\n\nA, C\n\\(\\rightarrow\\)\n5 minutes\n\n\nA\n\\(\\leftarrow\\)\n1 minutes\n\n\nA, D\n\\(\\rightarrow\\)\n10 minutes\n\n\n\nThe total duration of this schedule would be 19 minutes, so the torch would run out of battery while person A and D are still on the bridge.\nThe optimal solution consists of letting the two slowest people (C and D) cross the bridge together, giving the following schedule:\n\n\n\nA, B\n\\(\\rightarrow\\)\n2 minutes\n\n\nB\n\\(\\leftarrow\\)\n2 minutes\n\n\nC, D\n\\(\\rightarrow\\)\n10 minutes\n\n\nA\n\\(\\leftarrow\\)\n1 minutes\n\n\nA, B\n\\(\\rightarrow\\)\n2 minutes\n\n\n\nWhich gives a total crossing time of exactly 17 minutes."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html#prolog-to-the-rescue",
    "href": "posts/bridge-and-torch-puzzle/index.html#prolog-to-the-rescue",
    "title": "Bridge and Torch Puzzle",
    "section": "Prolog to the rescue",
    "text": "Prolog to the rescue\nProlog is quite suitable for solving these kinds of search problems.\n\n\nbridge.pl\n\n% A Prolog solver for the bridge and torch puzzle\n% https://en.wikipedia.org/wiki/Bridge_and_torch_problem\n\nprint_all_solutions :-\n    findall(_,print_solution,_).\n\nprint_solution :-\n    init(State),\n    solve(State,Solution,EndState),\n    writeln('Start state:'),\n    writeln(State),\n    writeln('Solution:'),\n    writeln(Solution),\n    writeln('Final state:'),\n    writeln(EndState), nl.\n\nsolve(State,[],State) :- goal(State).\nsolve(State,[Move|Tail],EndState) :- s(State,Move,NewState), solve(NewState,Tail,EndState).\n\ngoal(state([],right,[_,_,_,_],T)) :- T =&lt; 17.\n\ninit(state([a,b,c,d],left,[],0)).\n\ns(state(L1,left,L2,T),cross(L3),state(L4,right,L6,T2)) :-       \n    select_one_or_two(L1,L3,L4),\n    ord_union(L2,L3,L6),\n    min_time_needed(L3,Tn),\n    T2 is T + Tn, \n    T2 =&lt; 17.\ns(state(L1,right,L2,T),cross(L3),state(L4,left,L5,T2)) :-       \n    select_one_or_two(L2,L3,L5),\n    ord_union(L1,L3,L4),\n    min_time_needed(L3,Tn),\n    T2 is T + Tn, \n    T2 =&lt; 17.\n\nselect_one_or_two(L,[Sel],L2) :- select(Sel,L,L2).\nselect_one_or_two(L,[Sel1,Sel2],L2) :- select(Sel1,L,NewL), select(Sel2,NewL,L2), Sel1@&lt;Sel2.\n\nmin_time_needed([A],T) :- time_needed(A,T).\nmin_time_needed([A,B],T) :- time_needed(A,T1), time_needed(B,T2), max_list([T1,T2],T).\n\ntime_needed(a,1).\ntime_needed(b,2).\ntime_needed(c,5).\ntime_needed(d,10).\n\nThe init predicate defines the initial state of the puzzle, which includes the positions of the four people and the torch, and the time taken so far. The goal predicate defines the goal state, which is when all four people are on the other side of the bridge in at most 17 minutes.\nThe program finds a sequence of moves that will get all four people across the bridge in the shortest time. The solve predicate recursively searches for a sequence of moves that will lead to the goal state. The s predicate defines the possible moves that can be made from a given state. The select_one_or_two predicate selects one or two people from the group to cross the bridge. The min_time_needed predicate calculates the time needed for the selected people to cross the bridge.\nI chose to represent a state by keeping track of two lists, one for each side of the bridge. An alternative representation might be to use one list with the times it takes each person and a positive/negative sign that indicates on which side of the brige the person is. This list could look like this: [1,2,-5,-10] and would indicate that the persons with times 1 and 2 are on one side of the bridge and the others would be on the other side. We could add another number, say 1 (or -1), to indicate on which side the flashlight is. Finding a suitable representation is often half the battle and multiple alternatives might work equally well.\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html#running-the-solver",
    "href": "posts/bridge-and-torch-puzzle/index.html#running-the-solver",
    "title": "Bridge and Torch Puzzle",
    "section": "Running the solver",
    "text": "Running the solver\nTo run the solver, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the solver by typing:\n[bridge].\nThis loads the bridge.pl file. You can execute the solver which will output all solutions to the console:\nprint_all_solutions.\nStart state:\nstate([a,b,c,d],left,[],0)\nSolution:\n[cross([a,b]),cross([a]),cross([c,d]),cross([b]),cross([a,b])]\nFinal state:\nstate([],right,[a,b,c,d],17)\n\nStart state:\nstate([a,b,c,d],left,[],0)\nSolution:\n[cross([a,b]),cross([b]),cross([c,d]),cross([a]),cross([a,b])]\nFinal state:\nstate([],right,[a,b,c,d],17)"
  },
  {
    "objectID": "posts/the-wolf-goat-and-cabbage-problem/index.html",
    "href": "posts/the-wolf-goat-and-cabbage-problem/index.html",
    "title": "The Wolf, Goat, and Cabbage Puzzle",
    "section": "",
    "text": "In my previous blog post I showed how to solve Takuzu puzzles using SQL. After writing that post I couldn‚Äôt stop wondering what other puzzles could be (somewhat elegantly) expressed and solved using SQL. I realized that the classic wolf, goat, and cabbage puzzle would be a good candidate. Its search space is very small and with a suitable state and action representation the SQL code isn‚Äôt too incomprehensible."
  },
  {
    "objectID": "posts/the-wolf-goat-and-cabbage-problem/index.html#so-whats-this-puzzle-about",
    "href": "posts/the-wolf-goat-and-cabbage-problem/index.html#so-whats-this-puzzle-about",
    "title": "The Wolf, Goat, and Cabbage Puzzle",
    "section": "So what‚Äôs this puzzle about?",
    "text": "So what‚Äôs this puzzle about?\nThe puzzle goes like this:\n\nA farmer needs to cross a river, bringing with him a wolf, a goat, and a cabbage. The boat is small, so the farmer can only take one of the three with him at a time. The difficulty comes from the fact that certain pairs can‚Äôt be left alone. If the wolf is left with the goat, the wolf will eat the goat. If the goat is left with the cabbage, the goat will eat the cabbage. Only the farmer‚Äôs presence prevents these things from happening.\n\nYou may want to try to solve by hand first before reading on. It‚Äôs not that hard."
  },
  {
    "objectID": "posts/the-wolf-goat-and-cabbage-problem/index.html#the-solver",
    "href": "posts/the-wolf-goat-and-cabbage-problem/index.html#the-solver",
    "title": "The Wolf, Goat, and Cabbage Puzzle",
    "section": "The solver",
    "text": "The solver\nThis is what I came up with:\nWITH RECURSIVE\n  moves(mask, move_desc) AS (\n    VALUES \n      (1, \"Farmer crosses alone\"),\n      (3, \"Farmer takes wolf\"),\n      (5, \"Farmer takes goat\"),\n      (9, \"Farmer takes cabbage\")\n  ),\n  states(i, visual) AS (\n    SELECT 0, 'üë® üê∫ üêê ü•¨ | üö£üåäüåäüåäüåä |'\n    UNION ALL\n    SELECT\n      i + 1,\n      (CASE (i+1&gt;&gt;0)&1 WHEN 0 THEN 'üë® ' ELSE '   ' END) ||\n      (CASE (i+1&gt;&gt;1)&1 WHEN 0 THEN 'üê∫ ' ELSE '   ' END) ||\n      (CASE (i+1&gt;&gt;2)&1 WHEN 0 THEN 'üêê ' ELSE '   ' END) ||\n      (CASE (i+1&gt;&gt;3)&1 WHEN 0 THEN 'ü•¨ ' ELSE '   ' END) ||\n      (CASE (i+1&gt;&gt;0)&1 WHEN 0 THEN '| üö£üåäüåäüåäüåä | ' ELSE '| üåäüåäüåäüåäüö£ | ' END) ||\n      (CASE (i+1&gt;&gt;0)&1 WHEN 1 THEN 'üë® ' ELSE '   ' END) ||\n      (CASE (i+1&gt;&gt;1)&1 WHEN 1 THEN 'üê∫ ' ELSE '   ' END) ||\n      (CASE (i+1&gt;&gt;2)&1 WHEN 1 THEN 'üêê ' ELSE '   ' END) ||\n      (CASE (i+1&gt;&gt;3)&1 WHEN 1 THEN 'ü•¨ ' ELSE '   ' END)\n    FROM states\n    WHERE i &lt; 15\n  ),\n  explore(state, path, actions) AS (\n    -- start\n    SELECT 0, '0', printf('%-20s | %s', 'Start') || visual FROM states WHERE i = 0\n    UNION ALL\n    SELECT\n      state + mask - 2*(state & mask) AS next_state,\n      path || ' -&gt; ' || (state + mask - 2*(state & mask)),\n      actions || char(10) || printf('%-20s | %s', move_desc) || visual\n    FROM explore, moves, states\n    WHERE\n      -- join with states CTE for visuals\n      state + mask - 2*(state & mask) = i\n      -- farmer must be with passenger (unless alone)\n      AND (mask = 1 OR ((state & 1) = (state & mask) / mask))\n      -- avoid revisiting states\n      AND instr(path, state + mask - 2*(state & mask)) = 0\n      -- wolf + goat unsafe\n      AND NOT (\n        ((state + mask - 2*(state & mask)) &gt;&gt; 1 & 1)\n          = ((state + mask - 2*(state & mask)) &gt;&gt; 2 & 1)\n        AND ((state + mask - 2*(state & mask)) &gt;&gt; 0 & 1)\n          != ((state + mask - 2*(state & mask)) &gt;&gt; 1 & 1)\n      )\n      -- goat + cabbage unsafe\n      AND NOT (\n        ((state + mask - 2*(state & mask)) &gt;&gt; 2 & 1)\n          = ((state + mask - 2*(state & mask)) &gt;&gt; 3 & 1)\n        AND ((state + mask - 2*(state & mask)) &gt;&gt; 0 & 1)\n          != ((state + mask - 2*(state & mask)) &gt;&gt; 2 & 1)\n      )\n  )\nSELECT\n  group_concat(actions, char(10) || char(10))\nFROM (\n  SELECT actions\n  FROM explore\n  WHERE state = 15\n);\nThe first two CTEs define the static parts of the problem: all possible moves and all possible states. The third CTE performs a recursive search over the state space, applying moves and filtering out invalid transitions."
  },
  {
    "objectID": "posts/the-wolf-goat-and-cabbage-problem/index.html#state-and-action-representation",
    "href": "posts/the-wolf-goat-and-cabbage-problem/index.html#state-and-action-representation",
    "title": "The Wolf, Goat, and Cabbage Puzzle",
    "section": "State and action representation",
    "text": "State and action representation\nThe query is kept small thanks to the bitmask representation of state and action.\nEach entity is represented by one bit:\n\n\n\nBit\nEntity\n\n\n\n\n0\nFarmer\n\n\n1\nWolf\n\n\n2\nGoat\n\n\n3\nCabbage\n\n\n\nIf a bit is 0, it means the entity is on the left bank, and a 1 means right bank. Using this representation the state is a number from 0 to 15:\n\n\n\n\n\n\n\n\nDecimal\nBinary\nMeaning\n\n\n\n\n0\n0000\nEverything including the farmer is on the left bank\n\n\n5\n0101\nFarmer and goat are on the right\n\n\n15\n1111\nEverything including the farmer is on the right bank\n\n\n\nThe goal state is simply 15.\nMoves are represented using the same bitmask scheme.\n\n\n\nMove\nMask\nBinary\n\n\n\n\nFarmer alone\n1\n0001\n\n\nFarmer and wolf\n3\n0011\n\n\nFarmer and goat\n5\n0101\n\n\nFarmer and cabbage\n9\n1001\n\n\n\nApplying a move (the farmer moving from one side of the river to the other, either alone or with one entity) means flipping those bits (using XOR).\nSince SQLite doesn‚Äôt have XOR, we rewrite XOR as:\nstate + mask - 2*(state & mask)\nwhich has the same effect.\nThe WHERE part in the CTE explore checks whether after applying a move, the wolf and goat, or the goat and cabbage, aren‚Äôt left unsupervised."
  },
  {
    "objectID": "posts/the-wolf-goat-and-cabbage-problem/index.html#running-the-query",
    "href": "posts/the-wolf-goat-and-cabbage-problem/index.html#running-the-query",
    "title": "The Wolf, Goat, and Cabbage Puzzle",
    "section": "Running the query",
    "text": "Running the query\nRunning the query produces the following output:\n\nThere are infinitely many solutions (as the farmer can just row back and forth), but the solver only outputs the two shortest ones. The solver does this by making sure that previously visited states aren‚Äôt repeated. Emojis are used to visualize the state after each action.\nYou can find the query as a gist here:"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html",
    "href": "posts/mathematicians-birthdays-calendar/index.html",
    "title": "Mathematicians‚Äô Birthdays Calendar",
    "section": "",
    "text": "I teach several courses in the Applied Mathematics program at NHL Stenden University of Applied Sciences. My favorite days are the ones when there‚Äôs something to celebrate (like a birthday) and someone brings cake.\nIn an effort to convince my department that we should have cake more often, I‚Äôve created a birthday calendar featuring the birthdates of mathematicians, both living and deceased. I scraped these birthdays from Wikipedia and converted them into an ICS file that can be imported into a calendar application like Google Calendar or Microsoft Outlook Calendar.\nRead on to learn how I did this."
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#importing-libraries",
    "href": "posts/mathematicians-birthdays-calendar/index.html#importing-libraries",
    "title": "Mathematicians‚Äô Birthdays Calendar",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing some libraries. I‚Äôm using Selenium for webscraping. The icalendar package is used to create the birthday calendar.\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.common.by import By\nfrom selenium.common.exceptions import NoSuchElementException\nfrom webdriver_manager.chrome import ChromeDriverManager\n\nfrom icalendar import Calendar, Event, vRecur\nfrom datetime import date\n\nfrom abc import ABC, abstractmethod\n\nimport pandas as pd\n\nimport re\nimport calendar\nimport pickle\nimport json"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#scraping-wikipedia",
    "href": "posts/mathematicians-birthdays-calendar/index.html#scraping-wikipedia",
    "title": "Mathematicians‚Äô Birthdays Calendar",
    "section": "Scraping Wikipedia",
    "text": "Scraping Wikipedia\nWikipedia has, for each day of the year, an entry listing historical events, births, and deaths. We will scrape, for each day in a year, from this list, the births of mathematicians and place them in a dictionary.\nTo see what I mean, let‚Äôs look at the entry for December, the 7th.\n\nEach wikipedia page has a title which is shown here with a red border. If we scroll down we see a list of people who were born on this day. The first mathematician we find is Leopold Kronecker.\n\nScrolling further down, we find three more mathematicians.\nThe idea is to open for each day in the year its corresponding Wikipedia page. Using XPATH expressions, we‚Äôll extract the title of the page and each row in the list of births that contains the word mathematician. Each row, contains the year the mathematician was born (1823), their name (Leopold Kronecker), a one-line bio (Polish-German mathematician and academic (d.¬†1891)), and a URL pointing to a Wikipedia page about the mathematician in question (https://en.wikipedia.org/wiki/Leopold_Kronecker)."
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#building-the-scraper",
    "href": "posts/mathematicians-birthdays-calendar/index.html#building-the-scraper",
    "title": "Mathematicians‚Äô Birthdays Calendar",
    "section": "Building the scraper",
    "text": "Building the scraper\nThere are various ways to scrape using Python. Popular scraping libraries include Scrapy and Beautiful Soup. I usually use Selenium because it allows me to scrape from websites that render HTML from JavaScript. Selenium can be a bit slow, but we‚Äôre only scraping 366 pages so it won‚Äôt take that long.\nIn previous projects I have created some helper classes that allow me to quickly set up a scraping task. These classes can be easily chained together to define a new scraper. I got inspired by scraper tools such as Web scraper and ParseHub that let you compose a tree that specifies how to parse data from a website. Using the classes I defined, we can do something similar in Python.\nAll these helper classes inherit from an abstract base class called BaseSelector.\n\nclass BaseSelector(ABC):\n    @abstractmethod\n    def scrape(self, scraper, parent, **kwargs):\n        pass\n\nClasses that inherit from BaseSelector need to provide an implementation of the scrape method. This method generally scrapes some content from a webpage and returns this wrapped up in a Python dictionary. It may scrape a single DOM element, and return a single dictionary object, or it may scrape multiple elements and return these as a list of dictionaries.\n\nScraping attributes\nThe following class is one of these classes that inherit from BaseSelector. It locates an element(s) and returns a specific attribute of that element, such as the href (in case it matches an anchor link).\n\nclass AttributeSelector(BaseSelector):\n    def __init__(self, id, by, path, attribute, multiple=False, default=None):\n        self.id = id\n        self.by = by\n        self.path = path\n        self.attribute = attribute\n        self.multiple = multiple\n        self.default = default\n\n    def scrape(self, scraper, parent, **kwargs):    \n        if not self.multiple:\n            try:\n                elem = parent.find_element(self.by, self.path.format(**kwargs))\n                return {self.id: elem.get_attribute(self.attribute)}\n            except NoSuchElementException:\n                return self.default\n        else:\n            elems = parent.find_elements(self.by, self.path.format(**kwargs))\n            return [{self.id: elem.get_attribute(self.attribute)} for elem in elems]\n\nLet‚Äôs see how we can use it to scrape the URLs for each mathematicians found on a page (e.g.¬†https://en.m.wikipedia.org/wiki/Leopold_Kronecker).\nWe create a new AttributeSelector as follows.\n\nurls_selector = AttributeSelector(\n    'url', \n    By.XPATH, \n    \"//*[@id='mw-content-text']/div/ul[preceding::h2/span[.='Births'] and following::h2/span[.='Deaths']]/li[contains(., 'mathematician')]/a[string-length(.)&gt;4][1]\", \n    'href', \n    multiple=True\n)\n\nWe provide a key (‚Äòurl‚Äô) for the dictionary object.\nWe also tell it to search for an element addressed by an XPATH expression. In this case we look for list items that contain the string mathematician and find within each list item the first link with a content length of greater than four. We check for length because sometimes it may find multiple links on a single line but the first link always refers to a year (and is therefor at most 4 digits long). Note how we‚Äôre only looking for li elements after a span that contains the text Births, but before a span that contains the word Deaths. XPATH expressions can get a bit unwieldly but they‚Äôre very powerful.\nLinks (a or anchor tags) have an href attribute that we are interested in. We can expect multiple results as there may be multiple mathematicians born on the same day.\nBefore we can call this urls_selector object, we first need to initilize a Selenium webdriver.\ndriver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))\nThis will open a new instance of Google Chrome. Now we can open the webpage we want to scrape from.\ndriver.get(\"https://en.wikipedia.org/wiki/December_7\")\nAnd we get the URLs we‚Äôre interested in.\nurls = urls_selector.scrape(driver, driver)\n\nurls\n\n[{'url': 'https://en.wikipedia.org/wiki/Leopold_Kronecker'},\n {'url': 'https://en.wikipedia.org/wiki/Danilo_BlanuC5%A1a'},\n {'url': 'https://en.wikipedia.org/wiki/Mary_Ellen_Rudin'},\n {'url': 'https://en.wikipedia.org/wiki/Nick_Katz'}]\n\n\n\n\nScraping text\nMost often we are interested in the text that is contained in an element. To scrape simple text we can use the TextSelector class.\n\nclass TextSelector(AttributeSelector):\n    def __init__(self, id, by, path, multiple=False, default=None):\n        super().__init__(id, by, path, 'innerText', multiple, default)\n\nIt extends the AttributeSelector class we defined before. We can use it as follows to get all text of lines that contain the word mathematician.\n\nmathematician_selector = TextSelector(\n    'mathematician', \n    By.XPATH, \n    \"//*[@id='mw-content-text']/div/ul[preceding::h2/span[.='Births'] and following::h2/span[.='Deaths']]/li[contains(., 'mathematician')]\", \n    multiple=True\n)\n\nAgain we use XPATH to address the elements we‚Äôre interested in. This time we don‚Äôt have to check for URL length, so the expression is a bit simpler. Let‚Äôs use it to get each line corresponding to the birth of a mathematician.\nmathematicians = mathematician_selector.scrape(driver, driver)\n\nmathematicians\n\n[{'mathematician': '1823 ‚Äì Leopold Kronecker, Polish-German mathematician and academic (d. 1891)'},\n {'mathematician': '1903 ‚Äì Danilo Blanu≈°a, Croatian mathematician, physicist, and academic (d. 1987)'},\n {'mathematician': '1924 ‚Äì Mary Ellen Rudin, American mathematician (d. 2013)[16]'},\n {'mathematician': '1943 ‚Äì Nick Katz, American mathematician and academic'}]\n\n\nSimilarly we can scrape the month and day from the top of the page.\n\nmonth_day_selector = TextSelector('month_day', By.XPATH, '//*[@id=\"firstHeading\"]/span')\n\nmonth_day = month_day_selector.scrape(driver, driver)\n\nmonth_day\n\n{'month_day': 'December 7'}\n\n\n\n\nCleaning and transforming data\nWe see that the third item in the mathematicians list, contains a reference as indicated by [16]. We want to get rid of this. Furthermore, we also want to split the values for the key mathematician into several keys, such as, year, name, bio.\nThe value month_day contains both the month and day. This is another thing we will want to split up into two seperate keys.\nWe could leave it as is, and do some data cleaning after having scraped all pages. With the approach I‚Äôm taking here, it‚Äôs however quite easy to immediately clean and transform the data while scraping.\nI defined a MapSelector class that let‚Äôs me map a function over scraped data.\n\nclass MapSelector(BaseSelector):\n    def __init__(self, fun, child):\n        self.fun = fun\n        self.child = child\n\n    def scrape(self, scraper, parent, **kwargs):\n        data = self.child.scrape(scraper, parent, **kwargs)\n        if type(data) == dict:\n            return self.fun(data)\n        return list(map(self.fun, data))\n\nThis class doesn‚Äôt do any actual scraping, but is meant to be chained with other selector classes. Let‚Äôs see how it can be used to split up month_day values. We‚Äôll also convert the month name to its number.\n\nsplit_month_day_selector = MapSelector(\n    lambda m: { \n        \"day\": int(m['month_day'].split()[1]), \n        \"month\": list(calendar.month_name).index(m['month_day'].split()[0]) \n    },\n    month_day_selector\n)\n\nNote how I‚Äôm specifying a lambda function to split up month_day into two seperate keys. I‚Äôm passing the month_day_selector we defined above to the constructor as well so the MapSelector knows where to get data from before applying the function.\nsplit_month_day = split_month_day_selector.scrape(driver, driver)\nCalling scrape on the split_month_day_selector object will cause it to call the scrape function on the month_day_selector which does the actual scraping.\n\nsplit_month_day\n\n{'day': 7, 'month': 12}\n\n\nInstead of providing a lambda function, we can use a regular function. Let‚Äôs create a function that cleans and splits up the mathematician key in the mathematicians list.\n\ndef unpack_mathematician_data(m):\n    data = re.sub(r'\\[[^\\]]*\\]', '', m['mathematician']) # remove any references\n    match = re.match(r'^(\\d+)\\s.*‚Äì\\s*(.*?),\\s*(.*?)$', data)\n\n    return {\n        \"year\": int(match.group(1)),\n        \"name\": match.group(2),\n        \"bio\": match.group(3)\n    }\n\n\nsplit_mathematicians_selector = MapSelector(unpack_mathematician_data, mathematician_selector)\n\nsplit_mathematicians = split_mathematicians_selector.scrape(driver, driver)\nNow we have our data in seperate keys.\n\nsplit_mathematicians\n\n[{'year': 1823,\n  'name': 'Leopold Kronecker',\n  'bio': 'Polish-German mathematician and academic (d. 1891)'},\n {'year': 1903,\n  'name': 'Danilo Blanu≈°a',\n  'bio': 'Croatian mathematician, physicist, and academic (d. 1987)'},\n {'year': 1924,\n  'name': 'Mary Ellen Rudin',\n  'bio': 'American mathematician (d. 2013)'},\n {'year': 1943,\n  'name': 'Nick Katz',\n  'bio': 'American mathematician and academic'}]\n\n\n\n\nMerging data\nWe now have selectors that we can call to scrape a list of dictionaries with the year, name, and biography of each mathematician, and a dictionary with the month and day these mathematicians were born. We also defined a selector that scrapes a list of dictionaries of URLs.\nIn order to merge data from different selectors I defined a ZipSelector. If it merges two lists, the dicts in the first list will be extended with the keys and values of the dicts in the second list. It will only return as many items as are contained in the shortest list (similar to Python zip). If a list is merged with a dictionary, the dictionary keys are added to each dictionary in the list. If it merges two dictionaries, it returns a single dictionary containing the keys and values of both dictionaries.\n\nclass ZipSelector(BaseSelector):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n        \n    def scrape(self, scraper, parent, **kwargs):\n        data_left = self.left.scrape(scraper, parent, **kwargs)\n        data_right = self.right.scrape(scraper, parent, **kwargs)\n        \n        if type(data_left) == dict and type(data_right) == dict:\n            return data_left | data_right\n        elif type(data_left) == dict and type(data_right) == list:\n            return [data_left | m for m in data_right]\n        elif type(data_left) == list and type(data_right) == dict:\n            return [m | data_right for m in data_left]\n        return [data_left[i] | data_right[i] for i in range(min(len(data_left),len(data_right)))]\n\nLet‚Äôs see how it works.\n\nzip_month_day_mathematicians_selector = ZipSelector(split_month_day_selector, split_mathematicians_selector)\nzip_month_day_mathematicians_urls_selector = ZipSelector(zip_month_day_mathematicians_selector, urls_selector)\n\nWe first merge the month and day with the year, name, and bio. Then using a second ZipSelector we combine this with url.\nzip_month_day_mathematicians_urls = zip_month_day_mathematicians_urls_selector.scrape(driver, driver)\nIf it wasn‚Äôt clear already: we don‚Äôt need to call the scrape method on each selector object seperately. We are combining selector objects into a tree and just call scrape on the root node and this causes a cascade of calls throughout the tree.\n\nzip_month_day_mathematicians_urls\n\n[{'day': 7,\n  'month': 12,\n  'year': 1823,\n  'name': 'Leopold Kronecker',\n  'bio': 'Polish-German mathematician and academic (d. 1891)',\n  'url': 'https://en.wikipedia.org/wiki/Leopold_Kronecker'},\n {'day': 7,\n  'month': 12,\n  'year': 1903,\n  'name': 'Danilo Blanu≈°a',\n  'bio': 'Croatian mathematician, physicist, and academic (d. 1987)',\n  'url': 'https://en.wikipedia.org/wiki/Danilo_Blanu%C5%A1a'},\n {'day': 7,\n  'month': 12,\n  'year': 1924,\n  'name': 'Mary Ellen Rudin',\n  'bio': 'American mathematician (d. 2013)',\n  'url': 'https://en.wikipedia.org/wiki/Mary_Ellen_Rudin'},\n {'day': 7,\n  'month': 12,\n  'year': 1943,\n  'name': 'Nick Katz',\n  'bio': 'American mathematician and academic',\n  'url': 'https://en.wikipedia.org/wiki/Nick_Katz'}]\n\n\n\n\nNavigating pages\nWe can now call the zip_month_day_mathematicians_urls_selector for each page we want to scrape. This means calling the get method on the driver object to navigate to each page and then repeatedly call the scrape method on the zip_month_day_mathematicians_urls_selector object and concatenate all the results. To do that automatically I‚Äôve created, you guessed it, another class. The URLSelector class takes a list of URLs and opens them one by one each time calling a selector instance to scrape the data. All the data that is scraped is concatenated and eventually returned.\n\nclass URLSelector(BaseSelector):\n    def __init__(self, urls, child):\n        self.urls = urls\n        self.child = child\n        \n    def scrape(self, scraper, parent, **kwargs):\n        result = []\n        \n        for url in self.urls:\n            scraper.get(url.format(**kwargs))\n            data = self.child.scrape(scraper, scraper, **kwargs)\n            \n            if type(data) == dict:\n                result.append(data)\n            elif type(data) == list:\n                result.extend(data)\n            \n        return result\n\nThe constructor takes a list of URLs and a selector class to call for each page.\nWe start by creating a list of all URLs we will scrape from.\n\nmonth_names = calendar.month_name[1:]\ndays_in_month = [calendar.monthrange(2020, month)[1] for month in range(1, 13)]\nmonths_and_days = list(zip(month_names, days_in_month))\n\nwikipedia_urls = [f\"https://en.wikipedia.org/wiki/{month}_{day+1}\" for (month, days) in months_and_days for day in range(days)]\n\nNote how I selected a leap year (2020) to make sure I get 366 URLs. Let‚Äôs show the first five.\n\nwikipedia_urls[:5]\n\n['https://en.wikipedia.org/wiki/January_1',\n 'https://en.wikipedia.org/wiki/January_2',\n 'https://en.wikipedia.org/wiki/January_3',\n 'https://en.wikipedia.org/wiki/January_4',\n 'https://en.wikipedia.org/wiki/January_5']\n\n\nNow we create an instance of URLSelector and pass it this list of URLs and the selector object to call for each page, in this case zip_month_day_mathematicians_urls_selector.\n\nscraper = URLSelector(wikipedia_urls, zip_month_day_mathematicians_urls_selector)\n\nWe build the scraper step by step. Here‚Äôs an overview of how we combined the various classes.\n\n\n\n\n\n\n\nscraper\n\n\n\nus\n\nURLSelector\n\n\n\nzs1\n\nZipSelector\n\n\n\nus-&gt;zs1\n\n\n\n\n\nzs2\n\nZipSelector\n\n\n\nzs1-&gt;zs2\n\n\n\n\n\nas\n\nAttributeSelector\n\n\n\nzs1-&gt;as\n\n\n\n\n\nms1\n\nMapSelector\n\n\n\nzs2-&gt;ms1\n\n\n\n\n\nms2\n\nMapSelector\n\n\n\nzs2-&gt;ms2\n\n\n\n\n\nts1\n\nTextSelector\n\n\n\nms1-&gt;ts1\n\n\n\n\n\nts2\n\nTextSelector\n\n\n\nms2-&gt;ts2\n\n\n\n\n\n\n\n\n\n\nThe direction of the arrows indicate the direction of the cascade of calls. The data flows in the opposite direction.\nOnly TextSelector and AttributeSelector do any actual scraping. URLSelector navigates to each URL. The other selector classes merge or transform the data. In other scraping projects I might use custom selector classes that take care of pagination or filling forms and pressing buttons."
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#running-the-scraper",
    "href": "posts/mathematicians-birthdays-calendar/index.html#running-the-scraper",
    "title": "Mathematicians‚Äô Birthdays Calendar",
    "section": "Running the scraper",
    "text": "Running the scraper\nCalling the scrape method will scrape all mathematicians‚Äô birthdays.\ndata = scraper.scrape(driver, driver)\nLet‚Äôs looks at the first five results.\n\ndata[:5]\n\n[{'day': 1,\n  'month': 1,\n  'year': 1878,\n  'name': 'Agner Krarup Erlang',\n  'bio': 'Danish mathematician, statistician, and engineer (d. 1929)',\n  'url': 'https://en.wikipedia.org/wiki/Agner_Krarup_Erlang'},\n {'day': 1,\n  'month': 1,\n  'year': 1894,\n  'name': 'Satyendra Nath Bose',\n  'bio': 'Indian physicist and mathematician (d. 1974)',\n  'url': 'https://en.wikipedia.org/wiki/Satyendra_Nath_Bose'},\n {'day': 1,\n  'month': 1,\n  'year': 1905,\n  'name': 'Stanis≈Çaw Mazur',\n  'bio': 'Ukrainian-Polish mathematician and theorist (d. 1981)',\n  'url': 'https://en.wikipedia.org/wiki/Stanis%C5%82aw_Mazur'},\n {'day': 1,\n  'month': 1,\n  'year': 1912,\n  'name': 'Boris Vladimirovich Gnedenko',\n  'bio': 'Russian mathematician and historian (d. 1995)',\n  'url': 'https://en.wikipedia.org/wiki/Boris_Vladimirovich_Gnedenko'},\n {'day': 2,\n  'month': 1,\n  'year': 1803,\n  'name': 'Guglielmo Libri Carucci dalla Sommaja',\n  'bio': 'Italian mathematician and academic (d. 1869)',\n  'url': 'https://en.wikipedia.org/wiki/Guglielmo_Libri_Carucci_dalla_Sommaja'}]\n\n\nWe can save the result as a JSON file.\n# Save to a JSON file\nwith open('data.json', 'w') as json_file:\n    json.dump(data, json_file)\nOr convert it to a dataframe and save it as CSV.\n\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nday\nmonth\nyear\nname\nbio\nurl\n\n\n\n\n0\n1\n1\n1878\nAgner Krarup Erlang\nDanish mathematician, statistician, and engine...\nhttps://en.wikipedia.org/wiki/Agner_Krarup_Erlang\n\n\n1\n1\n1\n1894\nSatyendra Nath Bose\nIndian physicist and mathematician (d. 1974)\nhttps://en.wikipedia.org/wiki/Satyendra_Nath_Bose\n\n\n2\n1\n1\n1905\nStanis≈Çaw Mazur\nUkrainian-Polish mathematician and theorist (d...\nhttps://en.wikipedia.org/wiki/Stanis%C5%82aw_M...\n\n\n3\n1\n1\n1912\nBoris Vladimirovich Gnedenko\nRussian mathematician and historian (d. 1995)\nhttps://en.wikipedia.org/wiki/Boris_Vladimirov...\n\n\n4\n2\n1\n1803\nGuglielmo Libri Carucci dalla Sommaja\nItalian mathematician and academic (d. 1869)\nhttps://en.wikipedia.org/wiki/Guglielmo_Libri_...\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n833\n28\n12\n1950\nClifford Cocks\nEnglish mathematician and cryptographer\nhttps://en.wikipedia.org/wiki/Clifford_Cocks\n\n\n834\n29\n12\n1856\nThomas Joannes Stieltjes\nDutch-French mathematician and academic (d. 1894)\nhttps://en.wikipedia.org/wiki/Thomas_Joannes_S...\n\n\n835\n30\n12\n1944\nJoseph Hilbe\nAmerican mathematician and philosopher (d. 2017)\nhttps://en.wikipedia.org/wiki/Joseph_Hilbe\n\n\n836\n31\n12\n1714\nArima Yoriyuki\nJapanese mathematician and educator (d. 1783)\nhttps://en.wikipedia.org/wiki/Arima_Yoriyuki\n\n\n837\n31\n12\n1952\nVaughan Jones\nNew Zealand mathematician and academic (d. 2020)\nhttps://en.wikipedia.org/wiki/Vaughan_Jones\n\n\n\n\n838 rows √ó 6 columns\n\n\n\n\ndf.to_csv('data.csv', index=False)"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#creating-the-calendar",
    "href": "posts/mathematicians-birthdays-calendar/index.html#creating-the-calendar",
    "title": "Mathematicians‚Äô Birthdays Calendar",
    "section": "Creating the calendar",
    "text": "Creating the calendar\nWe‚Äôre now ready to convert this data into an ICS calendar file so it can be imported into a calendar application, like Google Calendar or Microsoft Outlook.\n\n# Create the calendar\ncal = Calendar()\n\n# Iterate through the birthday data and add recurring events to the calendar\nfor person in data:\n    name = person['name']\n    birthdate = date(person['year'], person['month'], person['day'])\n    bio = person['bio']\n    url = person['url']\n\n    # Create an event for the birthday with recurrence rule\n    event = Event()\n    event.add('summary', f\"{name}'s birthday\")\n    event.add('description', f\"{name} - {bio}\\n\\n{url}\")\n    event.add('dtstart', birthdate)\n    event.add('rrule', {'freq': 'yearly'})\n    event.add('url', url)\n    event.add('transp', 'TRANSPARENT') # Make events not show up as 'busy'\n\n    cal.add_component(event)\n\n# Save the calendar to a file\nwith open('mathematicians_birthdays_calendar.ics', 'wb') as ics_file:\n    ics_file.write(cal.to_ical())\n\nThe file is saved as mathematicians_birthdays_calendar.ics and ready to be imported into your calendar."
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#importing-the-calendar",
    "href": "posts/mathematicians-birthdays-calendar/index.html#importing-the-calendar",
    "title": "Mathematicians‚Äô Birthdays Calendar",
    "section": "Importing the calendar",
    "text": "Importing the calendar\nHere‚Äôs how to add the ICS calendar to Google Calendar:\n\nOpen Google Calendar: Open your Google Calendar in a web browser. Ensure that you are logged in with the Google account you want to associate with the birthday calendar.\nNavigate to ‚ÄúSettings‚Äù: In the top-right corner, click on the gear icon to access the settings menu. From the dropdown, select ‚ÄúSettings.‚Äù\nChoose ‚ÄúAdd Calendar‚Äù: In the settings menu, navigate to the ‚ÄúAdd calendar‚Äù section.\nSelect ‚ÄúFrom URL‚Äù: Within the ‚ÄúAdd calendar‚Äù section, choose the ‚ÄúFrom URL‚Äù option.\nEnter ICS Calendar URL: Copy and paste the following URL: https://www.aswinvanwoudenberg.com/posts/mathematicians-birthdays-calendar/mathematicians_birthdays_calendar.ics\nClick ‚ÄúAdd Calendar‚Äù: After entering the URL, click the ‚ÄúAdd Calendar‚Äù button. Google Calendar will validate the URL and add the calendar to your account.\nView Your New Calendar: Once added, you should see the new calendar in the left sidebar under ‚ÄúOther calendars.‚Äù The birthdays will be displayed on your Google Calendar.\n\n\nClicking on an event will show some details including a link to a Wikipedia page to learn more about the mathematician.\n\nEnjoy all the cake!"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#isaac-newtons-two-birthdays",
    "href": "posts/mathematicians-birthdays-calendar/index.html#isaac-newtons-two-birthdays",
    "title": "Mathematicians‚Äô Birthdays Calendar",
    "section": "Isaac Newton‚Äôs two birthdays",
    "text": "Isaac Newton‚Äôs two birthdays\nYou may have noticed, after viewing this calendar, that Isaac Newton seemingly has two birthdays, ten days apart. Initially recognized as born on December 25, 1642, his birthday is now more commonly acknowledged as January 4, 1643. This is due to the calendar difference between England and the rest of Europe during his birth. While England stuck to the Julian calendar, lagging ten days behind, the continent had already adopted the Gregorian calendar.\nWhile January 4 is now widely acknowledged as Isaac Newton‚Äôs birthday, December 25 continues to be celebrated as Grav-Mass day. This unofficial holiday annually honors Newton‚Äôs contributions to the understanding of gravity and mass in physics.\nI left both days in the calendar because it means I get to eat even more cake!"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#download-the-code",
    "href": "posts/mathematicians-birthdays-calendar/index.html#download-the-code",
    "title": "Mathematicians‚Äô Birthdays Calendar",
    "section": "Download the code",
    "text": "Download the code\nYou can find the code here."
  },
  {
    "objectID": "posts/dancing-queens/index.html",
    "href": "posts/dancing-queens/index.html",
    "title": "Dancing Queen(s)",
    "section": "",
    "text": "The n-queens problem is a puzzle that involves placing n queens on an n x n chessboard such that no two queens threaten each other. A queen can threaten another queen if they are in the same row, column, or diagonal. The objective is to find all possible ways to place n queens on the chessboard without any of them threatening each other.\nIn this post, we‚Äôll explore how to solve the n-queens problem using Python and visualize solutions using Matplotlib. We‚Äôll also see how to turn all solutions into an animation."
  },
  {
    "objectID": "posts/dancing-queens/index.html#importing-libraries",
    "href": "posts/dancing-queens/index.html#importing-libraries",
    "title": "Dancing Queen(s)",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing the necessary libraries. The Matplotlib library will be used to display the chessboard and queens.\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation\n\nfrom IPython.display import HTML\nfrom ipywidgets import widgets"
  },
  {
    "objectID": "posts/dancing-queens/index.html#the-solver",
    "href": "posts/dancing-queens/index.html#the-solver",
    "title": "Dancing Queen(s)",
    "section": "The solver",
    "text": "The solver\nThe code for the solver itself, consists of three functions: is_valid(), solve_n_queens_(), and solve_n_queens().\nThe is_valid() function takes three parameters: a board, a row, and a column. It checks if a queen can be placed at the given row and column on the board without attacking any other queen on the board. The function does this by iterating through each row before the current row and checking if a queen in that row attacks the given position.\nHere‚Äôs what the code for is_valid() looks like:\n\ndef is_valid(board, row, col):\n    for i in range(row):\n        if board[i] == col or row - i == abs(col - board[i]):\n            return False\n    return True\n\nThe solve_n_queens_() function takes two parameters: a board and a row. It solves the n-queens problem recursively by placing a queen at each row one by one. At each row, it checks if a queen can be placed at any of the columns on that row without attacking any other queen on the board. If a valid position is found, the function calls itself with the updated board and the next row. If no valid position is found, it backtracks to the previous row and tries the next column.\nThis is the code for solve_n_queens_():\n\ndef solve_n_queens_(board, row):\n    if row == len(board):\n        yield list(board)\n    else:\n        for col in range(len(board)):\n            if is_valid(board, row, col):\n                board[row] = col\n                yield from solve_n_queens_(board, row + 1)\n                board[row] = -1\n\nFinally, the solve_n_queens() function calls solve_n_queens_() with an empty board:\n\ndef solve_n_queens(n):\n    board = [-1] * n\n    yield from solve_n_queens_(board, 0)\n\nIn the three functions above, the board variable is a list that represents the chessboard. The board is initialized as a list of -1‚Äôs with a length of n. Each element in the list represents a column on the board, and the index of the element represents a row on the board. When a queen is placed on the board, its position is marked by setting the corresponding element in the board list to the column number of that queen.\nFor example, let‚Äôs say we have a 4x4 chessboard, and we place a queen at row 0 and column 1. We would represent this by setting board[0] = 1. The is_valid() function then checks if a queen can be placed at the given row and column on the board list without attacking any other queen on the board. If a valid position is found, the solve_n_queens_() function continues to the next row and updates the board list accordingly.\nIn case you didn‚Äôt know, the yield keyword turns the function into a generator that yields values as they are computed, rather than generating them all at once and returning them as a list or other collection. This makes it possible to produce each valid solution as it is found, rather than waiting until all solutions have been found and returning them all at once."
  },
  {
    "objectID": "posts/dancing-queens/index.html#function-to-display-a-solution",
    "href": "posts/dancing-queens/index.html#function-to-display-a-solution",
    "title": "Dancing Queen(s)",
    "section": "Function to display a solution",
    "text": "Function to display a solution\nThe following function takes an n-queens solution and an ax object as inputs and plots the solution on the given axes.\n\ndef plot_n_queens_solution(solution, ax):\n    # Define the colors of the squares\n    light_color = \"#F0D9B5\"\n    dark_color = \"#B58863\"\n\n    board_size = len(solution)\n    \n    # Draw the squares\n    for i in range(board_size):\n        for j in range(board_size):\n            if (i + j) % 2 == 0:\n                color = light_color\n            else:\n                color = dark_color\n            ax.add_patch(plt.Rectangle((i, j), 1, 1, color=color))\n\n    # Draw the pieces on the board\n    for y, x in enumerate(solution):\n        ax.text(x+0.5, y+0.5, \"‚ôõ\", ha=\"center\", va=\"center\", fontsize=240/board_size, color=\"black\")\n\n    # Set the aspect ratio to \"equal\"\n    ax.set_aspect('equal')\n\n    # Set the x and y limits to show the whole board\n    ax.set_xlim(0, board_size)\n    ax.set_ylim(0, board_size)\n\n    # Remove the tick labels\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    # Flip the y-axis\n    ax.invert_yaxis()"
  },
  {
    "objectID": "posts/dancing-queens/index.html#display-all-solutions",
    "href": "posts/dancing-queens/index.html#display-all-solutions",
    "title": "Dancing Queen(s)",
    "section": "Display all solutions",
    "text": "Display all solutions\nNow, let‚Äôs combine the solver with the code that displays a solution.\n\ndef plot_all_n_queens_solutions(board_size):\n    for solution in solve_n_queens(board_size):\n        fig, ax = plt.subplots()\n        plot_n_queens_solution(solution, ax)\n        plt.show()\n\nThis function uses the solve_n_queens function to generate all valid solutions to the n-queens puzzle of size board_size. It then loops over each solution, creating a new plot for each one using the plt.subplots() function, and then calling the plot_n_queens_solution function to plot the solution onto the plot. Finally, the plot is displayed using plt.show(). This process is repeated for each solution, resulting in all valid solutions being displayed as individual plots.\nNow, let‚Äôs call this function to generate and display all valid solutions to the n-queens puzzle of size 4.\n\nplot_all_n_queens_solutions(4)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this case we find only two valid solution."
  },
  {
    "objectID": "posts/dancing-queens/index.html#show-solutions-one-by-one",
    "href": "posts/dancing-queens/index.html#show-solutions-one-by-one",
    "title": "Dancing Queen(s)",
    "section": "Show solutions one by one",
    "text": "Show solutions one by one\nIf the board size is larger, plotting all possible solutions would take up a lot of space. To address this issue, the following code generates widgets that enable you to choose a board size and iterate through the solutions.\nWe start by creating a user interface with a dropdown menu, a button, an output widget, and a label widget using the Python widgets module.\n\nboard_size_dropdown = widgets.Dropdown(options=list(range(1,21)), value=8, description=\"Board size: \")\nnext_button = widgets.Button(description=\"Next\")\nhbox = widgets.HBox([board_size_dropdown, next_button])\noutput = widgets.Output()\nlabel = widgets.Label()\n\ndisplay(hbox, output, label)\n\n\n\n\n\n\n\n\n\n\nWe declare the following global variables:\n\ngen = None\nsolution = None\n\nThe gen is a generator object that generates solutions for a given board size using the solve_n_queens function. The solution variable stores the next solution to be displayed in the output widget. It is updated each time the ‚ÄúNext‚Äù button is clicked to display the next solution in the generator.\n\ndef on_board_size_dropdown_change(change):\n    global gen\n    global solution\n    \n    if change['type'] == 'change' and change['name'] == 'value':\n        value = change['new']\n        next_button.layout.display = 'none'\n        \n        output.clear_output()\n        \n        gen = solve_n_queens(value)\n        try:\n            solution = next(gen)            \n            with output:\n                fig, ax = plt.subplots()\n                plot_n_queens_solution(solution, ax)\n                plt.show()\n        except StopIteration:\n            label.value = \"No solutions found.\"\n            return\n\n        try:\n            solution = next(gen).copy()\n            label.value = \"\"\n            next_button.layout.display = 'inline-block'\n        except StopIteration:\n            label.value = \"\"\n\nboard_size_dropdown.observe(on_board_size_dropdown_change)\n\nThe on_board_size_dropdown_change function handles changes to the board size dropdown menu. It clears the output widget, displays the first solution (if any), and stores the next solution in the solution variable (if any).\n\ndef on_next_button_clicked(b):\n    global gen\n    global solution\n    \n    output.clear_output(wait=True)\n    with output:\n        fig, ax = plt.subplots()\n        plot_n_queens_solution(solution, ax)\n        plt.show()\n    \n    try:\n        solution = next(gen)\n    except StopIteration:\n        label.value = \"\"\n        next_button.layout.display = 'none'\n\nnext_button.on_click(on_next_button_clicked)\n\non_board_size_dropdown_change({'type': 'change', 'name': 'value', 'new': board_size_dropdown.value})\n\nThe on_next_button_clicked function handles clicks on the ‚ÄúNext‚Äù button by clearing the output widget, displaying the current solution, and generating the next solution."
  },
  {
    "objectID": "posts/dancing-queens/index.html#create-a-matplotlib-animation-that-shows-all-solutions",
    "href": "posts/dancing-queens/index.html#create-a-matplotlib-animation-that-shows-all-solutions",
    "title": "Dancing Queen(s)",
    "section": "Create a Matplotlib animation that shows all solutions",
    "text": "Create a Matplotlib animation that shows all solutions\nAnother thing we can do is animate all solutions. We first set up the necessary functions and objects for later use in creating an animation.\n\nfig, ax = plt.subplots()\n\ndef gen_func(n):\n    def generator():\n        yield from solve_n_queens(n)\n    return generator\n\ndef animate(solution):\n    ax.clear()\n    plot_n_queens_solution(solution, ax)\n\nplt.close()\n\nWe can then create an animation of the n-queens problem using the matplotlib.animation module and display it.\n\nboard_size = 8\n\nanim = matplotlib.animation.FuncAnimation(fig, animate, frames=gen_func(board_size), save_count=999999999999)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nTo fully enjoy the animation, it is recommended to listen to ABBA‚Äôs song Dancing Queen in the background.\nI originally created this code to teach my students about the concept of backtracking. I hope it will be helpful for you as well.\nUse one of the following links to play with an interactive version:"
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html",
    "href": "posts/from-procrastination-to-productivity/index.html",
    "title": "From Procrastination to Productivity",
    "section": "",
    "text": "We‚Äôve all been there - you sit down at your computer with the intention of getting work done, but suddenly find yourself lost in a rabbit hole of endless browsing. But what exactly are you doing when you‚Äôre procrastinating online?\nI decided to look into my own browser history to get better insight into my browsing behavior and hopefully build better habits.\nChrome, which is the browser I use, stores its history (like most browsers) in an SQLite database. This database can be queried from Python using the sqlite3 package. I use pandas for data manipulation and matplotlib and wordcloud to create visualizations.\nI wanted to answer questions, such as:\nRead on if you want to see my embarrasing browsing habits being visualized or want to learn how to analyze your own data."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#importing-libraries",
    "href": "posts/from-procrastination-to-productivity/index.html#importing-libraries",
    "title": "From Procrastination to Productivity",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe‚Äôll start by importing sqlite3, pandas, matplotlib and some other packages.\n\nimport os\nimport sqlite3\nimport time\nimport datetime\nimport tzlocal\nimport math\nimport calendar\n\nimport pandas as pd\nimport numpy as np\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FixedLocator, MaxNLocator\n%matplotlib inline\n\nfrom IPython.display import display, HTML\nfrom urllib.parse import urlparse\nfrom pathlib import Path\nfrom wordcloud import WordCloud\nfrom ipywidgets import interact"
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#reading-database-tables",
    "href": "posts/from-procrastination-to-productivity/index.html#reading-database-tables",
    "title": "From Procrastination to Productivity",
    "section": "Reading database tables",
    "text": "Reading database tables\nOn Linux, the Chrome history database is stored in the ~/.config/google-chrome/Default/History file. If you‚Äôre on a different OS, or are using multiple profiles, you will have to update this path.\ndb_path = os.path.expanduser(\"~/.config/google-chrome/Default/History\")\nWe connect to this database using the sqlite3 driver. To open this file read-only, immutable needs to be set to 1. This not only prevents accidental changes, but also allows reading the database file when it‚Äôs locked by the Chrome browser.\n\ncon = sqlite3.connect(f\"file:{db_path}?immutable=1\", uri=True)\n\nLet‚Äôs look at what tables are stored in this database file.\n\n(pd.read_sql_query(\"SELECT name FROM sqlite_master WHERE type='table';\", con)\n    .sort_values('name')\n    .style.hide(axis='index'))\n\n\n\n\n\n\nname\n\n\n\n\ncluster_keywords\n\n\ncluster_visit_duplicates\n\n\nclusters\n\n\nclusters_and_visits\n\n\ncontent_annotations\n\n\ncontext_annotations\n\n\ndownloads\n\n\ndownloads_slices\n\n\ndownloads_url_chains\n\n\nhistory_sync_metadata\n\n\nkeyword_search_terms\n\n\nmeta\n\n\nsegment_usage\n\n\nsegments\n\n\nsqlite_sequence\n\n\ntyped_url_sync_metadata\n\n\nurls\n\n\nvisit_source\n\n\nvisits\n\n\n\n\n\nWe‚Äôll read in tables using Pandas and explore their contents. There are quite a few tables, but I‚Äôll only focus on a few of them.\n\ndownloads = pd.read_sql_query(\"SELECT * FROM downloads;\", con)\nkeyword_search_terms = pd.read_sql_query(\"SELECT * FROM keyword_search_terms;\", con)\nurls = pd.read_sql_query(\"SELECT * FROM urls;\", con)\nvisits = pd.read_sql_query(\"SELECT * FROM visits;\", con)\n\nAfter reading in the data we can close the database connection.\n\ncon.close()\n\nThere‚Äôs a limit to how much history is saved to these tables. We won‚Äôt be able to go years back unless we periodically backup the database. I won‚Äôt do that in this post though."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#common-search-terms",
    "href": "posts/from-procrastination-to-productivity/index.html#common-search-terms",
    "title": "From Procrastination to Productivity",
    "section": "Common search terms",
    "text": "Common search terms\nA browser session often starts with a (Google) search. Let‚Äôs visualize what common search terms I am using. I‚Äôll do this using a word cloud.\nThe Chrome history database contains a keyword_search_terms table that records keywords that have been entered into search boxes. It has the following structure:\n\nkeyword_search_terms.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 4832 entries, 0 to 4831\nData columns (total 4 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   keyword_id       4832 non-null   int64 \n 1   url_id           4832 non-null   int64 \n 2   term             4832 non-null   object\n 3   normalized_term  4832 non-null   object\ndtypes: int64(2), object(2)\nmemory usage: 151.1+ KB\n\n\nThe url_id is a foreign key that links to records in the urls table. The urls table has the following structure:\n\nurls.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 11645 entries, 0 to 11644\nData columns (total 7 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   id               11645 non-null  int64 \n 1   url              11645 non-null  object\n 2   title            11645 non-null  object\n 3   visit_count      11645 non-null  int64 \n 4   typed_count      11645 non-null  int64 \n 5   last_visit_time  11645 non-null  int64 \n 6   hidden           11645 non-null  int64 \ndtypes: int64(5), object(2)\nmemory usage: 637.0+ KB\n\n\nThe urls table contains the actual URL and some other attributes. We could join the keyword_search_terms and urls tables using SQL, but here I‚Äôll use Pandas‚Äô merge method instead.\n\nkeyword_search_terms_urls = pd.merge(left=keyword_search_terms, right=urls, left_on='url_id', right_on='id')\n\nI want to be able to visualize what search terms I use per search box seperately. So I want to see which keywords I entered on Google, which ones I entered on YouTube, which ones on Bing, etc. I order to do this I‚Äôll extract the network location from the URL. This becomes a new column in the dataframe called netloc.\n\nkeyword_search_terms_urls['netloc'] = keyword_search_terms_urls.url.map(lambda r: urlparse(r).netloc)\n\nI‚Äôll use an dropdown widget to select the website I searched on and plot the word cloud.\n@interact(netloc=widgets.Dropdown(options=keyword_search_terms_urls.netloc.unique(), description='Website:'))\ndef search_wordcloud(netloc):\n    # Join all keywords into one lengthy string\n    keywords = ' '.join(keyword_search_terms_urls.query('netloc == @netloc').normalized_term)\n    width, height = 1200, 600 # Size of the word cloud\n    \n    px = 1/plt.rcParams['figure.dpi']  # pixel in inches    \n    fig, ax = plt.subplots(figsize=(width*px, height*px), subplot_kw={'xticks': [], 'yticks': []})\n\n    wordcloud = WordCloud(background_color=\"white\", width=width, height=height).generate_from_text(keywords)\n    ax.set_title(netloc)\n    ax.imshow(wordcloud, interpolation='bilinear', aspect='auto')\n    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nMost searches, at least the ones on Google seem to be data science related. I recently hiked the Great Glen Way in Scotland so you can see some searches related to that."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#most-visited-websites",
    "href": "posts/from-procrastination-to-productivity/index.html#most-visited-websites",
    "title": "From Procrastination to Productivity",
    "section": "Most visited websites",
    "text": "Most visited websites\nLet‚Äôs see what websites I visit most. I‚Äôll look at both how much time I spend on these websites and how frequently I visit them.\n\nMost visited websites by time spent\nThe visits table has the following structure:\n\nvisits.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 23181 entries, 0 to 23180\nData columns (total 15 columns):\n #   Column                           Non-Null Count  Dtype \n---  ------                           --------------  ----- \n 0   id                               23181 non-null  int64 \n 1   url                              23181 non-null  int64 \n 2   visit_time                       23181 non-null  int64 \n 3   from_visit                       23181 non-null  int64 \n 4   transition                       23181 non-null  int64 \n 5   segment_id                       23181 non-null  int64 \n 6   visit_duration                   23181 non-null  int64 \n 7   incremented_omnibox_typed_score  23181 non-null  int64 \n 8   opener_visit                     23181 non-null  int64 \n 9   originator_cache_guid            23181 non-null  object\n 10  originator_visit_id              23181 non-null  int64 \n 11  originator_from_visit            23181 non-null  int64 \n 12  originator_opener_visit          23181 non-null  int64 \n 13  is_known_to_sync                 23181 non-null  int64 \n 14  consider_for_ntp_most_visited    23181 non-null  int64 \ndtypes: int64(14), object(1)\nmemory usage: 2.7+ MB\n\n\nThe visit_duration holds how much time is spent on a specific URL in microseconds. The url column is a foreign key that again points to the urls table which contains the actual URL. Let‚Äôs join the two tables together.\n\nvisits_urls = pd.merge(left=visits, right=urls, left_on='url', right_on='id')\n\nColumns with duplicate names get appended with _x or _y. Because we end up with a url_x and an id_y column that both refer to the same value we can drop one of them.\n\nvisits_urls = visits_urls.drop(labels='url_x', axis=1)\n\nWe rename some columns to make it clear what attribute they represent.\n\nvisits_urls = visits_urls.rename(columns={'id_x': 'visit_id', 'id_y': 'url_id', 'url_y': 'url'})\n\nWe want to group by network location so we need to get this from the URL again like we did above.\n\nvisits_urls['netloc'] = visits_urls.url.map(lambda r: urlparse(r).netloc)\n\nI want to be able to filter by date range. We can use the visit_time column for that. This column contains WebKit/Chrome timestamps which we need to convert to human-readable date & Unix time. This timestamp format is used in web browsers such as Apple Safari (WebKit), Google Chrome and Opera (Chromium/Blink). It uses a 64-bit value for microseconds since Jan 1, 1601 00:00 UTC. I use a helper function to take care of the conversion.\n\ndef date_from_webkit(webkit_timestamp):\n    epoch_start = datetime.datetime(1601,1,1)\n    delta = datetime.timedelta(microseconds=int(webkit_timestamp))\n    return epoch_start + delta\n\n\nvisits_urls['visit_time_dt'] = pd.to_datetime(visits_urls.visit_time.map(date_from_webkit), utc=True).dt.tz_convert(tzlocal.get_localzone().key)\n\nI use a slider to select a date range and on each update the bar chart will redraw.\n\nstart_date = visits_urls['visit_time_dt'].min().date()\nend_date = visits_urls['visit_time_dt'].max().date()\n\ndates = pd.date_range(start_date, end_date, freq='D')\n\ndate_options = [(date.strftime('%d %b %Y'), date) for date in dates]\nindex = (0, len(date_options)-1)\n\n@interact(date_range=widgets.SelectionRangeSlider(options=date_options, index=index, description='Date range:', orientation='horizontal', layout={'width': '500px'}))\ndef plot_time_spent(date_range):\n    fig, ax = plt.subplots(figsize=(10,8))\n\n    tz = tzlocal.get_localzone().key\n    start_dt = pd.to_datetime(date_range[0]).tz_localize(tz)\n    end_dt = pd.to_datetime(date_range[1]).tz_localize(tz) + pd.Timedelta(days=1)\n    \n    top_visits_urls = visits_urls.query(\"visit_time_dt &gt;= @start_dt and visit_time_dt &lt; @end_dt\").groupby('netloc').visit_duration.sum()\n    top_visits_urls.sort_values().tail(20).plot(kind='barh', ax=ax, ylabel='', title=\"Top 20 websites most time spent on\")\n    \n    td = pd.to_timedelta(top_visits_urls.max(), unit='us')\n    for unit, n in td.components._asdict().items():\n        if n &gt; 0:\n            break\n    ticks_loc = [int(pd.to_timedelta(x, unit=unit) / pd.to_timedelta(1, unit='us')) for x in range(0, n+2, math.ceil((n+2)/5))]\n    \n    ax.xaxis.set_major_locator(FixedLocator(ticks_loc))\n    ax.set_xticklabels([\"{} {}\".format(pd.to_timedelta(x, unit='us').components._asdict()[unit], unit) for x in ticks_loc])\n    \n    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nOverall I spend a lot of time on websites related to data science and software development. So that‚Äôs good. Most time is spent on Spotify, but that‚Äôs just because I always have a tab open to listen to music while I work (or procrastinate). I seem to waste a lot of time on YouTube but let‚Äôs pretend for now I‚Äôm mostly watching educational videos. The localhost:8888 is my local instance of Jupyter Lab and you can see I run another local development server on localhost.\n\n\nMost visited websites by frequency\nNow let‚Äôs produce a similar graph but this time based on how frequently I visit certain websites. I‚Äôll use a slider again to be able to select date ranges.\n@interact(date_range=widgets.SelectionRangeSlider(options=date_options, index=index, description='Date range:', orientation='horizontal', layout={'width': '500px'}))\ndef plot_frequency(date_range):\n    fig, ax = plt.subplots(figsize=(10,8))\n\n    tz = tzlocal.get_localzone().key\n    start_dt = pd.to_datetime(date_range[0]).tz_localize(tz)\n    end_dt = pd.to_datetime(date_range[1]).tz_localize(tz) + pd.Timedelta(days=1)\n    \n    (visits_urls.query(\"visit_time_dt &gt;= @start_dt and visit_time_dt &lt; @end_dt\")\n         .groupby('netloc').size().sort_values().tail(20)\n         .plot(kind='barh', ax=ax, ylabel='', title=\"Top 20 most frequently visited websites\"))\n    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nThis doesn‚Äôt look as flattering clearly.\nIt appears that I‚Äôm constantly checking Facebook, Instagram and the toxic cesspool that is Twitter, excuse me, ùïè. I frequently visit the Dutch news website NOS to see if the world has fallen apart already. I also check the IMDB website quite often to see if there‚Äôs anything good to watch.\nI think some websites only make me feel annoyed and cynical, like Twitter and NOS, which then drives me to visit websites like IMDB in an attempt to search for movies or series to distract myself.\nI removed social media apps from my phone years ago but as you can tell from the chart above, I still visit the mobile website version of Facebook (m.facebook.com) way too often.\nI‚Äôm happy that in absolute time I don‚Äôt seem to waste too much time on social media but the frequency with which I visit those sites is definitely problematic. Most of it is mindless doomscrolling. Only occasionally I get a small dopamine hit when I see a cute cat video or someone likes one of my travel photos and I feel validated."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#youtube-videos",
    "href": "posts/from-procrastination-to-productivity/index.html#youtube-videos",
    "title": "From Procrastination to Productivity",
    "section": "YouTube videos",
    "text": "YouTube videos\nI seem to visit YouTube a lot both in frequency and time. What kind of stuff am I watching though? I‚Äôll use a date picker to select a date and use a dropdown box to select if I want to see the YouTube videos or shorts I watched that day. I‚Äôll make the links clickable.\n\ndef make_clickable(url, name):\n    return '&lt;a href=\"{}\" rel=\"noopener noreferrer\" target=\"_blank\"&gt;{}&lt;/a&gt;'.format(url, name)\n\n\n@interact(date=widgets.DatePicker(description='Date: ', disabled=False, value=end_date), \n          content_type=widgets.Dropdown(\n              options=[(\"Videos\", \"youtube.com/watch\"), \n                       (\"Shorts\", \"youtube.com/shorts\")], \n              value=\"youtube.com/watch\", description='Type:'))\ndef show_watched_videos(date, content_type):    \n    tz = tzlocal.get_localzone().key\n    start_dt = pd.to_datetime(date).tz_localize(tz)\n    end_dt = start_dt + pd.Timedelta(days=1)\n    \n    df = visits_urls.query(\"url.str.contains(@content_type) and visit_time_dt &gt;= @start_dt and visit_time_dt &lt; @end_dt\").copy()\n    df['YouTube video'] = df.apply(lambda x: make_clickable(x['url'], x['title']), axis=1)\n    if df.size:\n        display(df[['YouTube video']].style.hide(axis='index'))\n    else:\n        print(\"No YouTube URLs found for this type of content.\")\n\n\n\n\nThe stuff I watch is mostly related to music, science and AI/ML. I really appreciate good craftsmanship and there are some makers I follow. The frequency of my visits to YouTube is for the most part due to wanting to see if something new has been released."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#when-am-i-most-active",
    "href": "posts/from-procrastination-to-productivity/index.html#when-am-i-most-active",
    "title": "From Procrastination to Productivity",
    "section": "When am I most active?",
    "text": "When am I most active?\nLet‚Äôs see around what time I am most active online. I use Pandas conditional formatting to hightlight my most active hours each day of the week. A dropdown box is used to select the week.\n\ndates = pd.date_range(start_date, end_date, freq='W-MON')\noptions = [(\"{} - {}\".format(date.strftime('%d %b %Y'), (date + pd.Timedelta(days=7)).strftime('%d %b %Y')), (date, date + pd.Timedelta(days=7))) for date in dates]\noptions.insert(0, ('All weeks', (pd.to_datetime(start_date), pd.to_datetime(end_date))))\n\n\n@interact(date_range=widgets.Dropdown(options=options, description='Week:'))\ndef plot_activity(date_range):\n    tz = tzlocal.get_localzone().key\n    start_dt = pd.to_datetime(date_range[0]).tz_localize(tz)\n    end_dt = pd.to_datetime(date_range[1]).tz_localize(tz) + pd.Timedelta(days=1)\n        \n    df = (visits_urls.query(\"visit_time_dt &gt;= @start_dt and visit_time_dt &lt; @end_dt\")\n        .groupby([visits_urls.visit_time_dt.dt.day_of_week, visits_urls.visit_time_dt.dt.hour])\n        .size().unstack().reset_index(drop=True)\n        .reindex(list(range(0,7)), fill_value=0)\n        .reindex(list(range(0,24)), axis='columns', fill_value=0)\n    )\n    vmax = df.max(axis=None)\n    df.columns.name = None\n    display(df.rename(mapper=lambda x: list(calendar.day_name)[x])\n        .rename(columns=lambda y: str(y if y else 12) + \" am\" if y &lt; 12 else str(y if y==12 else y-12) + \" pm\")\n        .style.format(na_rep=0, precision=0).background_gradient(cmap='Blues', vmin=0, vmax=vmax)\n        .applymap(lambda x: 'background-color: white; color: black;' if pd.isnull(x) or x==0 else '')\n    )\n\n\n\n\nIt‚Äôs interesting to look at my browser usage by week, but by taking data from all weeks you can see a pattern emerge. I occasionally stay up way too late on Saturday night probably to make up for a lack of productivity (real or imagined) from the week before. I also come online quite early in the morning which is when I tend to waste most time on social media. Not a good way to start my day for sure."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#downloads",
    "href": "posts/from-procrastination-to-productivity/index.html#downloads",
    "title": "From Procrastination to Productivity",
    "section": "Downloads",
    "text": "Downloads\nFinally I wanted to look at my downloads and see if I could learn anything from that. Let‚Äôs look at the downloads table:\n\ndownloads.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 86 entries, 0 to 85\nData columns (total 28 columns):\n #   Column                  Non-Null Count  Dtype \n---  ------                  --------------  ----- \n 0   id                      86 non-null     int64 \n 1   guid                    86 non-null     object\n 2   current_path            86 non-null     object\n 3   target_path             86 non-null     object\n 4   start_time              86 non-null     int64 \n 5   received_bytes          86 non-null     int64 \n 6   total_bytes             86 non-null     int64 \n 7   state                   86 non-null     int64 \n 8   danger_type             86 non-null     int64 \n 9   interrupt_reason        86 non-null     int64 \n 10  hash                    86 non-null     object\n 11  end_time                86 non-null     int64 \n 12  opened                  86 non-null     int64 \n 13  last_access_time        86 non-null     int64 \n 14  transient               86 non-null     int64 \n 15  referrer                86 non-null     object\n 16  site_url                86 non-null     object\n 17  embedder_download_data  86 non-null     object\n 18  tab_url                 86 non-null     object\n 19  tab_referrer_url        86 non-null     object\n 20  http_method             86 non-null     object\n 21  by_ext_id               86 non-null     object\n 22  by_ext_name             86 non-null     object\n 23  etag                    86 non-null     object\n 24  last_modified           86 non-null     object\n 25  mime_type               86 non-null     object\n 26  original_mime_type      86 non-null     object\n 27  by_web_app_id           86 non-null     object\ndtypes: int64(11), object(17)\nmemory usage: 18.9+ KB\n\n\nThere are a few WebKit/Chrome timestamps that we need to convert to datetime format.\n\ndownloads['start_time_dt'] = pd.to_datetime(downloads.start_time.map(date_from_webkit), utc=True).dt.tz_convert(tzlocal.get_localzone().key)\n\n\ndownloads.loc[downloads.end_time &gt; 0, \"end_time_dt\"] = (pd.to_datetime(downloads.loc[downloads.end_time &gt; 0, \"end_time\"]\n    .map(date_from_webkit), utc=True).dt.tz_convert(tzlocal.get_localzone().key)\n)\n\n\ndownloads.loc[downloads.last_access_time &gt; 0, \"last_access_time_dt\"] = (pd.to_datetime(downloads.loc[downloads.last_access_time &gt; 0, \"last_access_time\"]\n    .map(date_from_webkit), utc=True).dt.tz_convert(tzlocal.get_localzone().key)\n)\n\n\nDownloads per month\nLet‚Äôs first look at how many GB of data I download each month.\n\nxticks = [\"{}, {}\".format(y, m) for y, _, m in downloads.groupby([downloads.start_time_dt.dt.year, downloads.start_time_dt.dt.month, downloads.start_time_dt.dt.month_name()]).size().index]\n\nax = downloads.groupby([downloads.start_time_dt.dt.year, downloads.start_time_dt.dt.month]).received_bytes.sum().plot(kind='bar', xlabel='', title=\"Downloads in GB by month\")\nax.set_xticklabels(xticks)\n\nticks_loc = ax.get_yticks().tolist()\nax.yaxis.set_major_locator(FixedLocator(ticks_loc))\nax.set_yticklabels(['{:,.0f}GB'.format(x/1e9) for x in ticks_loc])\n\nplt.show()\n\n\n\n\n\n\n\n\nI‚Äôve been traveling in August which is why I haven‚Äôt downloaded as much as in July.\n\n\nDownloads by file type\nLet‚Äôs see what kind of files I download most by looking at its extension.\n\nfig, ax = plt.subplots(figsize=(10,8))\n(downloads.target_path.apply(lambda p: Path(p).suffix.lower())\n    .replace('', np.nan).dropna()\n    .value_counts().sort_values()\n    .plot(kind='barh', ax=ax, ylabel='', title=\"Most downloaded file types\"))\nax.xaxis.set_major_locator(MaxNLocator(integer=True))\nplt.show()\n\n\n\n\n\n\n\n\nMost of the files I download are PDFs.\n\n\nWhere I download most files from\nLet‚Äôs look at the top 10 websites I download most files from. I start by extracting the network location from the tab_url attribute which contains the URL that provided the download link.\n\ndownloads['netloc'] = downloads.tab_url.map(lambda r: urlparse(r).netloc)\n\n\n(downloads.query('netloc.str.len() &gt; 0')\n    .groupby('netloc').size().sort_values(ascending=False)\n    .to_frame().head(10).reset_index().rename({0: 'count'}, axis=1)\n    .style.hide(axis='index')\n)\n\n\n\n\n\n\nnetloc\ncount\n\n\n\n\nlibretexts.org\n17\n\n\nblackboard.nhlstenden.com\n10\n\n\nwww.classicalguitarmidi.com\n10\n\n\nwww.ns.nl\n5\n\n\ndevtools\n4\n\n\narchive.org\n3\n\n\nwww.google.com\n2\n\n\ns9.imslp.org\n2\n\n\nlearn-eu-central-1-prod-fleet01-xythos.content.blackboardcdn.com\n2\n\n\noutlook.office.com\n2"
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#wrapping-this-up",
    "href": "posts/from-procrastination-to-productivity/index.html#wrapping-this-up",
    "title": "From Procrastination to Productivity",
    "section": "Wrapping this up",
    "text": "Wrapping this up\nThere‚Äôs a lot more we could look at. Some further ideas I have:\n\nVisualize how I transition from one website to another using GraphViz.\nVisualize during which time of the day I check social media, and for how long.\nTry to identify what triggers my procrastination.\nIdentify what I do directly after visiting social media.\nThe Chrome mobile browser history syncs with the browser history on my laptop. I could separate this data and see on which device I waste most of my time.\n\nThe more time I spend on this, the more ideas I get. I‚Äôm going to leave it at this for now though.\nBased on this analysis, I intend to do the following:\n\nStay away from my phone early in the morning. I‚Äôll charge it in a room I don‚Äôt come that often so it‚Äôs out of sight and I don‚Äôt grab it first thing in the morning.\nCheck my social media only once a day at a fixed time. Have a book nearby so I can read when I want to distract myself instead of doomscrolling.\nBlock news sites and Twitter. If something earth-shattering happens I‚Äôm sure people will let me know. Constantly coming back to and checking these sites feels like sprinkling an otherwise perfect day with unnecessary negativity and drama.\nGo to bed on time and get up on time. Limit my screen time.\nTake way more breaks, at least every two hours. I tend to work long stretches of time wanting to finish something, sometimes even forgetting to eat. I think that the constant checking of social media is my brain telling me it needs a proper break."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#analyze-your-own-browser-data",
    "href": "posts/from-procrastination-to-productivity/index.html#analyze-your-own-browser-data",
    "title": "From Procrastination to Productivity",
    "section": "Analyze your own browser data",
    "text": "Analyze your own browser data\nCongratulations if you made it this far! Now stop procrastinating and get back to work!\nIf you want to play with an interactive version and analyze your own browser data, you can get the source code as a GitHub gist here."
  },
  {
    "objectID": "posts/soma-cube/index.html",
    "href": "posts/soma-cube/index.html",
    "title": "Soma Cube",
    "section": "",
    "text": "The Soma cube is the brainchild of Danish mathematician, inventor, designer, writer and poet Piet Hein. The puzzle consists of seven pieces and the goal is to assemble these pieces into a 3x3x3 cube or other shapes.\nPiet Hein came up with this puzzle during a lecture on quantum physics by Werner Heisenberg. Instead of paying attention to the renowned theoretical physicist, Piet prefered idling away his time by thinking up frivolous brainteasers. Such a waste, not to mention rude! What‚Äôs even worse is that people seemed to actually enjoy his puzzle. This meant that Piet Hein‚Äôs invention wasn‚Äôt just a time-waster for him but for everyone who got hooked on it.\nInitially, the Soma cube was mostly known in Scandinavian countries, but things took a dark turn when Martin Gardner featured it in his Mathematical Games column in Scientific American in September 1958. Suddenly, the whole world got introduced to this time-waster.\nAs a self-proclaimed restorer of productivity, I hate to see people trifle away their lives trying to solve these inane puzzles. For this reason I‚Äôve created a Soma solver in Python so people can go back to spending time on more fruitful pursuits.\nRead on to learn how I did this."
  },
  {
    "objectID": "posts/soma-cube/index.html#the-soma-puzzle-pieces",
    "href": "posts/soma-cube/index.html#the-soma-puzzle-pieces",
    "title": "Soma Cube",
    "section": "The Soma puzzle pieces",
    "text": "The Soma puzzle pieces\nEach of the seven pieces has a different shape. I‚Äôve given each shape a different color to ease visualizing solutions later on.\n      \nAs mentioned above, the objective is to assemble these pieces into various shapes, like a cube."
  },
  {
    "objectID": "posts/soma-cube/index.html#importing-libraries",
    "href": "posts/soma-cube/index.html#importing-libraries",
    "title": "Soma Cube",
    "section": "Importing libraries",
    "text": "Importing libraries\nLet‚Äôs start by importing some libraries. We‚Äôll use matplotlib to visualize solutions in 3D.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport ipywidgets as widgets\n\nfrom IPython.display import HTML\nfrom math import ceil"
  },
  {
    "objectID": "posts/soma-cube/index.html#representing-the-pieces",
    "href": "posts/soma-cube/index.html#representing-the-pieces",
    "title": "Soma Cube",
    "section": "Representing the pieces",
    "text": "Representing the pieces\nWe‚Äôll represent each piece as a list of coordinates in 3D space. Each tuple is an (x, y, z) coordinate.\n\nz = [(0,0,0),(1,0,0),(1,1,0),(2,1,0)] # blue piece\np = [(0,0,0),(0,1,0),(0,1,1),(1,1,0)] # red piece\nt = [(0,0,0),(0,1,0),(1,1,0),(0,2,0)] # purple piece\nb = [(0,0,0),(1,0,0),(0,1,0),(0,1,1)] # brown piece\na = [(0,0,0),(0,0,1),(0,1,0),(1,1,0)] # yellow piece\nl = [(0,0,0),(1,0,0),(2,0,0),(0,1,0)] # orange piece\nv = [(0,0,0),(1,0,0),(0,1,0)] # green piece\n\nThe letters z, t, p, b, a, l, and v look (with some imagination) like the pieces.\nLet‚Äôs put all pieces and colors in a list so we can access them by index.\n\npieces = [z, p, t, b, a, l, v]\ncolors = [\"blue\", \"red\", \"purple\", \"brown\", \"yellow\", \"orange\", \"green\"]"
  },
  {
    "objectID": "posts/soma-cube/index.html#visualizing-the-pieces-and-solution",
    "href": "posts/soma-cube/index.html#visualizing-the-pieces-and-solution",
    "title": "Soma Cube",
    "section": "Visualizing the pieces and solution",
    "text": "Visualizing the pieces and solution\nBefore writing the solver, let‚Äôs consider how we can create a 3D visualization of the Soma cube. I‚Äôve chosen to use Matplotlib for its 3D rendering capabilities.\nMatplotlib can draw voxels (3D pixels) which we can use to visualize a single piece, multiple pieces, or even the full solution in 3D. The following function takes a 3D numpy array that represents the voxels and plots them.\n\ndef plot_solution(colors, ax=None):\n    if not ax:\n        fig = plt.figure()\n\n        # axis with 3D projection\n        ax = fig.add_subplot(projection='3d')\n        \n    ax.set_aspect('equal')\n    ax.set_axis_off()\n\n    # draw each voxel with a color (each voxel unequal to None)\n    voxels = (colors != None)\n\n    ax.voxels(voxels, facecolors=colors, edgecolors=colors)\n\nTo use this function we need to call it with a 3D numpy array that represents each voxel.\n\nvoxels = np.empty((3,3,3), dtype='object')\n\nEach element in this array is initialized to None.\n\nvoxels\n\narray([[[None, None, None],\n        [None, None, None],\n        [None, None, None]],\n\n       [[None, None, None],\n        [None, None, None],\n        [None, None, None]],\n\n       [[None, None, None],\n        [None, None, None],\n        [None, None, None]]], dtype=object)\n\n\nLet‚Äôs set each element of voxels to a color and call plot_solution. We can set elements seperately, like this:\n\nvoxels[0][0][0] = 'yellow'\nvoxels[1][0][0] = 'yellow'\nvoxels[0][0][1] = 'yellow'\nvoxels[0][1][1] = 'yellow'\n\nOr we can set all elements at once.\n\nvoxels = np.array([\n    [['yellow', 'yellow', 'orange'],\n     ['brown',  'yellow', 'orange'],\n     ['brown',  'brown',  'orange']],\n    [['yellow', 'green',  'orange'],\n     ['brown',  'blue',   'blue'],\n     ['blue',   'blue',   'red']],\n    [['purple', 'green',  'green'],\n     ['purple', 'purple', 'red'],\n     ['purple', 'red',    'red']]\n])\n\n\nplot_solution(voxels)\nplt.show()\n\n\n\n\n\n\n\n\nThis is the same solution as shown above and one of the 240 possible unique ways of packing the seven Soma pieces into a 3x3x3 cube.\nLet‚Äôs see how we can visualize a single piece.\n\ndef plot_piece(piece, color, ax=None):\n    max_dim = np.max([np.max(piece) + 1, 3])\n    voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n    for x, y, z in piece:\n        voxels[x][y][z] = color\n    plot_solution(voxels, ax)\n\n\nplot_piece(z, \"blue\")\nplt.show()"
  },
  {
    "objectID": "posts/soma-cube/index.html#animating-a-solution",
    "href": "posts/soma-cube/index.html#animating-a-solution",
    "title": "Soma Cube",
    "section": "Animating a solution",
    "text": "Animating a solution\nIn the solution above it was impossible to tell how some pieces were positioned. The following function animates the assembly of a solution by adding pieces one by one.\n\ndef animate_solution(colors):\n    w, d, h = colors.shape\n    \n    show_order = []\n    for a in range(1,max(w, d, h)+1):\n        for z in range(min(a,h)):\n            for x in range(min(a,w)):\n                for y in range(d-1,d-1-min(a,d),-1):\n                    color = colors[x][y][z]\n                    if not (color is None or color in show_order):\n                        show_order.append(color)\n    \n    fig = plt.figure()\n    \n    ax = fig.add_subplot(projection='3d')\n    \n    def update(frame):\n        ax.clear()\n        ax.set_aspect('equal')\n        ax.set_axis_off()\n        \n        voxels = np.in1d(colors, show_order[:frame+1]).reshape(colors.shape)\n\n        ax.voxels(voxels, facecolors=colors, edgecolors=colors)\n\n    plt.close()\n\n    anim = animation.FuncAnimation(fig, update, frames=len(show_order), interval=1000)\n    \n    return anim\n\n\nanim = animate_solution(voxels)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nNow it‚Äôs much clearer how a solution is constructed."
  },
  {
    "objectID": "posts/soma-cube/index.html#rotating-pieces",
    "href": "posts/soma-cube/index.html#rotating-pieces",
    "title": "Soma Cube",
    "section": "Rotating pieces",
    "text": "Rotating pieces\nWe will implement the solver using a simple recursive backtracking algorithm. The solver will try to fit the pieces in their various orientations. For this reason, we define some helper functions to rotate a piece around an axis. I also defined an identity function that just returns the input as is. Its use will become clear later.\n\nrotate_x = lambda cubelets: [(x, z, -y) for (x, y, z) in cubelets]\nrotate_y = lambda cubelets: [(z, y, -x) for (x, y, z) in cubelets]\nrotate_z = lambda cubelets: [(-y, x, z) for (x, y, z) in cubelets]\nidentity = lambda cubelets: cubelets\n\nFor instance, to rotate piece z around the x-axis we can make use of rotate_x.\n\nrotate_x(z)\n\n[(0, 0, 0), (1, 0, 0), (1, 0, -1), (2, 0, -1)]\n\n\nWe can see that rotating a piece may make some coordinates negative. The following function translates a piece so that all x, y, z coordinates are minimal but positive.\n\ndef translate(piece):\n    d_x, d_y, d_z = np.min(np.array(piece), axis=0) * -1\n    return [(x + d_x, y + d_y, z + d_z) for (x, y, z) in piece]\n\nNow we can do the same rotation as above but end up with coordinates that are all positive.\n\ntranslate(rotate_x(z))\n\n[(0, 0, 1), (1, 0, 1), (1, 0, 0), (2, 0, 0)]\n\n\nWe will use this translate function when we display individual pieces."
  },
  {
    "objectID": "posts/soma-cube/index.html#generating-all-orientations-for-each-piece",
    "href": "posts/soma-cube/index.html#generating-all-orientations-for-each-piece",
    "title": "Soma Cube",
    "section": "Generating all orientations for each piece",
    "text": "Generating all orientations for each piece\nUsing the functions defined above we can generate all orientations for each piece. Several transformations are performed one after another. The identity function just returns the original orientation.\n\ndef generate_rotations(piece):\n    orientations = []\n    for f_a in [identity, rotate_x,  rotate_y, rotate_z]:\n        for f_b in [identity, rotate_x,  rotate_y, rotate_z]:\n            for f_c in [identity, rotate_x,  rotate_y, rotate_z]:\n                for f_d in [identity, rotate_x,  rotate_y, rotate_z]:\n                    for f_e in [identity, rotate_x,  rotate_y, rotate_z]:\n                        rot_piece = sorted(f_a(f_b(f_c(f_d(f_e(piece))))))\n                        min_x, min_y, min_z = rot_piece[0]\n                        trans_rot_piece = [(x - min_x, y - min_y, z - min_z) for x, y, z in rot_piece]\n                        if trans_rot_piece not in orientations:\n                            orientations.append(trans_rot_piece)\n                        \n    return orientations\n\nWe can call this function for one piece.\n\ngenerate_rotations(z)\n\n[[(0, 0, 0), (1, 0, 0), (1, 1, 0), (2, 1, 0)],\n [(0, 0, 0), (1, 0, -1), (1, 0, 0), (2, 0, -1)],\n [(0, 0, 0), (0, 0, 1), (0, 1, -1), (0, 1, 0)],\n [(0, 0, 0), (0, 1, 0), (1, -1, 0), (1, 0, 0)],\n [(0, 0, 0), (1, -1, 0), (1, 0, 0), (2, -1, 0)],\n [(0, 0, 0), (0, 1, 0), (0, 1, 1), (0, 2, 1)],\n [(0, 0, 0), (0, 0, 1), (1, 0, 1), (1, 0, 2)],\n [(0, 0, 0), (0, 1, -1), (0, 1, 0), (0, 2, -1)],\n [(0, 0, 0), (1, 0, 0), (1, 0, 1), (2, 0, 1)],\n [(0, 0, 0), (0, 1, 0), (1, 1, 0), (1, 2, 0)],\n [(0, 0, 0), (0, 0, 1), (0, 1, 1), (0, 1, 2)],\n [(0, 0, 0), (0, 0, 1), (1, 0, -1), (1, 0, 0)]]\n\n\nOr we can apply this function to every piece in the pieces list we defined above.\n\norientations = list(map(generate_rotations, pieces))\n\nWe can display all orientations for each piece. Note how we apply translate to make sure all coordinates end up in the positive quadrant.\n\ncols = 8\ntotal_number_of_orientations = sum(list(map(len,orientations)))\nrows = ceil(total_number_of_orientations / cols)\nfig, axs = plt.subplots(rows, cols, figsize=(cols*3,rows*3), \n    subplot_kw= { 'projection':'3d' }, gridspec_kw = {'wspace':0.0, 'hspace':0.0})\n\nfig.subplots_adjust(top=0.96)\nfig.suptitle(f\"Orientations\", fontsize=16)\n\ncount = 0\nfor i in range(len(pieces)):\n    for j in range(len(orientations[i])):\n        plot_piece(translate(orientations[i][j]), colors[i], axs[count // cols, count % cols])\n        count += 1\n\nwhile count &lt; cols * rows:\n    axs[count // cols, count % cols].set_axis_off()\n    count += 1\n\nplt.show()\n\n\n\n\n\n\n\n\nIn the solver below, for each piece we‚Äôll see which orientation fits where."
  },
  {
    "objectID": "posts/soma-cube/index.html#writing-the-solver",
    "href": "posts/soma-cube/index.html#writing-the-solver",
    "title": "Soma Cube",
    "section": "Writing the solver",
    "text": "Writing the solver\nWe‚Äôre finally ready to work on the solver for the Soma cube. The solver will take in a list of coordinates (that make up the cube that we want to fill up with pieces) and recursively search for a solution.\nWe can generate this list of coordinates using a simple list comprehension.\n\ncube_coordinates = [(x, y, z) for x in range(3) for y in range(3) for z in range(3)]\n\n\ncube_coordinates\n\n[(0, 0, 0),\n (0, 0, 1),\n (0, 0, 2),\n (0, 1, 0),\n (0, 1, 1),\n (0, 1, 2),\n (0, 2, 0),\n (0, 2, 1),\n (0, 2, 2),\n (1, 0, 0),\n (1, 0, 1),\n (1, 0, 2),\n (1, 1, 0),\n (1, 1, 1),\n (1, 1, 2),\n (1, 2, 0),\n (1, 2, 1),\n (1, 2, 2),\n (2, 0, 0),\n (2, 0, 1),\n (2, 0, 2),\n (2, 1, 0),\n (2, 1, 1),\n (2, 1, 2),\n (2, 2, 0),\n (2, 2, 1),\n (2, 2, 2)]\n\n\nThe solver will yield the same list but each tuple will have an extra element indicating the color that coordinate will get after all pieces have been placed.\nWe‚Äôll use a list of booleans to keep track of which pieces have been placed.\n\npieces_used = [False] * 7\n\n\ndef solve_soma_(solution, i):\n    if i == 27:\n        yield solution\n    else:\n        x, y, z, _ = solution[i]\n        for piece in range(7):\n            if not pieces_used[piece]:\n                for orientation in orientations[piece]:\n                    empty_coords = [(x + d_x, y + d_y, z + d_z, None) for (d_x, d_y, d_z) in orientation]\n                    if all([tup in solution for tup in empty_coords]):\n                        # placing piece: replace None with color\n                        pieces_used[piece] = True\n                        filled_coords = [(x + d_x, y + d_y, z + d_z, colors[piece]) for (d_x, d_y, d_z) in orientation]\n                        new_solution = sorted([tup for tup in solution if tup not in empty_coords] + filled_coords)\n                        \n                        # find next empty coordinate\n                        j = i\n                        while j &lt; 27 and new_solution[j][3]:\n                            j += 1\n                            \n                        # continue search\n                        yield from solve_soma_(new_solution, j)\n                        pieces_used[piece] = False\n\n\ndef solve_soma(coordinates):\n    global pieces_used\n    pieces_used = [False] * 7\n    \n    solution = sorted([(x, y, z, None) for x, y, z in coordinates])\n    yield from solve_soma_(solution, 0)\n\nYou call the solve_soma function with a list of coordinates representing the space that will be packed with Soma pieces. The actual algorithm is implemented in solve_soma_. The algorithm does the following:\n\nIt checks if all coordinates are filled. If so, it yields the solution.\nFor each possible orientation of a piece, it checks if it can be placed from the current coordinate without overlapping with filled coordinates that are already in the solution.\nIf a valid placement is found, it recursively explores how to fill from the next empty coordinate.\nAfter exploring a piece and its orientation, it tries other possibilities.\n\nDifferent solutions may be duplicates of each other in the sense that one solution is a rotation of another."
  },
  {
    "objectID": "posts/soma-cube/index.html#finding-and-displaying-a-solution",
    "href": "posts/soma-cube/index.html#finding-and-displaying-a-solution",
    "title": "Soma Cube",
    "section": "Finding and displaying a solution",
    "text": "Finding and displaying a solution\nThe solver is a generator function that yields all solutions one by one. Let‚Äôs start by just displaying the first solution it finds.\nThe following function finds the first solution given a list of coordinates to fill and plots this solution.\n\ndef solve_and_plot_first_solution(coordinates, ax=None):\n    # instantiate generator\n    gen = solve_soma(coordinates)\n\n    # find first solution\n    solution = next(gen)\n\n    # find voxel space size\n    max_dim = np.max(coordinates) + 1\n\n    # fill 3D voxel array and plot it\n    voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n    for x, y, z, color in solution:\n        voxels[x][y][z] = color\n\n    plot_solution(voxels, ax)\n\n\nsolve_and_plot_first_solution(cube_coordinates)\nplt.show()\n\n\n\n\n\n\n\n\nWe‚Äôll also define a function that finds the first solution and then animates it.\n\ndef solve_and_animate_first_solution(coordinates):\n    # instantiate generator\n    gen = solve_soma(coordinates)\n\n    # find first solution\n    solution = next(gen)\n\n    # find voxel space size\n    max_dim = np.max(coordinates) + 1\n\n    # fill 3D voxel array and plot it\n    voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n    for x, y, z, color in solution:\n        voxels[x][y][z] = color\n\n    anim = animate_solution(voxels)\n    display(HTML(anim.to_jshtml(default_mode='once')))\n\n\nsolve_and_animate_first_solution(cube_coordinates)\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect"
  },
  {
    "objectID": "posts/soma-cube/index.html#creating-other-figures",
    "href": "posts/soma-cube/index.html#creating-other-figures",
    "title": "Soma Cube",
    "section": "Creating other figures",
    "text": "Creating other figures\nWe called the solver with cube_coordinates that contains the coordinates that make up a cube. Instead of a cube, we can also pass a sorted list of coordinates that make up another shape.\nLet‚Äôs look at some examples.\n\npyramid_coordinates = sorted(\n    [(x, y, 0) for x in range(1, 4) for y in range(5)] + \n    [(x, y, 0) for x in [0, 4] for y in range(1, 4)] +\n    [(2, y, 1) for y in range(1, 4)] + \n    [(1, 2, 1), (3, 2, 1), (2, 2, 2)]\n)\n\nturtle_coordinates = sorted(\n    [(x, y, z) for x in range(1, 4) for y in range(1, 4) for z in range(2)] +\n    [(4, 2, z) for z in range(3)] + \n    [(0, 2, 0), (1, 0, 0), (1, 4, 0), (3, 0, 0), (3, 4, 0), (5, 2, 2)]\n)\n\ntower_coordinates = sorted(\n    [(x, y, z) for x in range(2) for y in range(2) for z in range(7) if (x, y, z) != (1, 0, 6)]\n)\n\nbear_coordinates = sorted(\n    [(x, y, 0) for x in range(3) for y in range(2)] +\n    [(x, 1, z) for x in range(3) for z in range(1, 6)] + \n    [(x, 0, z) for x in [0, 2] for z in [1, 3, 4]]\n)\n\ntunnel_coordinates = sorted(\n    [(x, y, 0) for x in range(5) for y in range(3) if x != 2] +\n    [(x, y, 1) for x in range(1, 4) for y in range(3) if x != 2] +\n    [(x, y, 2) for x in range(1, 4) for y in range(3)]\n)\n\ntub_coordinates = sorted(\n    [(x, y, 0) for x in range(5) for y in range(3)] +\n    [(x, y, 1) for x in range(5) for y in range(3) if x in [0, 4] or y in [0, 2]]\n)\n\nairplane_coordinates = sorted(\n    [(x, y, 0) for x in range(1, 6) for y in range(7) if x == 3 or y in [0, 1]] +\n    [(x, y, 1) for x in range(7) for y in range(7) if y == 0 or (x == 3 and y != 5)]\n)\n\nbench_coordinates = sorted(\n    [(x, y, z) for x in range(5) for y in range(2) for z in range(3) if y == 1 or x in [0, 4]] +\n    [(x, 0, 1) for x in range(1, 4)] +\n    [(x, 1, 3) for x in range(1, 4)]\n)\n\nduck_coordinates = sorted(\n    [(x, y, z) for x in range(4) for y in range(3) for z in range(2)] +\n    [(3, 1, 2), (3, 1, 3), (4, 1, 3)]\n)\n\ncascade_coordinates = sorted(\n    [(x, y, z) for x in range(3) for y in range(3) for z in range(5) if (2-x) + y &gt;= z]\n)\n\nchair_coordinates = sorted(\n    [(x, y, z) for x in range(3) for y in range(3) for z in range(2)] +\n    [(x, 2, z) for x in range(3) for z in range(2, 5)]\n)\n\ncastle_coordinates = sorted(\n    [(x, y, 0) for x in range(5) for y in range(5) if (x, y) not in [(0,2), (4,2)]] +\n    [(0, 0, 1), (0, 4, 1), (4, 0, 1), (4, 4, 1)]\n)\n\ndog_coordinates = sorted(\n    [(x, y, 0) for x in range(6) for y in range(3) if (x, y) not in [(3, 0), (3, 2), (5, 1)]] +\n    [(x, y, 1) for x in range(5) for y in range(3) if x == 4 or y == 1] +\n    [(x, 1, z) for x in range(3, 6) for z in range(2, 4) if (x, z) != (5, 3)]\n)\n\ncross_coordinates = sorted(\n    [(x, y, z) for x in range(3) for y in range(3) for z in range(2)] +\n    [(1, y, 2) for y in range(3)] +\n    [(1, 1, z) for z in range(3, 7)] + \n    [(0, 1, 5), (2, 1, 5)]\n)\n\nelephant_coordinates = sorted(\n    [(0, 0, 0), (3, 0, 0), (0, 2, 0), (3, 2, 0)] + \n    [(x, y, 1) for x in range(4) for y in range(3) if (x, y) != (3, 1)] +\n    [(x, 1, z) for x in range(5) for z in range(2, 4) if (x, z) != (0, 3)] +\n    [(4, 1, 1), (2, 0, 2), (2, 2, 2)]\n)\n\nstairs_coordinates = sorted(\n    [(x, y, z) for y in range(3) for z in range(3) for x in range(4-z)]\n)\n\nsnake_coordinates = sorted(\n    [(x, y, z) for y in range(4) for z in range(2) for x in range(2*(3-y), (2*(3-y))+3)] +\n    [(x, 0, z) for x in range(8, 10) for z in range(2, 4) if x == 8 or z == 3]\n)\n\nskyscraper_coordinates = sorted(\n    [(x, y, 0) for x in range(3) for y in range(3)] +\n    [(x, y, z) for x in range(2) for y in range(1, 3) for z in range(1, 5)] + \n    [(1, 1, 5), (1, 1, 6)]\n)\n\nwall_coordinates = sorted(\n    [(x, x - 1, 0) for x in range(1, 6)] +\n    [(x, x, z) for x in range(6) for z in range(2)] +\n    [(x, x + 1, z) for x in range(5) for z in range(2)]\n)\n\nLet‚Äôs place these figures and their names into lists.\n\nfigure_names = [\"Cube\", \"Pyramid\", \"Turtle\", \"Tower\", \"Bear\", \"Tunnel\", \"Tub\", \"Airplane\", \n                \"Bench\", \"Duck\", \"Cascade\", \"Chair\", \"Castle\", \"Dog\", \"Cross\", \"Elephant\",\n                \"Stairs\", \"Snake\", \"Skyscraper\", \"Wall\"\n               ]\nfigure_coordinates = [\n    cube_coordinates, pyramid_coordinates, turtle_coordinates, \n    tower_coordinates, bear_coordinates, tunnel_coordinates,\n    tub_coordinates, airplane_coordinates, bench_coordinates,\n    duck_coordinates, cascade_coordinates, chair_coordinates,\n    castle_coordinates, dog_coordinates, cross_coordinates,\n    elephant_coordinates, stairs_coordinates, snake_coordinates,\n    skyscraper_coordinates, wall_coordinates\n]\n\nYou can add more figures if you want. Just make sure that each list contains exactly 27 coordinates.\nWe can plot all figures as subplots.\n\ncols = 5\nnumber_of_figures = len(figure_coordinates)\nrows = ceil(number_of_figures / cols)\nfig, axs = plt.subplots(rows, cols, figsize=(cols*3,rows*3), \n    subplot_kw= { 'projection':'3d' }, gridspec_kw = {'wspace':0.5, 'hspace':0.0})\n\nfig.suptitle(f\"Figures\", fontsize=16)\n\ncount = 0\nfor i in range(number_of_figures):\n    solve_and_plot_first_solution(figure_coordinates[i], axs[count // cols, count % cols])\n    axs[count // cols, count % cols].set_title(figure_names[i])\n    count += 1\n\nwhile count &lt; cols * rows:\n    axs[count // cols, count % cols].set_axis_off()\n    count += 1\n\nplt.show()\n\n\n\n\n\n\n\n\nI have to admit that some figures are pretty cute."
  },
  {
    "objectID": "posts/soma-cube/index.html#showing-solutions-one-by-one",
    "href": "posts/soma-cube/index.html#showing-solutions-one-by-one",
    "title": "Soma Cube",
    "section": "Showing solutions one by one",
    "text": "Showing solutions one by one\nMost figures can be assembled in more than one way. Using some widgets we can put together a simple GUI that lets us select a figure, solve it and iterate over the solutions.\nWe‚Äôll use a dropdown menu, a button, an output widget, and a label widget. The solutions are shown as an animation we can step through.\nfigure_dropdown = widgets.Dropdown(options=zip(figure_names, figure_coordinates), value=cube_coordinates, description=\"Figure: \")\nnext_button = widgets.Button(description=\"Next\")\nhbox = widgets.HBox([figure_dropdown, next_button])\noutput = widgets.Output()\nlabel = widgets.Label()\n\ndisplay(hbox, output, label)\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nTo keep track of which solution to show next, we declare the following global variables:\ngen = None\nsolution = None\nThe gen is a generator object that generates solutions for a given figure using the solve_soma function. The solution variable stores the next solution to be displayed. It is updated each time the ‚ÄúNext‚Äù button is clicked to display the next solution.\ndef figure_dropdown_change(change):\n    global gen\n    global solution\n    \n    if change['type'] == 'change' and change['name'] == 'value':\n        value = change['new']\n        next_button.layout.display = 'none'\n        \n        output.clear_output()\n        \n        gen = solve_soma(value)\n        try:\n            solution = next(gen)            \n            with output:\n                # find voxel space size\n                max_dim = np.max(value) + 1\n\n                # fill 3D voxel array and plot it\n                voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n                for x, y, z, color in solution:\n                    voxels[x][y][z] = color\n\n                anim = animate_solution(voxels)\n                display(HTML(anim.to_jshtml(default_mode='once')))\n        except StopIteration:\n            label.value = \"No solutions found.\"\n            return\n\n        try:\n            solution = next(gen).copy()\n            label.value = \"\"\n            next_button.layout.display = 'inline-block'\n        except StopIteration:\n            label.value = \"\"\n\nfigure_dropdown.observe(figure_dropdown_change)\nThe figure_dropdown_change function handles changes to the figure dropdown menu. It clears the output widget, displays the first solution, and stores the next solution in the solution variable (if any).\ndef on_next_button_clicked(b):\n    global gen\n    global solution\n    \n    output.clear_output(wait=True)\n    with output:\n        # find voxel space size\n        max_dim = np.max(figure_dropdown.value) + 1\n\n        # fill 3D voxel array and plot it\n        voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n        for x, y, z, color in solution:\n            voxels[x][y][z] = color\n\n        anim = animate_solution(voxels)\n        display(HTML(anim.to_jshtml(default_mode='once')))\n    \n    try:\n        solution = next(gen)\n    except StopIteration:\n        label.value = \"\"\n        next_button.layout.display = 'none'\n\nnext_button.on_click(on_next_button_clicked)\n\nfigure_dropdown_change({'type': 'change', 'name': 'value', 'new': figure_dropdown.value})\nThe on_next_button_clicked function handles clicks on the ‚ÄúNext‚Äù button by clearing the output widget, displaying the current solution, and generating the next solution."
  },
  {
    "objectID": "posts/soma-cube/index.html#solving-your-own-soma-puzzles",
    "href": "posts/soma-cube/index.html#solving-your-own-soma-puzzles",
    "title": "Soma Cube",
    "section": "Solving your own Soma puzzles",
    "text": "Solving your own Soma puzzles\nThere you have it! No more wasting time on solving Soma puzzles. If you want to experiment with an interactive version of the solver, you can check out on of the following links:\n  \nNow go do something useful!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aswin van Woudenberg",
    "section": "",
    "text": "Hello, I‚Äôm Aswin. I blog about machine learning, logic programming, software development, or anything else that sparks my interest. Feel free to reach out via email or connect with me on LinkedIn.\n\n\n\n\n\n\n\n\nThe Wolf, Goat, and Cabbage Puzzle\n\n\n\n\n\n\nprogramming\n\nsql\n\npuzzles\n\n\n\nSome more SQL shenanigans.\n\n\n\n\n\nJan 17, 2026\n\n7 min\n\n\n\n\n\n\nSolving Takuzu Puzzles with SQL\n\n\n\n\n\n\nprogramming\n\nsql\n\npuzzles\n\n\n\nHow to use recursive CTEs to solve Takuzu (a.k.a. Binary) puzzles.\n\n\n\n\n\nJan 9, 2026\n\n10 min\n\n\n\n\n\n\nExploring Dutch Party Positions\n\n\n\n\n\n\nprogramming\n\npython\n\npandas\n\nsklearn\n\nmachine learning\n\n\n\nScraping and analyzing data from the Stemwijzer website.\n\n\n\n\n\nOct 21, 2025\n\n27 min\n\n\n\n\n\n\nEmbedding Pictures into Magic Squares\n\n\n\n\n\n\nprogramming\n\npython\n\nart\n\nmathematics\n\n\n\nHow to construct magic squares from any image using Python.\n\n\n\n\n\nJun 3, 2025\n\n18 min\n\n\n\n\n\n\nNo More Missed Trash Days\n\n\n\n\n\n\nprogramming\n\npython\n\n\n\nHow I fetch waste collection dates from an API and sync them to my calendar.\n\n\n\n\n\nJan 12, 2025\n\n4 min\n\n\n\n\n\n\nPrettifying My Phone\n\n\n\n\n\n\nprogramming\n\npython\n\nmatplotlib\n\nmachine learning\n\n\n\nHow I organized my mobile apps using the Chamfer distance metric, hierarchical clustering, and a simulated annealing-based algorithm for finding Hamiltonian paths.\n\n\n\n\n\nJul 14, 2024\n\n20 min\n\n\n\n\n\n\nFrom CAMT.053 to Charts\n\n\n\n\n\n\nprogramming\n\npython\n\nmatplotlib\n\npandas\n\n\n\nReading and visualizing bank transactions with Pandas and Matplotlib.\n\n\n\n\n\nJun 24, 2024\n\n27 min\n\n\n\n\n\n\nRun a Terminal in Google Colab (on the Free Tier)\n\n\n\n\n\n\nprogramming\n\npython\n\nmachine learning\n\n\n\nHow to open a terminal on Google Colab without paying for Colab Pro.\n\n\n\n\n\nFeb 10, 2024\n\n3 min\n\n\n\n\n\n\nMathematicians‚Äô Birthdays Calendar\n\n\n\n\n\n\nprogramming\n\npython\n\n\n\nWeb scraping Wikipedia to create a mathematicians‚Äô birthdays calendar.\n\n\n\n\n\nDec 25, 2023\n\n17 min\n\n\n\n\n\n\nWord Search Clock\n\n\n\n\n\n\nprogramming\n\npython\n\nmatplotlib\n\nalgorithms\n\n\n\nHow I created a clock using an old digital photo frame and some Python code.\n\n\n\n\n\nNov 26, 2023\n\n19 min\n\n\n\n\n\n\nSoma Cube\n\n\n\n\n\n\nprogramming\n\npython\n\nmatplotlib\n\npuzzles\n\n\n\nSolving Piet Hein‚Äôs Soma cube with Python.\n\n\n\n\n\nOct 20, 2023\n\n24 min\n\n\n\n\n\n\nFrom Procrastination to Productivity\n\n\n\n\n\n\nprogramming\n\npython\n\npandas\n\nmatplotlib\n\n\n\nHow I analyzed my browser history using Python.\n\n\n\n\n\nSep 2, 2023\n\n15 min\n\n\n\n\n\n\nMusikalisches W√ºrfelspiel\n\n\n\n\n\n\nprogramming\n\npython\n\nmusic\n\nart\n\ngames\n\n\n\nA Python implementation of Mozart‚Äôs musical dice game to automatically generate compositions and play them over MIDI.\n\n\n\n\n\nJul 26, 2023\n\n14 min\n\n\n\n\n\n\nSolving Word Ladders with Prolog\n\n\n\n\n\n\nprogramming\n\npuzzles\n\nprolog\n\nalgorithms\n\n\n\nHow to solve word ladders using the A* algorithm and Prolog.\n\n\n\n\n\nJun 3, 2023\n\n11 min\n\n\n\n\n\n\nThinking Inside the Matchbox\n\n\n\n\n\n\nprogramming\n\npython\n\nmachine learning\n\nreinforcement learning\n\nmatplotlib\n\ngames\n\n\n\nAn implementation of Donald Michie‚Äôs MENACE in Python.\n\n\n\n\n\nMay 27, 2023\n\n28 min\n\n\n\n\n\n\nCall Me Maybe?\n\n\n\n\n\n\nprogramming\n\npython\n\n\n\nA Python decorator to log function calls and a custom logging handler for creating call graphs.\n\n\n\n\n\nMay 16, 2023\n\n14 min\n\n\n\n\n\n\nBLOCBIRDS\n\n\n\n\n\n\nprogramming\n\npython\n\nsklearn\n\nart\n\n\n\nHow Mondrian would have produced his art had he been into birds and machine learning.\n\n\n\n\n\nJan 13, 2023\n\n6 min\n\n\n\n\n\n\nDancing Queen(s)\n\n\n\n\n\n\nprogramming\n\npython\n\nmatplotlib\n\npuzzles\n\n\n\nSolving the classic n-queens problem with Python and visualizing solutions using Matplotlib.\n\n\n\n\n\nSep 26, 2022\n\n10 min\n\n\n\n\n\n\nMaking Sense of Sorting\n\n\n\n\n\n\nprogramming\n\npython\n\nmatplotlib\n\nalgorithms\n\n\n\nEasy algorithm visualization in Python.\n\n\n\n\n\nSep 18, 2022\n\n9 min\n\n\n\n\n\n\nFrom Baby Face to Neanderthal\n\n\n\n\n\n\nprogramming\n\npython\n\nmediapipe\n\nopencv\n\n\n\nHow to turn a series of selfies into a time-lapse video using MediaPipe.\n\n\n\n\n\nJul 28, 2022\n\n9 min\n\n\n\n\n\n\nDraining the Fun Out of Wordle\n\n\n\n\n\n\nprogramming\n\npython\n\nsklearn\n\npuzzles\n\ndecision trees\n\n\n\nHow to generate a decision tree for solving Wordle games and save our civilization.\n\n\n\n\n\nFeb 21, 2022\n\n18 min\n\n\n\n\n\n\nTraversing a Decision Tree to Win at Guess Who?\n\n\n\n\n\n\nmachine learning\n\ndecision trees\n\ngames\n\npython\n\nsklearn\n\nprogramming\n\n\n\nHow to construct and traverse a decision tree and use it for playing Guess Who?\n\n\n\n\n\nJan 4, 2022\n\n17 min\n\n\n\n\n\n\nA Custom Sudoku Widget\n\n\n\n\n\n\nprogramming\n\npython\n\npuzzles\n\n\n\nCreating a custom Jupyter widget for editing and displaying Sudoku puzzles.\n\n\n\n\n\nFeb 26, 2021\n\n37 min\n\n\n\n\n\n\nPictionary Air Mouse\n\n\n\n\n\n\nprogramming\n\npython\n\nopencv\n\n\n\nUse the Pictionary Air pen as an alternative input device.\n\n\n\n\n\nDec 13, 2020\n\n5 min\n\n\n\n\n\n\nIcosian Game\n\n\n\n\n\n\nprogramming\n\nprolog\n\npuzzles\n\n\n\nA Prolog solver for the Icosian game.\n\n\n\n\n\nApr 24, 2020\n\n5 min\n\n\n\n\n\n\nSupercharging the Nabaztag\n\n\n\n\n\n\nprogramming\n\nprolog\n\niot\n\n\n\nA Nabaztag server that interfaces with ifttt.com.\n\n\n\n\n\nJul 15, 2019\n\n5 min\n\n\n\n\n\n\nSkyline Puzzle\n\n\n\n\n\n\nprogramming\n\nprolog\n\npuzzles\n\n\n\nA Prolog solver for the ‚ÄòSkyline‚Äô puzzle.\n\n\n\n\n\nOct 4, 2015\n\n3 min\n\n\n\n\n\n\nVBA IBAN Validator\n\n\n\n\n\n\nprogramming\n\nvba\n\n\n\nA function in VBA that checks the validity of an IBAN (International Bank Account Number).\n\n\n\n\n\nJul 18, 2013\n\n4 min\n\n\n\n\n\n\nBridge and Torch Puzzle\n\n\n\n\n\n\nprogramming\n\nprolog\n\npuzzles\n\n\n\nA Prolog solver for the ‚ÄòBridge and torch‚Äô puzzle.\n\n\n\n\n\nJul 3, 2009\n\n5 min\n\n\n\n\n\n\nWho Owns the Zebra\n\n\n\n\n\n\nprogramming\n\nprolog\n\npuzzles\n\n\n\nA Prolog solver for the ‚ÄòZebra puzzle‚Äô a.k.a. ‚ÄòEinstein‚Äôs puzzle‚Äô.\n\n\n\n\n\nOct 26, 2007\n\n6 min\n\n\n\n\n\n\nA Brainf*ck Interpreter in Prolog\n\n\n\n\n\n\nprogramming\n\nesoteric\n\nprolog\n\n\n\nAn esoteric programming language interpreter written in a slightly less esoteric programming language.\n\n\n\n\n\nJan 5, 2007\n\n4 min\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html",
    "href": "posts/thinking-inside-the-matchbox/index.html",
    "title": "Thinking Inside the Matchbox",
    "section": "",
    "text": "Reinforcement Learning (RL) has emerged as a powerful paradigm, enabling machines to learn and make decisions through trial and error. Recent successes in RL, such as agents that play Atari games, hold conversations, control nuclear fusion plasma and discover new algorithms, have demonstrated its potential for solving complex problems. However, the roots of RL can be traced back to an earlier era, where Donald Michie and his creation MENACE, helped pave the way for machines that could learn.\nThis blog post explores the design and functioning of MENACE, showcasing it as one of the earliest examples of RL. I‚Äôll also provide a Python implementation of MENACE so you can experiment with it yourself."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#menaces-genesis",
    "href": "posts/thinking-inside-the-matchbox/index.html#menaces-genesis",
    "title": "Thinking Inside the Matchbox",
    "section": "MENACE‚Äôs genesis",
    "text": "MENACE‚Äôs genesis\nDuring World War II, even before attending college, Donald Michie worked as a code breaker at Bletchley Park where he collaborated with Alan Turing. During their free time, the two men would play chess and theorize how game playing machines could be built.\nAfter the war, both Turing and Michie, in collaboration with others, came up with algorithms that could play chess. In 1948, Alan Turing and David Champernowne developed Turochamp. Somewhat earlier, Donald Michie, together with Shaun Wylie, had thought up a chess program called Machiavelli. These programs were primarily conceptual and required manual execution of instructions. Turochamp and Machiavelli relied on various heuristics to determine the most advantageous moves, with these heuristics being hard-coded without any learning capability.\nIn 1960, Michie wanted to show how a program could actually improve itself by playing many games and learn from its wins and losses. Chess was too complicated because of its many possible game states, so he shifted from chess to the much simpler game of tic-tac-toe (or noughts and crosses as they call it in the UK). Because Michie didn‚Äôt have access to a digital computer, he implemented his learning algorithm using matchboxes and colored beads. He called his machine Matchbox Educable Noughts and Crosses Engine, or MENACE."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#how-menace-plays-and-learns",
    "href": "posts/thinking-inside-the-matchbox/index.html#how-menace-plays-and-learns",
    "title": "Thinking Inside the Matchbox",
    "section": "How MENACE plays and learns",
    "text": "How MENACE plays and learns\n\nHow it‚Äôs setup\nEach matchbox in MENACE corresponds to a specific configuration of X‚Äôs, O‚Äôs, and empty squares on the tic-tac-toe game grid. Duplicate arrangements, such as rotations or mirror images of other configurations, are left out. Configurations representing concluded games or positions with only one empty square are also omitted. Furthermore, MENACE always goes first and only its own turns need to be represented. All this results in exactly 304 distinct configurations that MENACE can encounter, so only this many matchboxes are used.\n\n\n\nDonald Michie‚Äôs original MENACE\n\n\nInside each matchbox, there is a collection of colored beads. Each color represents a move that can be made on a specific square of the game grid.\n\n\n\n\n\nIn the original MENACE, these were the colors of beads used to indicate positions on the game grid\n\n\n\n\nMatchboxes with arrangements where positions on the grid are already taken don‚Äôt contain beads for those occupied positions. Bead colors that represent duplicate moves, resulting from rotating or mirroring the configuration, are also left out.\nA matchbox can contain multiple beads of the same color. Initially, the matchbox representing the first move, which corresponds to the empty grid, contains four beads for each color representing a possible move. In this initial move, MENACE has three options: moving in the center, a corner, or a side, resulting in a total of 12 beads. As for its second move, there are at most seven possibilities, and each vacant square has three of the same colored beads associated with it. In the case of MENACE‚Äôs third move, there are two beads for each of the at most five possibilities. Similarly, for its fourth move, there is one bead for each of the at most three possibilities.\n\n\nHow it plays\nWhen it‚Äôs MENACE‚Äôs turn to make a move, one must locate the matchbox that corresponds to the current grid configuration and randomly select a bead from within that matchbox. The chosen bead‚Äôs color indicates the square where MENACE makes its move. After each move, the selected matchbox and bead are put aside for later processing. This procedure is repeated for each of MENACE‚Äôs turns until a victor emerges or the game ends in a draw.\n\n\nHow it learns\nUpon completing a game, MENACE will need to be either ‚Äòpunished‚Äô or ‚Äòrewarded‚Äô for its choices based on the outcome. When MENACE loses, the beads representing its moves are simply removed. In the case of a draw, an additional bead of the corresponding color is added to each relevant matchbox. Conversely, if MENACE wins, three extra beads are added for each move it played.\nThese adjustments in bead quantities directly influence MENACE‚Äôs future gameplay. Poor performance reduces the likelihood of MENACE repeating the same gameplay, as the corresponding beads are removed. On the other hand, successful gameplay increases the probability of MENACE following a similar strategy in subsequent games due to the presence of additional beads.\nThrough this reward-based system, MENACE progressively refines its gameplay strategy. By reinforcing successful moves and discouraging less effective ones, MENACE becomes more adept at the game, increasing its chances of achieving victory or at least tie in future rounds.\nUsing modern-day reinforcement learning lingo, we would say that MENACE learns a policy. A policy refers to a mapping from the current environment observation to a probability distribution of the actions to be taken. In case of MENACE, the policy is determined by the number of beads of each color in a matchbox. We would calculate the probability of each action (each move) by taking the fraction of beads of a specific color in a matchbox over the total count of beads in that matchbox."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#a-python-implementation",
    "href": "posts/thinking-inside-the-matchbox/index.html#a-python-implementation",
    "title": "Thinking Inside the Matchbox",
    "section": "A Python implementation",
    "text": "A Python implementation\nIn the remainder of this post, I‚Äôll go over how I coded my own version of MENACE in Python. My implementation stays as close as possible to the original version as described by Donald Michie[1] but has the following additional features:\n\nMy implementation doesn‚Äôt just model the game grids of the first player, but of the second player as well. This allows MENACE to play against itself.\nThe number of beads to start out with in each turn is configurable.\nThe number of beads that are used to punish and reward are configurable as well.\nYou can visualize the state of all matchboxes before and after training.\nSome matchboxes may end up with 0 beads. In that case a random move is selected.\n\nI‚Äôll also show how to use my implementation for your own experiments."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#importing-modules",
    "href": "posts/thinking-inside-the-matchbox/index.html#importing-modules",
    "title": "Thinking Inside the Matchbox",
    "section": "Importing modules",
    "text": "Importing modules\nLet‚Äôs start by importing the necessary modules.\n\nfrom kaggle_environments import make, evaluate\nfrom math import ceil\nfrom IPython.display import HTML\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nimport random\nimport matplotlib\nmatplotlib.rcParams['animation.embed_limit'] = 2**128\n\nLoading environment lux_ai_s2 failed: No module named 'vec_noise'\n\n\nThe matplotlib library is used to display the state of each matchbox. I import kaggle_environments so we can animate matches. Importing this last module outputs a warning but this can safely be ignored."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#helper-functions",
    "href": "posts/thinking-inside-the-matchbox/index.html#helper-functions",
    "title": "Thinking Inside the Matchbox",
    "section": "Helper functions",
    "text": "Helper functions\nGame grids are represented using a simple string. Each string is 9 characters long and contains only X‚Äôs, O‚Äôs and .‚Äôs for empty squares. Donald Michie used O for the first player. I think most people start with X as does the kaggle_environment I imported. Maybe it‚Äôs a British thing as they call it noughts and crosses. It doesn‚Äôt matter much. I just decided to use X for the first player. I went with strings because this would allow me to use them as keys in a Python dictionary to look up the state of it‚Äôs corresponding matchbox.\nFor each game grid we need to be able to get a list of possible moves. The following function takes a string and returns a list of moves. It makes sure to remove any duplicate moves by rotating and mirroring the game grid and checking for equivalent moves.\n\ndef get_unique_moves(state):\n    moves = list(range(9))\n    unique_moves = [i for i, v in enumerate(state) if v == '.']\n\n    state_array = np.array(list(state)).reshape((3, 3)) # convert state to a 3x3 array\n    moves_array = np.array(moves).reshape((3, 3)) # convert moves to a 3x3 array\n\n    transformed_state_array = np.copy(state_array)\n    transformed_moves_array = np.copy(moves_array)\n\n    for _ in range(4):\n        transformed_state_array = np.rot90(transformed_state_array)\n        transformed_moves_array = np.rot90(transformed_moves_array)\n        transformed_moves = transformed_moves_array.flatten().tolist()\n        if np.array_equal(transformed_state_array, state_array):\n            for a, b in zip(moves, transformed_moves):\n                if a != b and a in unique_moves and b in unique_moves:\n                    unique_moves.remove(b)\n\n        flipped_state_array = np.flipud(transformed_state_array)\n        flipped_moves_array = np.flipud(transformed_moves_array)\n        flipped_moves = flipped_moves_array.flatten().tolist()\n        if np.array_equal(flipped_state_array, state_array):\n            for a, b in zip(moves, flipped_moves):\n                if a != b and a in unique_moves and b in unique_moves:\n                    unique_moves.remove(b)\n\n    return unique_moves\n\nCalling this function with an empty grid returns three moves: the center, a corner and a side.\n\nprint(get_unique_moves('.........'))\n\n[4, 7, 8]\n\n\nI‚Äôm just using index values to represent moves. Using color names would only complicate things.\nTurn numbers start from 0.\n\ndef get_turn(state):\n    return 9 - state.count('.')\n\nThe check_winner function returns X if the first player has won, O if the second player has won, or None if the game hasn‚Äôt finished yet, or has ended in a draw.\n\ndef check_winner(state):\n    winning_combinations = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8], # rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8], # columns\n        [0, 4, 8], [2, 4, 6] # diagonals\n    ]\n\n    for combination in winning_combinations:\n        if state[combination[0]] == state[combination[1]] == state[combination[2]] != '.':\n            return state[combination[0]] # return the winning symbol (X or O)\n\n    return None # no winner\n\nTo check if a game is actually over, we can call game_over.\n\ndef game_over(state):\n    return check_winner(state) or get_turn(state) == 9\n\nThe get_current_player function returns who‚Äôs turn it is. If it returns None, then the game has already ended.\n\ndef get_current_player(state):\n    if game_over(state):\n        return None\n    if state.count('X') &gt; state.count('O'):\n        return 'O'\n    return 'X'\n\nTo make a move and get the next game grid we call update_game_state and pass the current game grid and a move.\n\ndef update_game_state(state, move):\n    return state[:move] + get_current_player(state) + state[move+1:]"
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#menace-class",
    "href": "posts/thinking-inside-the-matchbox/index.html#menace-class",
    "title": "Thinking Inside the Matchbox",
    "section": "MENACE class",
    "text": "MENACE class\nThe MENACE class encapsulates the logic and functionality of MENACE, including initializing matchboxes, selecting moves, updating matchboxes based on game outcomes, and providing visualizations of the matchboxes.\n\nclass MENACE:\n    def __init__(self, initial_beads = [4,4,3,3,2,2,1,1,1], win_beads=3, lose_beads=-1, tie_beads=1):\n        self.matchboxes = {} # dictionary to store matchboxes and their beads\n        self.initial_beads = initial_beads\n        self.win_beads = win_beads\n        self.lose_beads = lose_beads\n        self.tie_beads = tie_beads\n        self.initialize_matchboxes()\n    \n    def reset(self):\n        self.matchboxes = {}\n        self.initialize_matchboxes()\n    \n    def initialize_matchboxes(self, state='.........'):\n        if game_over(state) or isinstance(self.get_move(state),int):\n            return\n        \n        moves = get_unique_moves(state)\n        \n        beads = [-1] * 9\n        for move in moves:\n            beads[move] = self.initial_beads[get_turn(state)]\n        self.matchboxes[state] = beads\n        \n        for move in moves:\n            next_state = update_game_state(state, move)\n            self.initialize_matchboxes(next_state)\n    \n    def _get_transformed_move(self, transformed_state_array, transformed_moves_array):\n        transformed_state = ''.join(transformed_state_array.flatten().tolist())\n        transformed_moves = transformed_moves_array.flatten().tolist()\n        if transformed_state in self.matchboxes:\n            beads = [0 if v &lt; 0 else v for v in self.matchboxes[transformed_state]]\n            if sum(beads) == 0:\n                beads = [0 if v &lt; 0 else 1 for v in self.matchboxes[transformed_state]]\n            return random.choices(transformed_moves, beads)[0]\n        return None\n    \n    def get_move(self, state):\n        moves = list(range(9))\n        \n        state_array = np.array(list(state)).reshape((3, 3)) # convert state to a 3x3 array\n        moves_array = np.array(moves).reshape((3, 3)) # convert moves to a 3x3 array\n        \n        transformed_state_array = np.copy(state_array)\n        transformed_moves_array = np.copy(moves_array)\n        \n        if isinstance(ret := self._get_transformed_move(transformed_state_array, transformed_moves_array), int):\n            return ret\n        \n        for _ in range(4):\n            transformed_state_array = np.rot90(transformed_state_array)\n            transformed_moves_array = np.rot90(transformed_moves_array)\n            if isinstance(ret := self._get_transformed_move(transformed_state_array, transformed_moves_array), int):\n                return ret\n            \n            flipped_state_array = np.flipud(transformed_state_array)\n            flipped_moves_array = np.flipud(transformed_moves_array)\n            if isinstance(ret := self._get_transformed_move(flipped_state_array, flipped_moves_array), int):\n                return ret\n        \n        return None\n    \n    def _update_transformed_move(self, transformed_state_array, transformed_moves_array, move, winner):\n        transformed_state = ''.join(transformed_state_array.flatten().tolist())\n        transformed_moves = transformed_moves_array.flatten().tolist()\n        if transformed_state in self.matchboxes:\n            beads = self.matchboxes[transformed_state]\n            if beads[transformed_moves.index(move)] &gt; -1:\n                # update beads\n                if get_current_player(transformed_state) == winner:\n                    beads[transformed_moves.index(move)] += self.win_beads\n                elif winner is None:\n                    beads[transformed_moves.index(move)] += self.tie_beads\n                else:\n                    beads[transformed_moves.index(move)] += self.lose_beads\n                if beads[transformed_moves.index(move)] &lt; 0:\n                    beads[transformed_moves.index(move)] = 0\n                return True\n        return False\n    \n    def update_matchbox(self, state, move, winner):\n        moves = list(range(9))\n        \n        state_array = np.array(list(state)).reshape((3, 3)) # convert state to a 3x3 array\n        moves_array = np.array(moves).reshape((3, 3)) # convert moves to a 3x3 array\n        \n        transformed_state_array = np.copy(state_array)\n        transformed_moves_array = np.copy(moves_array)\n        \n        if self._update_transformed_move(transformed_state_array, transformed_moves_array, move, winner):\n            return\n        \n        for _ in range(4):\n            transformed_state_array = np.rot90(transformed_state_array)\n            transformed_moves_array = np.rot90(transformed_moves_array)\n            if self._update_transformed_move(transformed_state_array, transformed_moves_array, move, winner):\n                return\n            \n            flipped_state_array = np.flipud(transformed_state_array)\n            flipped_moves_array = np.flipud(transformed_moves_array)\n            if self._update_transformed_move(flipped_state_array, flipped_moves_array, move, winner):\n                return\n    \n    def plot_matchbox(self, state, ax):\n        beads = np.array(self.matchboxes[state]).reshape((3,3))\n        board = np.array(list(state)).reshape((3, 3))\n\n        ax.imshow(beads, cmap='Oranges', vmin=0)\n        ax.set_xticks([-0.5,0.5,1.5,2.5], labels='')\n        ax.set_yticks([-0.5,0.5,1.5,2.5], labels='')\n        ax.xaxis.set_ticks_position('none')\n        ax.yaxis.set_ticks_position('none')\n        ax.grid(True, color='black', linewidth=1)\n\n        for i in range(3):\n            for j in range(3):\n                if board[i, j] == 'X':\n                    ax.plot([j-0.4,j+0.4],[i-0.4,i+0.4], color='black')\n                    ax.plot([j+0.4,j-0.4],[i-0.4,i+0.4], color='black')\n                elif board[i, j] == 'O':\n                    ax.add_artist(plt.Circle((j, i), 0.4, fill=False, color='black'))\n                elif beads[i, j] &gt; -1:\n                    ax.text(j, i, str(beads[i, j]), ha='center', va='center', color='white')\n\n    def plot_matchboxes(self, player='X'):\n        if player=='X':\n            cols = 16\n            states = sorted([k for k in self.matchboxes.keys() if get_turn(k) % 2 == 0 and get_turn(k) &lt; 7], key=lambda v: get_turn(v))\n            rows = ceil(len(states) / cols)\n            fig, axs = plt.subplots(rows, cols, figsize=(cols,rows), gridspec_kw = {'wspace':0.1, 'hspace':0.1})\n        else:\n            cols = 17\n            states = sorted([k for k in self.matchboxes.keys() if get_turn(k) % 2 != 0], key=lambda v: get_turn(v))\n            rows = ceil(len(states) / cols)\n            fig, axs = plt.subplots(rows, cols, figsize=(cols,rows), gridspec_kw = {'wspace':0.1, 'hspace':0.1})\n        \n        fig.subplots_adjust(top=0.96)\n        fig.suptitle(f\"The {len(states)} matchboxes that make up player {player}\", fontsize=16)\n        for r in range(rows):\n            for c in range(cols):\n                self.plot_matchbox(states[r*cols+c], axs[r, c])\n\nThe class has an initialization method that takes in parameters such as the initial number of beads for each matchbox per turn, and the change in beads for a win, a loss, and a draw. It also sets up the matchboxes dictionary that is used to store the state for each matchbox as a list.\nIt calls the initialize_matchboxes method recursively creates and initializes matchboxes for all possible (but unique) grid configurations. It considers valid moves and assigns the corresponding number of beads based on the initial configuration parameters.\nIt might be interesting to experiment with the number of beads to add and remove after each win, loss, or draw. For now, we‚Äôll just go with the defaults that were also used in the original MENACE and instantiate the class.\n\nmenace = MENACE()\n\nAfter all matchboxes are initialized we can visualize their state.\n\nmenace.plot_matchboxes('X')\nplt.show()\n\n\n\n\n\n\n\n\nNote how each game grid shows the number of beads corresponding to each move. Each game grid is actually a little heatmap where a darker orange means the move corresponding to that square is more likely to be selected. For now all grids have the same intensity. This will change once we start training MENACE.\nAs mentioned above, this Python implementation also includes all the matchboxes for the second player. You can visualize those by replacing the X by an O in the call to plot_matchboxes."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#training-menace",
    "href": "posts/thinking-inside-the-matchbox/index.html#training-menace",
    "title": "Thinking Inside the Matchbox",
    "section": "Training MENACE",
    "text": "Training MENACE\nWe can train MENACE against itself or other agents. It makes sense to implement an agent as a function that takes in a game grid and returns a move.\nWe can easily define an agent that makes random moves.\n\n# makes a random move\ndef random_agent(state):\n    return random.choice([i for i, v in enumerate(state) if v == '.'])\n\nOr we define an agent that moves in the first available empty square.\n\n# move in the first available position\ndef first_agent(state):\n    return [i for i, v in enumerate(state) if v == '.'][0]\n\nWe can use the following function that returns an agent that uses the menace object we instantiated above.\n\n# returns an agent that get's a move from MENACE\ndef get_menace_agent(m):\n    def menace_agent(state):\n        return m.get_move(state)    \n    return menace_agent\n\nThe following function takes in a MENACE object, and two agents and lets them play a game against each other. The function keeps track of which moves were made and after the game ends it calls the update_matchbox method in the MENACE object to update the number of beads.\n\ndef play_game(menace, agent1, agent2):\n    state = \".........\" # initial game state\n    moves = [] # list to store moves\n    players = [agent1, agent2]\n    \n    for i in range(9):\n        move = players[i%2](state) # get move\n        moves.append((state, move)) # record the move\n\n        # update game state and check for a winner or draw\n        state = update_game_state(state, move)\n        if game_over(state):\n            break\n\n    winner = check_winner(state)\n    \n    # update matchboxes based on the game outcome\n    for state, move in moves:\n        menace.update_matchbox(state, move, winner)\n    \n    return winner\n\nNote how this function calls update_matchbox for moves made by either agent. This gives us a lot of flexibility. For instance, we could invoke play_game with a MENACE instance and two random agents. The two random agents would play against each other and MENACE would be able to learn from their moves.\n\nTraining MENACE against a random player\nFor now, let‚Äôs have MENACE go first (agent1) and have it play against a random player (agent2). We let it play for 10000 rounds.\n\n# Train MENACE\nnum_games = 10000 # number of games to play for training\ngame_results = []\n\nagent1 = get_menace_agent(menace)\nagent2 = random_agent\n\nfor i in range(num_games):\n    winner = play_game(menace, agent1, agent2)\n    game_results.append((i, winner))\n\nThe outcome of each game is appended to the game_results list that we can use later to visualize how well it‚Äôs learning.\nLet‚Äôs look at the state of each matchbox after these 10000 rounds.\n\nmenace.plot_matchboxes('X')\nplt.show()\n\n\n\n\n\n\n\n\nThe following function creates an animation that shows the cumulative count for each outcome after each round.\n\ndef wins_and_ties_animation(game_results):\n    frames = 1000 if len(game_results) &gt; 1000 else len(game_results)\n    step_size = 1 if len(game_results) &lt;= 1000 else int(len(game_results) / 1000)\n    \n    fig, ax = plt.subplots()\n\n    max_y = max(\n        sum(1 for _, winner in game_results if winner == 'X'),\n        sum(1 for _, winner in game_results if winner == 'O'),\n        sum(1 for _, winner in game_results if winner is None)\n    )\n\n    def update(frame):\n        data = game_results[:(frame+1)*step_size]\n        cumulative_wins_X = sum(1 for _, winner in data if winner == 'X')\n        cumulative_wins_O = sum(1 for _, winner in data if winner == 'O')\n        cumulative_ties = sum(1 for _, winner in data if winner is None)\n        ax.clear()\n        ax.set_ylim(0, max_y)\n        ax.bar(['X', 'O', 'Ties'], [cumulative_wins_X, cumulative_wins_O, cumulative_ties])\n        ax.set_ylabel('Cumulative Wins')\n        ax.set_title('Cumulative Wins and Ties')\n\n    plt.close()\n\n    anim = animation.FuncAnimation(fig, update, frames=frames, interval=10)\n    \n    return anim\n\nLet‚Äôs see what it looks like for 10000 games of MENACE going first against a random player.\n\nanim = wins_and_ties_animation(game_results)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nAlmost instantly the number of wins for X shoots up. The animation mostly illustrates the advantage of going first. The first player has an extra move and more opportunities to achieve a winning combination of three in a row.\n\n\nTraining MENACE against itself\nLet‚Äôs see what happens if we let MENACE play against itself.\n\n# Train MENACE against MENACE\nmenace.reset()\n\nnum_games = 10000 # number of games to play for training\ngame_results = []\n\nagent1 = get_menace_agent(menace)\nagent2 = get_menace_agent(menace)\n\nfor i in range(num_games):\n    winner = play_game(menace, agent1, agent2)\n    game_results.append((i, winner))\n\nWe reset the state of all matchboxes and play another 10000 games.\n\nanim = wins_and_ties_animation(game_results)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nThis time, initially, the first player wins more often, but after a few hundred rounds the majority of games end in a draw.\nLet‚Äôs inspect what the matchboxes for the second player looks like.\n\nmenace.plot_matchboxes('O')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nFurther training MENACE against itself\nWe can let MENACE train for a while longer so it hopefully improves even more.\n\nnum_games = 50000 # number of additional games to play for training\n\nfor _ in range(num_games):\n    play_game(menace, agent1, agent2)"
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#animating-a-game",
    "href": "posts/thinking-inside-the-matchbox/index.html#animating-a-game",
    "title": "Thinking Inside the Matchbox",
    "section": "Animating a game",
    "text": "Animating a game\nThe kaggle_environments module that we imported earlier allows us to let two agents play against each other and animate the game. We start by initializing the tic-tac-toe environment.\n\n# setup a Tic-Tac-Toe environment.\nenv = make(\"tictactoe\")\n\nThis environment calls agents with a custom observation object that represents the game grid. Because MENACE expects a game grid to be represented as a string we need to convert this.\n\ndef menace_agent(obs):\n    state = ''.join([['.','X','O'][v] for v in obs.board])\n    return menace.get_move(state)\n\nLet‚Äôs have MENACE play against a random agent.\n\n# run the MENACE agent against a default agent which chooses a \"random\" move.\nenv.run([menace_agent, \"random\"])\n\n# render an html ipython replay of the tictactoe game.\nenv.render(mode=\"ipython\")"
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#some-final-thoughts",
    "href": "posts/thinking-inside-the-matchbox/index.html#some-final-thoughts",
    "title": "Thinking Inside the Matchbox",
    "section": "Some final thoughts",
    "text": "Some final thoughts\nThe agent that MENACE trains against will influence how well it learns to master tic-tac-toe. If it plays against an agent that always makes random moves, it will take a while longer before it learns how to block the opponent from reaching three in a row. These configurations are simply less likely to occur. It will encounter more diverse grid configurations though, which should help it pick up how to take advantage of weaker opponents. On the other hand, training against an agent that plays tic-tac-toe perfectly will make MENACE learn how to force a draw more quickly. However, it won‚Äôt learn how to take advantage of configurations that might arise when dealing with a weaker player. A strategy one could try is to make it first play against a perfect player, and then train it some more against a random player.\nBesides experimenting with the opponent, you could also try experimenting with the number of beads that are used for punishing and rewarding a certain outcome. How should a tie be rewarded if at all? And a win?\nAnother issue to consider is how MENACE deals with the credit assignment problem. The credit assignment problem in reinforcement learning refers to the challenge of assigning credit to the actions that led to a particular outcome. In MENACE, every punishment and reward are uniformly applied to all moves. While it is reasonable to assign reinforcement to the last move since it directly contributed to the outcome, the same may not hold true for earlier moves. MENACE deals at least partly with this problem by starting out with four beads in its first turn, three beads in its second, and so on. This way, removing a bead after a loss has a bigger impact on later turns than it has on earlier ones. It might be worthwhile to experiment with different numbers of starting beads.\nIf you want to experiment with some of these ideas, check out one of the following links:\n  \nHappy reinforcing!"
  },
  {
    "objectID": "posts/no-more-missed-trash-days/index.html",
    "href": "posts/no-more-missed-trash-days/index.html",
    "title": "No More Missed Trash Days",
    "section": "",
    "text": "In my municipality, waste is collected by a company called Omrin. We have different waste collection days for paper and cardboard, compost, chemicals, and other kinds of trash, and the schedule can be a bit tricky to keep track of.\nOmrin offers an app that shows these various waste collection dates, but I didn‚Äôt want to install yet another app for something as simple as knowing when to put out my trash. Instead, I wrote a Python script that pulls the collection dates from an API, saves this data as an ICS file which then gets synced to my Google calendar.\nRead on if your trash is also collected by Omrin and you want to use this script yourself."
  },
  {
    "objectID": "posts/no-more-missed-trash-days/index.html#setting-up-the-script",
    "href": "posts/no-more-missed-trash-days/index.html#setting-up-the-script",
    "title": "No More Missed Trash Days",
    "section": "Setting up the script",
    "text": "Setting up the script\n\nSome assumptions\nI assume you use a UNIX-based operating system like Linux or MacOS. The script itself should work on Windows as well, but setting it up to run periodically might be a bit different. You‚Äôll also need a Dropbox account.\n\n\nDownloading the script\nYou can grab the script from the following GitHub gist:\n\nI saved it as omrin2ics in my ~/bin directory which is in $PATH. The location doesn‚Äôt really matter though.\n\n\nMaking the script executable\nTo make this script as easy to run as possible, I use a tool called uv. uv is becoming quite popular lately because it simplifies the process of managing Python dependencies and environments. It‚Äôs also crazy fast and perfect for simple scripts like these.\nTo use uv we do first need to install it using the instructions on this website.\nAt the top of the script, I included a shebang line along with the dependencies I need. Here‚Äôs how it looks:\n#!/usr/bin/env -S uv run --script\n\n# /// script\n# requires-python = \"&gt;=3.12\"\n# dependencies = [\n#   \"requests\", \n#   \"rsa\", \n#   \"pycryptodome\", \n#   \"icalendar\",\n# ]\n# ///\n\n# The rest of the script ...\nI make sure the script is executable:\nchmod +x omrin2ics\nOnce this is done, I can simply run the script with this single command:\nomrin2ics 8921HA 123 -o ~/Dropbox/Public/omrin.ics\nuv takes care of setting up and initializing the virtual environment each time we run this script.\nThe script itself expects a zip code (which in the Netherlands is always made up of 4 digits and 2 letters), a house number, and the location of where to write the ICS file to. I‚Äôm writing this to my Dropbox folder for reasons that will become clear later. The zip code and house number are obviously just example values, not my actual address. I don‚Äôt want to dox myself.\n\n\nRunning the script periodically with cron\nThe API returns all the waste collection dates a few months in advance, so we need to periodically rerun this script.\nFor this reason, I set up a cron job to automatically run the script every Monday at 3 AM. This way, my calendar stays up to date without me having to think about it. Here‚Äôs the cron job I added:\n0 3 * * 1 bash -lc 'omrin2ics 8921HA 123 -o ~/Dropbox/Public/omrin.ics' &gt; /dev/null 2&gt;&1\n\n\nWhy save the ICS file in Dropbox though?\nBy saving this file in my Dropbox folder, the file is automatically uploaded to the cloud. Dropbox allows us to generate a public link to the ICS file. We need this link to synchronize the file into Google Calendar."
  },
  {
    "objectID": "posts/no-more-missed-trash-days/index.html#syncing-the-ics-file-with-google-calendar",
    "href": "posts/no-more-missed-trash-days/index.html#syncing-the-ics-file-with-google-calendar",
    "title": "No More Missed Trash Days",
    "section": "Syncing the ICS file with Google Calendar",
    "text": "Syncing the ICS file with Google Calendar\nAfter copying the Dropbox link, here‚Äôs how to add the ICS calendar to Google Calendar:\n\nOpen Google Calendar: Open Google Calendar in a web browser. Ensure that you are logged in with your Google account.\nNavigate to ‚ÄúSettings‚Äù: In the top-right corner, click on the gear icon to access the settings menu. From the dropdown, select ‚ÄúSettings.‚Äù\nChoose ‚ÄúAdd Calendar‚Äù: In the settings menu, navigate to the ‚ÄúAdd calendar‚Äù section.\nSelect ‚ÄúFrom URL‚Äù: Within the ‚ÄúAdd calendar‚Äù section, choose the ‚ÄúFrom URL‚Äù option.\nEnter ICS calendar URL: Copy and paste the URL you copied before. The link ends in &dl=0. After pasting you need to change this last 0 to 1.\nClick ‚ÄúAdd Calendar‚Äù: After entering the URL, click the ‚ÄúAdd Calendar‚Äù button. Google Calendar will validate the URL and add the calendar to your account.\nView the calendar: Once added, you should see the new calendar in the left sidebar under ‚ÄúOther calendars.‚Äù You can also change the name of the calendar there."
  },
  {
    "objectID": "posts/no-more-missed-trash-days/index.html#possible-improvement",
    "href": "posts/no-more-missed-trash-days/index.html#possible-improvement",
    "title": "No More Missed Trash Days",
    "section": "Possible improvement",
    "text": "Possible improvement\nA more elegant approach would be hosting the script on a web server, letting Google Calendar sync directly instead of relying on Dropbox and a cron job. However, hosting costs money, so I went with this free solution. Hopefully, Omrin will offer a direct iCal feed somewhere in the future."
  },
  {
    "objectID": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html",
    "href": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html",
    "title": "Run a Terminal in Google Colab (on the Free Tier)",
    "section": "",
    "text": "Google Colab is an awesome service that lets you run Jupyter Notebooks in the cloud. There‚Äôs a free version and some paid plans. Even with the free version, you get some serious compute and can use hardware like GPUs or TPUs.\nIn Jupyter Notebook environments, like Colab, executing shell commands is straightforward. For example, to list the contents of a directory, you can simply type !ls in a code cell and execute it.\nWhile this is fine for short shell commands, there are instances where a full shell environment is more convenient."
  },
  {
    "objectID": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html#a-solution-for-people-who-dont-mind-spending-some-money",
    "href": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html#a-solution-for-people-who-dont-mind-spending-some-money",
    "title": "Run a Terminal in Google Colab (on the Free Tier)",
    "section": "A solution for people who don‚Äôt mind spending some money",
    "text": "A solution for people who don‚Äôt mind spending some money\nIn the bottom left of the Colab interface you can click an icon that should open a terminal to the container running the Colab instance.\n\nSadly, this only works on a paid plan."
  },
  {
    "objectID": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html#a-solution-for-cheapskates-frugal-people",
    "href": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html#a-solution-for-cheapskates-frugal-people",
    "title": "Run a Terminal in Google Colab (on the Free Tier)",
    "section": "A solution for cheapskates frugal people",
    "text": "A solution for cheapskates frugal people\nThe solution I came up with is to install and run Shell in a Box. This tool lets you use command line tools like Bash in a web-based terminal emulator, which you can open in a notebook cell or a separate browser tab.\n\nSetting it up\nSetting this up is a breeze. First, install and run Shell in a Box. Then, make sure you‚Äôve got access to a standard server environment by running unminimize.\n!apt install shellinabox &&gt; /dev/null\n!nohup shellinaboxd --disable-ssl --no-beep --port=8000 --css /etc/shellinabox/options-enabled/00_White\\ On\\ Black.css -s \"/:root:root:/root:/bin/bash -c bash -i\" &&gt; /dev/null &\n!yes | /usr/local/sbin/unminimize &&gt; /dev/null\nRunning unminimize is optional and could be done at a later time as well. Some things, like man pages, won‚Äôt work on a minimized system. For this reason, I like to run it right away for full functionality.\n\n\nOpening a terminal in an iframe\nTo access the terminal within the notebook, run the following code.\nfrom google.colab.output import serve_kernel_port_as_iframe\nserve_kernel_port_as_iframe(8000)\nIt‚Äôll open up a terminal right within the cell‚Äôs output.\n\nThe serve_kernel_port_as_iframe function lets you customize the dimensions of the iframe by providing arguments like width and height.\n\n\nOpening a terminal in a seperate tab\nIf you prefer a separate tab for your terminal, run the following code snippet:\nfrom google.colab.output import serve_kernel_port_as_window\nserve_kernel_port_as_window(8000, anchor_text = \"Open a terminal\")\nIt‚Äôll give you a link to click.\n\nClicking this link will open a terminal in a new browser window.\n\nEach time you click the link, a fresh tab (and terminal) pops up."
  },
  {
    "objectID": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html#some-remarks",
    "href": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html#some-remarks",
    "title": "Run a Terminal in Google Colab (on the Free Tier)",
    "section": "Some remarks",
    "text": "Some remarks\nHere are some things to remember:\n\nIf you don‚Äôt do anything in the notebook, it will timeout. If it does, you‚Äôll need to restart it and reinstall and rerun Shell in a Box. The free plan gives you up to 12 hours of runtime.\nYou can access your files through a shell by mounting your Google Drive. Colab will put your Google Drive under /content/drive/MyDrive.\nSome activities are off-limits on Google Colab. No mining cryptocurrencies or using it for file hosting. It‚Äôs handy to have shell access, but it‚Äôs not a free Linux box in the cloud. Check the FAQ to see what‚Äôs allowed."
  },
  {
    "objectID": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html#want-to-give-it-a-go",
    "href": "posts/run-a-terminal-in-google-colab-on-the-free-tier/index.html#want-to-give-it-a-go",
    "title": "Run a Terminal in Google Colab (on the Free Tier)",
    "section": "Want to give it a go?",
    "text": "Want to give it a go?\nUse this link to try it out."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "",
    "text": "In the scikit-learn machine learning library, the predict method is used to make predictions on new data with a fitted model. This method expects the input data to have the same number of features as the data that the model was trained on. This makes sense for many models, but not necessarily for decision trees. Since decision trees look at one feature at a time, they may only need a subset of all features to make a prediction.\nIf we want to provide solely the features that are actually considered when making a prediction, we will need to traverse a decision tree iteratively.\nTo show you how this works, we‚Äôll fit a decision tree model to a dataset of Guess Who character features. After fitting the model, we can traverse the resulting tree to make a prediction about the character‚Äôs identity."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#wait-how-do-i-play-guess-who-again",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#wait-how-do-i-play-guess-who-again",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Wait, how do I play Guess Who again?",
    "text": "Wait, how do I play Guess Who again?\nIt may have been a while since you played this game, so let‚Äôs start with a refresher.\nIn Guess Who two players try to guess the opponent‚Äôs character by asking yes-no questions. Each player starts the game with a board that includes cartoon images of 24 people and their first names with all the images standing up. Each player selects a card of their choice from a separate pile of cards containing the same 24 images. The objective of the game is to be the first to determine which card one‚Äôs opponent has selected. Players alternate asking various yes-no questions to eliminate candidates, such as:\n\nDoes your person wear a hat?\nDoes your person wear glasses?\nIs your person female?\n\nThe player will then eliminate candidates (based on the opponent‚Äôs response) by flipping those images down until only one is left."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#importing-necessary-libraries-and-loading-the-data",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#importing-necessary-libraries-and-loading-the-data",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Importing necessary libraries and loading the data",
    "text": "Importing necessary libraries and loading the data\nTo begin, we import the necessary libraries.\n\nimport pandas as pd\nimport numpy as np\nimport graphviz\nimport re\n\nfrom ipywidgets import GridspecLayout, HTML, VBox, HBox, Button, Label\nfrom sklearn.tree import DecisionTreeClassifier, export_graphviz\n\nData describing the characters is loaded into a Pandas DataFrame, with the character names located in the final column. Each feature in the DataFrame represents a specific trait, where a value of 1 or 0 indicates the presence or absence of that trait for a particular character.\n\ndf = pd.DataFrame({\n    # hair style\n    'hair_partition': [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0], \n    'curly_hair':     [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],\n    'hat':            [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'bald':           [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n    'long_hair':      [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    # hair color\n    'ginger_hair':    [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'white_hair':     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0],\n    'brown_hair':     [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0],\n    'blond_hair':     [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'black_hair':     [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1],\n    # facial attributes\n    'big_mouth':      [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\n    'big_nose':       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0],\n    'red_cheeks':     [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0],\n    'blue_eyes':      [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n    'sad_looking':    [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    # facial hair\n    'facial_hair':    [1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0],\n    'moustache':      [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0],\n    'beard':          [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n    # other\n    'glasses':        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1],\n    'earrings':      [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'female':         [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    # names\n    'name':           ['alex', 'alfred', 'anita', 'anne', 'bernard', 'bill', 'charles', 'claire', \n                       'david', 'eric', 'frans', 'george', 'herman', 'joe', 'maria', 'max', 'paul', \n                       'peter', 'philip', 'richard', 'robert', 'sam', 'susan', 'tom']\n})\n\nEvery trait is associated with a question. The following dictionary links each trait (or feature) to a valid yes-no question. We will use this dictionary to map feature names to questions.\n\ncolumn_description = {\n    \"hair_partition\": \"Does your character have a visible hair partition?\",\n    \"curly_hair\": \"Does your character have curly hair?\",\n    \"hat\": \"Does your character wear a hat?\",\n    \"bald\": \"Is your character bald?\",\n    \"long_hair\": \"Does your character have long hair?\",\n    \"ginger_hair\": \"Does your character have ginger hair?\",\n    \"white_hair\": \"Does your character have white hair?\",\n    \"brown_hair\": \"Does your character have brown hair?\",\n    \"blond_hair\": \"Does your character have blond hair?\",\n    \"black_hair\": \"Does your character have black hair?\",\n    \"big_mouth\": \"Does your character have a big mouth?\",\n    \"big_nose\": \"Does your character have a big nose?\",\n    \"red_cheeks\": \"Does your character have red cheeks?\",\n    \"blue_eyes\": \"Does your character have blue eyes?\",\n    \"sad_looking\": \"Does your character look sad?\",\n    \"facial_hair\": \"Does your character have facial hair?\",\n    \"moustache\": \"Does your character have a moustache?\",\n    \"beard\": \"Does your character have a beard?\",\n    \"glasses\": \"Does your character wear glasses?\",\n    \"earrings\": \"Does your character wear earrings?\",\n    \"female\": \"Is your character female?\"\n}\n\nI used the traits mentioned in this blog post. At the end of this post, I‚Äôll suggest some more questions you could add."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#fitting-the-decision-tree",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#fitting-the-decision-tree",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Fitting the decision tree",
    "text": "Fitting the decision tree\nFirstly, we select the features and target variable from the DataFrame.\n\nX = df.iloc[:, :-1]\ny = df.iloc[:, -1]\n\nWe create a list feature_names containing the names of all the features in the input dataset. We will use this when visualizing the decision tree.\n\nfeature_names = list(df.columns)[:-1]\n\nBelow we fit the decision tree classifier using the DecisionTreeClassifier class. We specify the criterion for splitting nodes as entropy. The default is gini but entropy yields a slightly more optimal tree in this case.\n\nclf = DecisionTreeClassifier(criterion = \"entropy\")\nclf = clf.fit(X, y)"
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#visualizing-the-decision-tree",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#visualizing-the-decision-tree",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Visualizing the decision tree",
    "text": "Visualizing the decision tree\nThe depth of the tree tells us how many questions we need to ask at most. Ideally, you would want to do a binary search by splitting the number of possible characters in half with each question. By asking questions that split the number of remaining characters into two equal groups, you‚Äôd need only 4 or 5 questions at most.\nLet‚Äôs see how we do with the set of questions we defined above.\n\nclf.get_depth()\n\n6\n\n\nThe tree has a depth of 6. This means we need to ask 6 questions at most to guess the opponent‚Äôs characters if we use this decision tree. Let‚Äôs see what the tree looks like.\nIf we plot the tree graphically using sklearn.tree.plot_tree the result is illegible. A better way is to use the Graphviz format. The export_graphviz function returns a DOT string which is the abstract language used by Graphviz to describe nodes, edges, graphs, subgraphs etc.\n\ndot_data = export_graphviz(clf, out_file=None, feature_names=feature_names, \n    rotate=True, class_names=y, filled=True, rounded=True, \n    leaves_parallel=True, impurity=False, special_characters=True)\n\nWe can make the tree more compact by removing superfluous content from the nodes.\n\ndot_data = re.sub(\"=&lt;samples = .*class = \", \"=&lt;\", dot_data)\ndot_data = re.sub(\" &le; 0.5.*&gt;, fillcolor\", \"&gt;, fillcolor\", dot_data)\ndot_data = re.sub('labeldistance.*headlabel=\"True\"', 'label=\"NO\"', dot_data)\ndot_data = re.sub('labeldistance.*headlabel=\"False\"', 'label=\"YES\"', dot_data)\ndot_data = re.sub('ranksep=.*,', 'ranksep=0.02', dot_data)\n\nFinally we display the tree.\n\ngraph = graphviz.Source(dot_data)\ngraph\n\n\n\n\n\n\n\n\nWe can see that most characters can be guessed in 4 or 5 moves. Only two characters need a 6th question."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#traversing-the-decision-tree",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#traversing-the-decision-tree",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Traversing the decision tree",
    "text": "Traversing the decision tree\nWe can traverse the decision tree programmatically using the tree_ attribute of the trained clf object. The tree_ attribute is an instance of the sklearn.tree._tree.Tree class, which represents the decision tree as a binary tree of nodes.\nThe Tree class has several attributes and methods that can be used to traverse the tree, including:\n\nnode_count: the total number of nodes in the tree.\nfeature: an array of length node_count containing the feature index at each node, or -2 for leaf nodes.\nthreshold: an array of length node_count containing the threshold value at each split node, or -2 for leaf nodes. In our case the threshold value will always be 0.5 because all our features are either 0 or 1.\nvalue: an array of shape (node_count, n_outputs, n_classes) containing the class distribution at each leaf node.\nchildren_left: an array of length node_count containing the index of the left child node for each split node, or -1 for leaf nodes.\nchildren_right: an array of length node_count containing the index of the right child node for each split node, or -1 for leaf nodes.\n\nTo traverse the decision tree, we start at the root node (index 0) and recursively traverse the left or right child nodes depending on the feature value.\nThe following function traverses the tree and queries the user at each (non-leaf) node it encounters. It uses the column_description dictionary that we‚Äôve defined above to match feature names to questions.\n\ndef play_game(node_id=0):\n    if clf.tree_.children_left[node_id] == -1:\n        # leaf node\n        print(f\"Your character is: {clf.classes_[clf.tree_.value[node_id].argmax()].capitalize()}\")\n    else:\n        feature = clf.feature_names_in_[clf.tree_.feature[node_id]]\n        threshold = clf.tree_.threshold[node_id]\n\n        while (ans := input(f\"{column_description[feature]} (Y/N): \").lower()) not in ['y', 'n']:\n            pass\n        \n        val = 0 if ans == 'n' else 1\n        if val &lt;= threshold:\n            # it's a 'no', so traverse left subtree\n            play_game(clf.tree_.children_left[node_id])\n        else:\n            # traverse right subtree\n            play_game(clf.tree_.children_right[node_id])\n\nBy calling this function, we recursively traverse the decision tree starting from the root node (index 0), checking the feature value of the input instance at each split node and following the left or right child node accordingly, until a leaf node is reached. At the leaf node, the function prints the predicted class label by finding the index of the largest class probability in the value array of the leaf node, which corresponds to the predicted class label (the name of the character)."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#creating-a-fancy-gui-with-ipywidgets",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#creating-a-fancy-gui-with-ipywidgets",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Creating a fancy GUI with ipywidgets",
    "text": "Creating a fancy GUI with ipywidgets\nWe can create a way fancier GUI using Jupyter widgets, and render it using Voila to create an interactive web app. We‚Äôll display the pictures of the characters that we will flip down while traversing the tree. The images were taken from this website.\nWe use the following features of the tree_ attribute.\n\nchildren_left = clf.tree_.children_left\nchildren_right = clf.tree_.children_right\nfeature = clf.tree_.feature\nvalue = clf.tree_.value\n\nThe next part sets up the grid using GridspecLayout with 3 rows and 8 columns. Each cell in the grid contains an HTML element with an image of a character loaded from the website mentioned above.\nThe code also creates a label and three buttons using the Label and Button classes, and arranges them in a horizontal box (HBox). The label displays the current question or the final answer, and the buttons allow the user to answer yes or no to a question, and restart the game. These widgets are then arranged in a vertical box (VBox) along with the grid.\n\ngrid = GridspecLayout(3, 8)\ngrid.width = \"1120\"\n\nfor i in range(3):\n    for j in range(8):\n        grid[i, j] = HTML(value=\"&lt;img src='https://www.aswinvanwoudenberg.com/posts/traversing-a-decision-tree-to-win-at-guess-who/{}.jpeg' width=130 height=190&gt;\".format(str(df.name[i*8+j])))\n\nlabel = Label(value=\"Put the questions and answer here\")\nbutton_yes = Button(description=\"Yes\")\nbutton_no = Button(description=\"No\")\nbutton_play_again = Button(description=\"Play again\")\nhbox = HBox([label, button_yes, button_no, button_play_again])\nvbox = VBox([grid, hbox])\n\nThe root node of the tree will have an id of 0 which is where we start out search.\n\n# Start at root\nnode_id = 0\n\nThe functions below are for updating the GUI based on user interactions:\n\nupdate_gui() updates the label and buttons based on the current node in a decision tree model used for the game. If the current node is a leaf node, meaning it represents a final answer, the label displays the character‚Äôs name and the ‚ÄúYes‚Äù and ‚ÄúNo‚Äù buttons are hidden while the ‚ÄúPlay Again‚Äù button is shown. If the current node is a branch node, the label displays the current question, and the ‚ÄúYes‚Äù and ‚ÄúNo‚Äù buttons are shown while the ‚ÄúPlay Again‚Äù button is hidden.\nshow_all_cards() makes all cards visible in the grid.\nhide_cards(attribute, val) hides cards in the grid that have a particular attribute with a given value.\non_button_yes_clicked(b), on_button_no_clicked(b), and on_button_play_again_clicked(b) are callback functions that are executed when the ‚ÄúYes‚Äù, ‚ÄúNo‚Äù, or ‚ÄúPlay Again‚Äù button is clicked, respectively. These functions update the node_id variable that tracks the current node in the decision tree model and call update_gui() to update the GUI based on the new node.\n\n\ndef update_gui():\n    if children_left[node_id] == children_right[node_id]:\n        label.value = \"You character is \" + y[np.argmax(value[node_id])].capitalize()\n        button_yes.layout.display = 'none'\n        button_no.layout.display = 'none'\n        button_play_again.layout.display = 'block'\n    else:\n        label.value = column_description[df.columns[feature[node_id]]]\n        button_yes.layout.display = 'block'\n        button_no.layout.display = 'block'\n        button_play_again.layout.display = 'none'\n\ndef show_all_cards():\n    for i in range(3):\n        for j in range(8):\n            grid[i, j].layout.visibility = 'visible'\n\ndef hide_cards(attribute, val):\n    for i in range(3):\n        for j in range(8):\n            if df[attribute][i*8+j] == val:\n                grid[i, j].layout.visibility = 'hidden'\n        \ndef on_button_yes_clicked(b):\n    global node_id\n    hide_cards(df.columns[feature[node_id]], 0)\n    node_id = children_right[node_id]\n    update_gui()\n\ndef on_button_no_clicked(b):\n    global node_id\n    hide_cards(df.columns[feature[node_id]], 1)\n    node_id = children_left[node_id]\n    update_gui()\n\ndef on_button_play_again_clicked(b):\n    global node_id\n    show_all_cards()\n    node_id = 0\n    update_gui()\n    \nbutton_yes.on_click(on_button_yes_clicked)\nbutton_no.on_click(on_button_no_clicked)\nbutton_play_again.on_click(on_button_play_again_clicked)\n\nupdate_gui()\n\nFinally, the GUI is displayed using the display() function.\n\ndisplay(vbox)\n\n\n\n\nUse one of the following links to play with an interactive version:"
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#ok-cool-but-how-do-i-win-at-guess-who",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#ok-cool-but-how-do-i-win-at-guess-who",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "OK, cool, but how do I win at Guess Who?",
    "text": "OK, cool, but how do I win at Guess Who?\nNow you know how to fit and traverse a decision tree. Let‚Äôs see how we can improve the decision tree.\nOur decision tree above has a depth of 6 which seems decent, but as I mentioned, we can do better. In order to guess our opponent‚Äôs character with the least number of attempts, we want to pose questions that halve the number of potential characters each turn. By employing this tactic, we can quickly narrow down the options from 24 people to 12, then 6, 3, and eventually just 1 or 2 remaining. This approach enables us to guess the character within a maximum of 4 or 5 turns.\nThe game has deliberately been designed so that obvious traits, like if the person is female, or if the person has a moustache, applies to 5 characters at most. This makes even splits challenging. Two strategies that are mentioned in various places are the letter strategy and the compound questions strategy.\n\nLetter strategy\nThe letter strategy is a simple yet effective approach. It works by asking questions that revolve around the starting letter of each character‚Äôs name and focusing on the middle starting letter of the remaining characters. For instance, asking as a first question if the person‚Äôs name starts with the letters A-G would eliminate half the characters. If the person‚Äôs name does indeed start with one of the letters A-G, a follow-up question might be whether the person‚Äôs name starts with the letters A-B, and so on.\n\n\nCompound questions strategy\nAnother approach is the compound questions strategy. Rather than asking about a single characteristic at a time, you can ask about two or more characteristics simultaneously. For example, instead of asking ‚ÄúDoes your person have white hair?‚Äù, you could ask ‚ÄúDoes your person have white hair OR black hair?‚Äù. The facial hair trait used above is an example of such a compound question as it asks whether the character has a beard OR a moustache."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#conclusion",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#conclusion",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Conclusion",
    "text": "Conclusion\nWe have seen how a fitted decision tree can be traversed iteratively.\nBy adding new questions based on the letter and compound questions strategies to the DataFrame above you should be able to reduce the depth of the decision tree to five.\nSo there you have it, you now have all the tools to dominate (and drain all the fun out of) your Guess Who games.\nGood luck and happy guessing!"
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html",
    "href": "posts/pictionary-air-mouse/index.html",
    "title": "Pictionary Air Mouse",
    "section": "",
    "text": "Pictionary Air is a modern take on the classic Pictionary game in which players draw in the air with an electronic pen instead of on paper. Using a special AR app on a smartphone or tablet teammates can see what is being drawn.\nI wanted to use the Pictionary Air pen with my laptop instead of my phone so I could play Pictionary on a larger screen, or use the pen as an alternative input device.\nRead on to learn how I did this."
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html#the-general-approach",
    "href": "posts/pictionary-air-mouse/index.html#the-general-approach",
    "title": "Pictionary Air Mouse",
    "section": "The general approach",
    "text": "The general approach\nThe Pictionary Air pen has a tip that can light up green or red. If you turn on the pen it lights up red. Pressing a button on the pen, turns the tip green, effectively putting it in drawing mode. To detect the position and color of the tip, we can use the webcam to capture real-time video and process it with OpenCV. We can apply color masking to isolate the red and green colors used by the pen.\nTo do color masking, we use OpenCV‚Äôs inRange() function to create a binary mask for each color we want to detect. The function takes a single frame and a range of colors we want to include in our mask. This range is specified as a lower and upper color threshold, which helps us include only pixels with values within a specified range. Pixels outside of this range are set to black in the mask, while pixels inside the range are set to white.\nFor instance, to create a mask that match all green pixels, we would write:\n# convert a frame to HSV color space\nhsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n\n# setting the lower and upper range for mask_green\nlower_green = np.array([55, 40, 40])\nupper_green = np.array([95, 255, 255])\nmask_green = cv2.inRange(hsv, lower_green, upper_green)\nNote that in this code, we first convert a camera frame (which is, by default, in BGR color space) to HSV color space. Using HSV color space makes creating a mask easier because HSV separates color information from brightness information.\nOnce we have our masks, we use the findContours() function to detect any contours in the binary images. Contours are the boundaries of objects with similar color or intensity values, so we can use them to locate the tip of the Pictionary Air pen. The function returns a list of contours, and we use the contourArea() function to find the contour with the largest area, which is likely to be the pen‚Äôs tip.\ncontours, _ = cv2.findContours(mask_green.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n# if the contours are formed\nif len(contours) &gt; 0:\n    # find the largest contour \n    contour = sorted(contours, key = cv2.contourArea, reverse = True)[0] \nAfter locating the pen‚Äôs tip, we can calculate its position and move the mouse pointer to the corresponding location on the screen. Additionally, we simulate a left-click by pressing and releasing the left mouse button when a green tip is detected and lost, respectively.\n    # get the radius and position of the enclosing circle\n    ((x, y), _) = cv2.minEnclosingCircle(contour)\n    x, y = int(x), int(y)\n\n    # move the mouse\n    mouse.position = (int(x * factor_x), int(y * factor_y))\n    # press the button is not pressed already\n    if not pressed:\n        pressed = True\n        mouse.press(Button.left)"
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html#one-slight-hurdle",
    "href": "posts/pictionary-air-mouse/index.html#one-slight-hurdle",
    "title": "Pictionary Air Mouse",
    "section": "One slight hurdle",
    "text": "One slight hurdle\nPlease take a look at the picture, taken through my webcam, of me holding a Pictionary Air pen:\n\nIs there anything that stands out to you? Is it my handsome face, my wrinkled shirt, or my messy bookcase?\nNotice the tip of the pen. Can you tell its color? It‚Äôs impossible to discern because bright light sources appear as white when seen through my laptop‚Äôs webcam. Unfortunately, this creates an issue since we need to accurately detect whether the pen‚Äôs tip is red or green."
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html#a-simple-solution",
    "href": "posts/pictionary-air-mouse/index.html#a-simple-solution",
    "title": "Pictionary Air Mouse",
    "section": "A simple solution",
    "text": "A simple solution\nThe solution is luckily quite simple. We just shorten the exposure time of the webcam.\nFor this, we can use the v4l2-ctl Linux command line tool.\nv4l2-ctl -c auto_exposure=1 -c exposure_dynamic_framerate=0 -c exposure_time_absolute=10\nThe picture now looks like this:\n\nAfter adjusting the exposure time, we can clearly see the color of the tip of the pen. Pressing the button on the pen turns its tip green.\n\nNow we can easily detect the position and color of the pen using the approach explained above. Additionally, shortening the exposure time hides irrelevant objects, such as my red shirt, that could throw off the detection algorithm."
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html#see-it-in-action",
    "href": "posts/pictionary-air-mouse/index.html#see-it-in-action",
    "title": "Pictionary Air Mouse",
    "section": "See it in action",
    "text": "See it in action\nCheck out the video below to see it in action.\n\nFor the complete program check out this repository. You don‚Äôt need to first adjust the exposure time before running the program. The Python program calls v4l2-ctl for you.\nThis program runs fine on my laptop, but you likely need to adjust webcam settings to make it work for you. Also, you need to run Linux. If this program doesn‚Äôt seem to function, try experimenting with the parameters in the calls that are made to the v4l2-ctl tool in the set_short_exposure_time and restore_camera_settings functions.\nEnter v4l2-ctl --all on the command line to see the available options."
  },
  {
    "objectID": "posts/who-owns-the-zebra/index.html",
    "href": "posts/who-owns-the-zebra/index.html",
    "title": "Who Owns the Zebra",
    "section": "",
    "text": "On December 17, 1962, Life International magazine published the following puzzle:\nThis puzzle is said to be invented by Einstein and therefore sometimes referred to as Einstein‚Äôs puzzle or Einstein‚Äôs riddle. Supposedly, he also claimed that only 2% of the world‚Äôs population would be smart enough to solve it. For neither claim is there any evidence."
  },
  {
    "objectID": "posts/who-owns-the-zebra/index.html#solving-the-puzzle-using-prolog",
    "href": "posts/who-owns-the-zebra/index.html#solving-the-puzzle-using-prolog",
    "title": "Who Owns the Zebra",
    "section": "Solving the puzzle using Prolog",
    "text": "Solving the puzzle using Prolog\nAs an example of how to solve these kinds of logic puzzles using Prolog, I wrote this code:\n\n\neinstein.pl\n\n% A Prolog solver for the Zebra puzzle a.k.a. Einstein's riddle.\n% https://en.wikipedia.org/wiki/Zebra_Puzzle\n\neinstein :-\n    einstein(Solution),\n    write_sol(Solution).\n\neinstein(Sol) :-\n    Sol = [ \n        [1,N1,C1,P1,D1,S1],                             % There are five houses.\n        [2,N2,C2,P2,D2,S2],\n        [3,N3,C3,P3,D3,S3],\n        [4,N4,C4,P4,D4,S4],\n        [5,N5,C5,P5,D5,S5]],\n    member([_,englishman,red,_,_,_],Sol),               % The Englishman lives in the red house.\n    member([_,spaniard,_,dog,_,_],Sol),                 % The Spaniard owns the dog.\n    member([_,_,green,_,coffee,_],Sol),                 % Coffee is drunk in the green house.\n    member([_,ukrainian,_,_,tea,_],Sol),                % The Ukrainian drinks tea.\n    member([GH,_,green,_,_,_],Sol),                     % The green house is immediately to the right of the ivory house.\n    member([IH,_,ivory,_,_,_],Sol),\n    GH =:= IH + 1,\n    member([_,_,_,snails,_,old_gold],Sol),              % The Old Gold smoker owns snails.\n    member([_,_,yellow,_,_,kools],Sol),                 % Kools are smoked in the yellow house.\n    member([3,_,_,_,milk,_],Sol),                       % Milk is drunk in the middle house.\n    member([1,norwegian,_,_,_,_],Sol),                  % The Norwegian lives in the first house.\n    member([BH,_,_,_,_,chesterfields],Sol),             % The man who smokes Chesterfields lives in the house next to the man with the fox.\n    member([CH,_,_,fox,_,_],Sol),\n    next_to(BH,CH),\n    member([DH,_,_,_,_,kools],Sol),                     % Kools are smoked in the house next to the house where the horse is kept.\n    member([HH,_,_,horse,_,_],Sol),\n    next_to(DH,HH),\n    member([_,_,_,_,orange_juice,lucky_strike],Sol),    % The Lucky Strike smoker drinks organge juice.\n    member([_,japanese,_,_,_,parliaments],Sol),         % The Japanese smokes Parliaments\n    member([NH,norwegian,_,_,_,_],Sol),                 % The Norwegian lives next to the blue house.\n    member([BlH,_,blue,_,_,_],Sol),\n    next_to(NH,BlH),\n    permutation([englishman,spaniard,ukrainian,japanese,norwegian],[N1,N2,N3,N4,N5]),\n    permutation([green,ivory,yellow,blue,red],[C1,C2,C3,C4,C5]),\n    permutation([dog,snails,fox,horse,zebra],[P1,P2,P3,P4,P5]),\n    permutation([coffee,tea,milk,orange_juice,water],[D1,D2,D3,D4,D5]),\n    permutation([old_gold,kools,chesterfields,lucky_strike,parliaments],[S1,S2,S3,S4,S5]).\n\nnext_to(A,B) :- A =:= B - 1.\nnext_to(A,B) :- A =:= B + 1.\n\nwrite_sol(Solution) :-\n    write('+--+------------+------------+------------+-------------+--------------+'),nl,\n    maplist(writef('|%2L|%12L|%12L|%12L|%13L|%14L|\\n'),Solution),\n    write('+--+------------+------------+------------+-------------+--------------+'),nl.\n\nThe program uses a list of lists to represent the houses and applies a set of constraints to determine the correct answer.\nThe einstein/1 predicate defines the structure of the solution as a list of lists called Sol. Each sublist corresponds to a house and contains five variables representing the house number, nationality, color, pet, drink, and cigarette brand.\nThe predicate then uses a set of member/2 and next_to/2 predicates to apply the given clues and constraints to the list of houses. For example, member([_,englishman,red,_,_,_],Sol) specifies that the Englishman lives in the red house, and the predicates member([BH,_,_,_,_,chesterfields],Sol), member([CH,_,_,fox,_,_],Sol), and next_to(BH,CH) specify that the man who smokes Chesterfields lives in the house next to the man with the fox.\nFinally, write_sol/1 outputs the solutions in a formatted table.\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/who-owns-the-zebra/index.html#running-the-solver",
    "href": "posts/who-owns-the-zebra/index.html#running-the-solver",
    "title": "Who Owns the Zebra",
    "section": "Running the solver",
    "text": "Running the solver\nTo run the solver, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the solver by typing:\n[einstein].\nThis loads the einstein.pl file. You can execute the solver which will output the solution to the console:\neinstein.\n+--+------------+------------+------------+-------------+--------------+\n|1 |norwegian   |yellow      |fox         |water        |kools         |\n|2 |ukrainian   |blue        |horse       |tea          |chesterfields |\n|3 |englishman  |red         |snails      |milk         |old_gold      |\n|4 |spaniard    |ivory       |dog         |orange_juice |lucky_strike  |\n|5 |japanese    |green       |zebra       |coffee       |parliaments   |\n+--+------------+------------+------------+-------------+--------------+"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html",
    "href": "posts/draining-the-fun-out-of-wordle/index.html",
    "title": "Draining the Fun Out of Wordle",
    "section": "",
    "text": "Wordle‚Äôs addictive nature has caused it to spread like wildfire, captivating players around the world who find themselves entangled in the pursuit of streaks. It has become a quest for daily victories, a battle against time to maintain unbroken chains of triumphant solves. The desire to conquer the next puzzle and extend those streaks has become an obsession that consumes countless hours of human capital.\nWe‚Äôre witnessing a peculiar phenomenon: a society on the brink of crumbling under the weight of unsolved Wordle puzzles. Productivity is plummeting, deadlines are missed, pets and children are neglected while people fret endlessly over deciphering those elusive five-letter words.\nIn the face of this crisis, I took it upon myself, to save our civilization from its Wordle-induced downfall. The solution was simple: I developed a Wordle solver. Yes, a program designed to expedite the solving process and allow people to return to more important tasks without sacrificing their streaks or sanity.\nI am certain that in a few years from now, I‚Äôll be recognized as the hero of productivity, wielding the power of math and Python to restore balance in the world. Please don‚Äôt make my statue too big, I‚Äôm quite modest.\nRead on if you want to learn about the inner workings of my Wordle solver."
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#how-to-play-wordle",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#how-to-play-wordle",
    "title": "Draining the Fun Out of Wordle",
    "section": "How to play Wordle",
    "text": "How to play Wordle\nIn case you‚Äôre one of the lucky few who hasn‚Äôt been caught by the grip of Wordle‚Äôs addictive tendrils, let‚Äôs go over the rules.\nThe objective is to guess a five-letter mystery word within six attempts. After each guess, you receive feedback in the form of colored boxes. Green boxes indicate correct letters in the right position, while yellow boxes indicate correct letters in the wrong position. Gray boxes mean the word doesn‚Äôt contain this letter.\n\nAfter trying SPOON we know the position of S. We also know that the word must contain an A and a N. The secret word doesn‚Äôt contain any of the letters E, R, I, O, or P.\nThere are four more tries left. Feeling anxious already?"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#the-approach",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#the-approach",
    "title": "Draining the Fun Out of Wordle",
    "section": "The approach",
    "text": "The approach\nI started by writing Python code to produce a decision tree to tackle Wordle games. Each node within the tree suggests a word to try. The branches represent the possible color patterns that Wordle provides as feedback. By navigating this tree, players can solve the daily Wordle puzzles.\nIn this post I‚Äôll first focus on the code for generating the decision tree. Then I‚Äôll presents a user interface built from widgets that enables interactive traversal of this tree."
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#importing-libraries",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#importing-libraries",
    "title": "Draining the Fun Out of Wordle",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing the necessary libraries. Note how we don‚Äôt import any tree models from sklearn as we‚Äôll roll our own.\n\nimport json\n\nimport numpy as np\nimport pandas as pd\nimport ipywidgets as widgets\n\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.feature_selection import mutual_info_classif\nfrom warnings import simplefilter\nfrom collections import deque"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#getting-the-list-of-possible-answers",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#getting-the-list-of-possible-answers",
    "title": "Draining the Fun Out of Wordle",
    "section": "Getting the list of possible answers",
    "text": "Getting the list of possible answers\nThe following list was taken directly from the Wordle JavaScript source code. The source code actually contains two lists. One is the list of possible answers. The second is a list of valid 5-letter words.\nWe‚Äôll only use the first list. This will still allow the decision tree to solve every possible puzzle reasonably efficiently. Tree induction will be much faster this way.\nWe might need to update this list in the future if the New York Times decides to update the possible set of answers. You might also want to update this list if you want to create a decision tree for one of the many Wordle clones.\n\nanswers_list = [\"cigar\",\"rebut\",\"sissy\",\"humph\",\"awake\",\"blush\",\"focal\",\"evade\",\"naval\",\"serve\",\"heath\",\"dwarf\",\"model\",\"karma\",\"stink\",\"grade\",\"quiet\",\"bench\",\"abate\",\"feign\",\"major\",\"death\",\"fresh\",\"crust\",\"stool\",\"colon\",\"abase\",\"marry\",\"react\",\"batty\",\"pride\",\"floss\",\"helix\",\"croak\",\"staff\",\"paper\",\"unfed\",\"whelp\",\"trawl\",\"outdo\",\"adobe\",\"crazy\",\"sower\",\"repay\",\"digit\",\"crate\",\"cluck\",\"spike\",\"mimic\",\"pound\",\"maxim\",\"linen\",\"unmet\",\"flesh\",\"booby\",\"forth\",\"first\",\"stand\",\"belly\",\"ivory\",\"seedy\",\"print\",\"yearn\",\"drain\",\"bribe\",\"stout\",\"panel\",\"crass\",\"flume\",\"offal\",\"agree\",\"error\",\"swirl\",\"argue\",\"bleed\",\"delta\",\"flick\",\"totem\",\"wooer\",\"front\",\"shrub\",\"parry\",\"biome\",\"lapel\",\"start\",\"greet\",\"goner\",\"golem\",\"lusty\",\"loopy\",\"round\",\"audit\",\"lying\",\"gamma\",\"labor\",\"islet\",\"civic\",\"forge\",\"corny\",\"moult\",\"basic\",\"salad\",\"agate\",\"spicy\",\"spray\",\"essay\",\"fjord\",\"spend\",\"kebab\",\"guild\",\"aback\",\"motor\",\"alone\",\"hatch\",\"hyper\",\"thumb\",\"dowry\",\"ought\",\"belch\",\"dutch\",\"pilot\",\"tweed\",\"comet\",\"jaunt\",\"enema\",\"steed\",\"abyss\",\"growl\",\"fling\",\"dozen\",\"boozy\",\"erode\",\"world\",\"gouge\",\"click\",\"briar\",\"great\",\"altar\",\"pulpy\",\"blurt\",\"coast\",\"duchy\",\"groin\",\"fixer\",\"group\",\"rogue\",\"badly\",\"smart\",\"pithy\",\"gaudy\",\"chill\",\"heron\",\"vodka\",\"finer\",\"surer\",\"radio\",\"rouge\",\"perch\",\"retch\",\"wrote\",\"clock\",\"tilde\",\"store\",\"prove\",\"bring\",\"solve\",\"cheat\",\"grime\",\"exult\",\"usher\",\"epoch\",\"triad\",\"break\",\"rhino\",\"viral\",\"conic\",\"masse\",\"sonic\",\"vital\",\"trace\",\"using\",\"peach\",\"champ\",\"baton\",\"brake\",\"pluck\",\"craze\",\"gripe\",\"weary\",\"picky\",\"acute\",\"ferry\",\"aside\",\"tapir\",\"troll\",\"unify\",\"rebus\",\"boost\",\"truss\",\"siege\",\"tiger\",\"banal\",\"slump\",\"crank\",\"gorge\",\"query\",\"drink\",\"favor\",\"abbey\",\"tangy\",\"panic\",\"solar\",\"shire\",\"proxy\",\"point\",\"robot\",\"prick\",\"wince\",\"crimp\",\"knoll\",\"sugar\",\"whack\",\"mount\",\"perky\",\"could\",\"wrung\",\"light\",\"those\",\"moist\",\"shard\",\"pleat\",\"aloft\",\"skill\",\"elder\",\"frame\",\"humor\",\"pause\",\"ulcer\",\"ultra\",\"robin\",\"cynic\",\"aroma\",\"caulk\",\"shake\",\"dodge\",\"swill\",\"tacit\",\"other\",\"thorn\",\"trove\",\"bloke\",\"vivid\",\"spill\",\"chant\",\"choke\",\"rupee\",\"nasty\",\"mourn\",\"ahead\",\"brine\",\"cloth\",\"hoard\",\"sweet\",\"month\",\"lapse\",\"watch\",\"today\",\"focus\",\"smelt\",\"tease\",\"cater\",\"movie\",\"saute\",\"allow\",\"renew\",\"their\",\"slosh\",\"purge\",\"chest\",\"depot\",\"epoxy\",\"nymph\",\"found\",\"shall\",\"harry\",\"stove\",\"lowly\",\"snout\",\"trope\",\"fewer\",\"shawl\",\"natal\",\"comma\",\"foray\",\"scare\",\"stair\",\"black\",\"squad\",\"royal\",\"chunk\",\"mince\",\"shame\",\"cheek\",\"ample\",\"flair\",\"foyer\",\"cargo\",\"oxide\",\"plant\",\"olive\",\"inert\",\"askew\",\"heist\",\"shown\",\"zesty\",\"hasty\",\"trash\",\"fella\",\"larva\",\"forgo\",\"story\",\"hairy\",\"train\",\"homer\",\"badge\",\"midst\",\"canny\",\"fetus\",\"butch\",\"farce\",\"slung\",\"tipsy\",\"metal\",\"yield\",\"delve\",\"being\",\"scour\",\"glass\",\"gamer\",\"scrap\",\"money\",\"hinge\",\"album\",\"vouch\",\"asset\",\"tiara\",\"crept\",\"bayou\",\"atoll\",\"manor\",\"creak\",\"showy\",\"phase\",\"froth\",\"depth\",\"gloom\",\"flood\",\"trait\",\"girth\",\"piety\",\"payer\",\"goose\",\"float\",\"donor\",\"atone\",\"primo\",\"apron\",\"blown\",\"cacao\",\"loser\",\"input\",\"gloat\",\"awful\",\"brink\",\"smite\",\"beady\",\"rusty\",\"retro\",\"droll\",\"gawky\",\"hutch\",\"pinto\",\"gaily\",\"egret\",\"lilac\",\"sever\",\"field\",\"fluff\",\"hydro\",\"flack\",\"agape\",\"voice\",\"stead\",\"stalk\",\"berth\",\"madam\",\"night\",\"bland\",\"liver\",\"wedge\",\"augur\",\"roomy\",\"wacky\",\"flock\",\"angry\",\"bobby\",\"trite\",\"aphid\",\"tryst\",\"midge\",\"power\",\"elope\",\"cinch\",\"motto\",\"stomp\",\"upset\",\"bluff\",\"cramp\",\"quart\",\"coyly\",\"youth\",\"rhyme\",\"buggy\",\"alien\",\"smear\",\"unfit\",\"patty\",\"cling\",\"glean\",\"label\",\"hunky\",\"khaki\",\"poker\",\"gruel\",\"twice\",\"twang\",\"shrug\",\"treat\",\"unlit\",\"waste\",\"merit\",\"woven\",\"octal\",\"needy\",\"clown\",\"widow\",\"irony\",\"ruder\",\"gauze\",\"chief\",\"onset\",\"prize\",\"fungi\",\"charm\",\"gully\",\"inter\",\"whoop\",\"taunt\",\"leery\",\"class\",\"theme\",\"lofty\",\"tibia\",\"booze\",\"alpha\",\"thyme\",\"eclat\",\"doubt\",\"parer\",\"chute\",\"stick\",\"trice\",\"alike\",\"sooth\",\"recap\",\"saint\",\"liege\",\"glory\",\"grate\",\"admit\",\"brisk\",\"soggy\",\"usurp\",\"scald\",\"scorn\",\"leave\",\"twine\",\"sting\",\"bough\",\"marsh\",\"sloth\",\"dandy\",\"vigor\",\"howdy\",\"enjoy\",\"valid\",\"ionic\",\"equal\",\"unset\",\"floor\",\"catch\",\"spade\",\"stein\",\"exist\",\"quirk\",\"denim\",\"grove\",\"spiel\",\"mummy\",\"fault\",\"foggy\",\"flout\",\"carry\",\"sneak\",\"libel\",\"waltz\",\"aptly\",\"piney\",\"inept\",\"aloud\",\"photo\",\"dream\",\"stale\",\"vomit\",\"ombre\",\"fanny\",\"unite\",\"snarl\",\"baker\",\"there\",\"glyph\",\"pooch\",\"hippy\",\"spell\",\"folly\",\"louse\",\"gulch\",\"vault\",\"godly\",\"threw\",\"fleet\",\"grave\",\"inane\",\"shock\",\"crave\",\"spite\",\"valve\",\"skimp\",\"claim\",\"rainy\",\"musty\",\"pique\",\"daddy\",\"quasi\",\"arise\",\"aging\",\"valet\",\"opium\",\"avert\",\"stuck\",\"recut\",\"mulch\",\"genre\",\"plume\",\"rifle\",\"count\",\"incur\",\"total\",\"wrest\",\"mocha\",\"deter\",\"study\",\"lover\",\"safer\",\"rivet\",\"funny\",\"smoke\",\"mound\",\"undue\",\"sedan\",\"pagan\",\"swine\",\"guile\",\"gusty\",\"equip\",\"tough\",\"canoe\",\"chaos\",\"covet\",\"human\",\"udder\",\"lunch\",\"blast\",\"stray\",\"manga\",\"melee\",\"lefty\",\"quick\",\"paste\",\"given\",\"octet\",\"risen\",\"groan\",\"leaky\",\"grind\",\"carve\",\"loose\",\"sadly\",\"spilt\",\"apple\",\"slack\",\"honey\",\"final\",\"sheen\",\"eerie\",\"minty\",\"slick\",\"derby\",\"wharf\",\"spelt\",\"coach\",\"erupt\",\"singe\",\"price\",\"spawn\",\"fairy\",\"jiffy\",\"filmy\",\"stack\",\"chose\",\"sleep\",\"ardor\",\"nanny\",\"niece\",\"woozy\",\"handy\",\"grace\",\"ditto\",\"stank\",\"cream\",\"usual\",\"diode\",\"valor\",\"angle\",\"ninja\",\"muddy\",\"chase\",\"reply\",\"prone\",\"spoil\",\"heart\",\"shade\",\"diner\",\"arson\",\"onion\",\"sleet\",\"dowel\",\"couch\",\"palsy\",\"bowel\",\"smile\",\"evoke\",\"creek\",\"lance\",\"eagle\",\"idiot\",\"siren\",\"built\",\"embed\",\"award\",\"dross\",\"annul\",\"goody\",\"frown\",\"patio\",\"laden\",\"humid\",\"elite\",\"lymph\",\"edify\",\"might\",\"reset\",\"visit\",\"gusto\",\"purse\",\"vapor\",\"crock\",\"write\",\"sunny\",\"loath\",\"chaff\",\"slide\",\"queer\",\"venom\",\"stamp\",\"sorry\",\"still\",\"acorn\",\"aping\",\"pushy\",\"tamer\",\"hater\",\"mania\",\"awoke\",\"brawn\",\"swift\",\"exile\",\"birch\",\"lucky\",\"freer\",\"risky\",\"ghost\",\"plier\",\"lunar\",\"winch\",\"snare\",\"nurse\",\"house\",\"borax\",\"nicer\",\"lurch\",\"exalt\",\"about\",\"savvy\",\"toxin\",\"tunic\",\"pried\",\"inlay\",\"chump\",\"lanky\",\"cress\",\"eater\",\"elude\",\"cycle\",\"kitty\",\"boule\",\"moron\",\"tenet\",\"place\",\"lobby\",\"plush\",\"vigil\",\"index\",\"blink\",\"clung\",\"qualm\",\"croup\",\"clink\",\"juicy\",\"stage\",\"decay\",\"nerve\",\"flier\",\"shaft\",\"crook\",\"clean\",\"china\",\"ridge\",\"vowel\",\"gnome\",\"snuck\",\"icing\",\"spiny\",\"rigor\",\"snail\",\"flown\",\"rabid\",\"prose\",\"thank\",\"poppy\",\"budge\",\"fiber\",\"moldy\",\"dowdy\",\"kneel\",\"track\",\"caddy\",\"quell\",\"dumpy\",\"paler\",\"swore\",\"rebar\",\"scuba\",\"splat\",\"flyer\",\"horny\",\"mason\",\"doing\",\"ozone\",\"amply\",\"molar\",\"ovary\",\"beset\",\"queue\",\"cliff\",\"magic\",\"truce\",\"sport\",\"fritz\",\"edict\",\"twirl\",\"verse\",\"llama\",\"eaten\",\"range\",\"whisk\",\"hovel\",\"rehab\",\"macaw\",\"sigma\",\"spout\",\"verve\",\"sushi\",\"dying\",\"fetid\",\"brain\",\"buddy\",\"thump\",\"scion\",\"candy\",\"chord\",\"basin\",\"march\",\"crowd\",\"arbor\",\"gayly\",\"musky\",\"stain\",\"dally\",\"bless\",\"bravo\",\"stung\",\"title\",\"ruler\",\"kiosk\",\"blond\",\"ennui\",\"layer\",\"fluid\",\"tatty\",\"score\",\"cutie\",\"zebra\",\"barge\",\"matey\",\"bluer\",\"aider\",\"shook\",\"river\",\"privy\",\"betel\",\"frisk\",\"bongo\",\"begun\",\"azure\",\"weave\",\"genie\",\"sound\",\"glove\",\"braid\",\"scope\",\"wryly\",\"rover\",\"assay\",\"ocean\",\"bloom\",\"irate\",\"later\",\"woken\",\"silky\",\"wreck\",\"dwelt\",\"slate\",\"smack\",\"solid\",\"amaze\",\"hazel\",\"wrist\",\"jolly\",\"globe\",\"flint\",\"rouse\",\"civil\",\"vista\",\"relax\",\"cover\",\"alive\",\"beech\",\"jetty\",\"bliss\",\"vocal\",\"often\",\"dolly\",\"eight\",\"joker\",\"since\",\"event\",\"ensue\",\"shunt\",\"diver\",\"poser\",\"worst\",\"sweep\",\"alley\",\"creed\",\"anime\",\"leafy\",\"bosom\",\"dunce\",\"stare\",\"pudgy\",\"waive\",\"choir\",\"stood\",\"spoke\",\"outgo\",\"delay\",\"bilge\",\"ideal\",\"clasp\",\"seize\",\"hotly\",\"laugh\",\"sieve\",\"block\",\"meant\",\"grape\",\"noose\",\"hardy\",\"shied\",\"drawl\",\"daisy\",\"putty\",\"strut\",\"burnt\",\"tulip\",\"crick\",\"idyll\",\"vixen\",\"furor\",\"geeky\",\"cough\",\"naive\",\"shoal\",\"stork\",\"bathe\",\"aunty\",\"check\",\"prime\",\"brass\",\"outer\",\"furry\",\"razor\",\"elect\",\"evict\",\"imply\",\"demur\",\"quota\",\"haven\",\"cavil\",\"swear\",\"crump\",\"dough\",\"gavel\",\"wagon\",\"salon\",\"nudge\",\"harem\",\"pitch\",\"sworn\",\"pupil\",\"excel\",\"stony\",\"cabin\",\"unzip\",\"queen\",\"trout\",\"polyp\",\"earth\",\"storm\",\"until\",\"taper\",\"enter\",\"child\",\"adopt\",\"minor\",\"fatty\",\"husky\",\"brave\",\"filet\",\"slime\",\"glint\",\"tread\",\"steal\",\"regal\",\"guest\",\"every\",\"murky\",\"share\",\"spore\",\"hoist\",\"buxom\",\"inner\",\"otter\",\"dimly\",\"level\",\"sumac\",\"donut\",\"stilt\",\"arena\",\"sheet\",\"scrub\",\"fancy\",\"slimy\",\"pearl\",\"silly\",\"porch\",\"dingo\",\"sepia\",\"amble\",\"shady\",\"bread\",\"friar\",\"reign\",\"dairy\",\"quill\",\"cross\",\"brood\",\"tuber\",\"shear\",\"posit\",\"blank\",\"villa\",\"shank\",\"piggy\",\"freak\",\"which\",\"among\",\"fecal\",\"shell\",\"would\",\"algae\",\"large\",\"rabbi\",\"agony\",\"amuse\",\"bushy\",\"copse\",\"swoon\",\"knife\",\"pouch\",\"ascot\",\"plane\",\"crown\",\"urban\",\"snide\",\"relay\",\"abide\",\"viola\",\"rajah\",\"straw\",\"dilly\",\"crash\",\"amass\",\"third\",\"trick\",\"tutor\",\"woody\",\"blurb\",\"grief\",\"disco\",\"where\",\"sassy\",\"beach\",\"sauna\",\"comic\",\"clued\",\"creep\",\"caste\",\"graze\",\"snuff\",\"frock\",\"gonad\",\"drunk\",\"prong\",\"lurid\",\"steel\",\"halve\",\"buyer\",\"vinyl\",\"utile\",\"smell\",\"adage\",\"worry\",\"tasty\",\"local\",\"trade\",\"finch\",\"ashen\",\"modal\",\"gaunt\",\"clove\",\"enact\",\"adorn\",\"roast\",\"speck\",\"sheik\",\"missy\",\"grunt\",\"snoop\",\"party\",\"touch\",\"mafia\",\"emcee\",\"array\",\"south\",\"vapid\",\"jelly\",\"skulk\",\"angst\",\"tubal\",\"lower\",\"crest\",\"sweat\",\"cyber\",\"adore\",\"tardy\",\"swami\",\"notch\",\"groom\",\"roach\",\"hitch\",\"young\",\"align\",\"ready\",\"frond\",\"strap\",\"puree\",\"realm\",\"venue\",\"swarm\",\"offer\",\"seven\",\"dryer\",\"diary\",\"dryly\",\"drank\",\"acrid\",\"heady\",\"theta\",\"junto\",\"pixie\",\"quoth\",\"bonus\",\"shalt\",\"penne\",\"amend\",\"datum\",\"build\",\"piano\",\"shelf\",\"lodge\",\"suing\",\"rearm\",\"coral\",\"ramen\",\"worth\",\"psalm\",\"infer\",\"overt\",\"mayor\",\"ovoid\",\"glide\",\"usage\",\"poise\",\"randy\",\"chuck\",\"prank\",\"fishy\",\"tooth\",\"ether\",\"drove\",\"idler\",\"swath\",\"stint\",\"while\",\"begat\",\"apply\",\"slang\",\"tarot\",\"radar\",\"credo\",\"aware\",\"canon\",\"shift\",\"timer\",\"bylaw\",\"serum\",\"three\",\"steak\",\"iliac\",\"shirk\",\"blunt\",\"puppy\",\"penal\",\"joist\",\"bunny\",\"shape\",\"beget\",\"wheel\",\"adept\",\"stunt\",\"stole\",\"topaz\",\"chore\",\"fluke\",\"afoot\",\"bloat\",\"bully\",\"dense\",\"caper\",\"sneer\",\"boxer\",\"jumbo\",\"lunge\",\"space\",\"avail\",\"short\",\"slurp\",\"loyal\",\"flirt\",\"pizza\",\"conch\",\"tempo\",\"droop\",\"plate\",\"bible\",\"plunk\",\"afoul\",\"savoy\",\"steep\",\"agile\",\"stake\",\"dwell\",\"knave\",\"beard\",\"arose\",\"motif\",\"smash\",\"broil\",\"glare\",\"shove\",\"baggy\",\"mammy\",\"swamp\",\"along\",\"rugby\",\"wager\",\"quack\",\"squat\",\"snaky\",\"debit\",\"mange\",\"skate\",\"ninth\",\"joust\",\"tramp\",\"spurn\",\"medal\",\"micro\",\"rebel\",\"flank\",\"learn\",\"nadir\",\"maple\",\"comfy\",\"remit\",\"gruff\",\"ester\",\"least\",\"mogul\",\"fetch\",\"cause\",\"oaken\",\"aglow\",\"meaty\",\"gaffe\",\"shyly\",\"racer\",\"prowl\",\"thief\",\"stern\",\"poesy\",\"rocky\",\"tweet\",\"waist\",\"spire\",\"grope\",\"havoc\",\"patsy\",\"truly\",\"forty\",\"deity\",\"uncle\",\"swish\",\"giver\",\"preen\",\"bevel\",\"lemur\",\"draft\",\"slope\",\"annoy\",\"lingo\",\"bleak\",\"ditty\",\"curly\",\"cedar\",\"dirge\",\"grown\",\"horde\",\"drool\",\"shuck\",\"crypt\",\"cumin\",\"stock\",\"gravy\",\"locus\",\"wider\",\"breed\",\"quite\",\"chafe\",\"cache\",\"blimp\",\"deign\",\"fiend\",\"logic\",\"cheap\",\"elide\",\"rigid\",\"false\",\"renal\",\"pence\",\"rowdy\",\"shoot\",\"blaze\",\"envoy\",\"posse\",\"brief\",\"never\",\"abort\",\"mouse\",\"mucky\",\"sulky\",\"fiery\",\"media\",\"trunk\",\"yeast\",\"clear\",\"skunk\",\"scalp\",\"bitty\",\"cider\",\"koala\",\"duvet\",\"segue\",\"creme\",\"super\",\"grill\",\"after\",\"owner\",\"ember\",\"reach\",\"nobly\",\"empty\",\"speed\",\"gipsy\",\"recur\",\"smock\",\"dread\",\"merge\",\"burst\",\"kappa\",\"amity\",\"shaky\",\"hover\",\"carol\",\"snort\",\"synod\",\"faint\",\"haunt\",\"flour\",\"chair\",\"detox\",\"shrew\",\"tense\",\"plied\",\"quark\",\"burly\",\"novel\",\"waxen\",\"stoic\",\"jerky\",\"blitz\",\"beefy\",\"lyric\",\"hussy\",\"towel\",\"quilt\",\"below\",\"bingo\",\"wispy\",\"brash\",\"scone\",\"toast\",\"easel\",\"saucy\",\"value\",\"spice\",\"honor\",\"route\",\"sharp\",\"bawdy\",\"radii\",\"skull\",\"phony\",\"issue\",\"lager\",\"swell\",\"urine\",\"gassy\",\"trial\",\"flora\",\"upper\",\"latch\",\"wight\",\"brick\",\"retry\",\"holly\",\"decal\",\"grass\",\"shack\",\"dogma\",\"mover\",\"defer\",\"sober\",\"optic\",\"crier\",\"vying\",\"nomad\",\"flute\",\"hippo\",\"shark\",\"drier\",\"obese\",\"bugle\",\"tawny\",\"chalk\",\"feast\",\"ruddy\",\"pedal\",\"scarf\",\"cruel\",\"bleat\",\"tidal\",\"slush\",\"semen\",\"windy\",\"dusty\",\"sally\",\"igloo\",\"nerdy\",\"jewel\",\"shone\",\"whale\",\"hymen\",\"abuse\",\"fugue\",\"elbow\",\"crumb\",\"pansy\",\"welsh\",\"syrup\",\"terse\",\"suave\",\"gamut\",\"swung\",\"drake\",\"freed\",\"afire\",\"shirt\",\"grout\",\"oddly\",\"tithe\",\"plaid\",\"dummy\",\"broom\",\"blind\",\"torch\",\"enemy\",\"again\",\"tying\",\"pesky\",\"alter\",\"gazer\",\"noble\",\"ethos\",\"bride\",\"extol\",\"decor\",\"hobby\",\"beast\",\"idiom\",\"utter\",\"these\",\"sixth\",\"alarm\",\"erase\",\"elegy\",\"spunk\",\"piper\",\"scaly\",\"scold\",\"hefty\",\"chick\",\"sooty\",\"canal\",\"whiny\",\"slash\",\"quake\",\"joint\",\"swept\",\"prude\",\"heavy\",\"wield\",\"femme\",\"lasso\",\"maize\",\"shale\",\"screw\",\"spree\",\"smoky\",\"whiff\",\"scent\",\"glade\",\"spent\",\"prism\",\"stoke\",\"riper\",\"orbit\",\"cocoa\",\"guilt\",\"humus\",\"shush\",\"table\",\"smirk\",\"wrong\",\"noisy\",\"alert\",\"shiny\",\"elate\",\"resin\",\"whole\",\"hunch\",\"pixel\",\"polar\",\"hotel\",\"sword\",\"cleat\",\"mango\",\"rumba\",\"puffy\",\"filly\",\"billy\",\"leash\",\"clout\",\"dance\",\"ovate\",\"facet\",\"chili\",\"paint\",\"liner\",\"curio\",\"salty\",\"audio\",\"snake\",\"fable\",\"cloak\",\"navel\",\"spurt\",\"pesto\",\"balmy\",\"flash\",\"unwed\",\"early\",\"churn\",\"weedy\",\"stump\",\"lease\",\"witty\",\"wimpy\",\"spoof\",\"saner\",\"blend\",\"salsa\",\"thick\",\"warty\",\"manic\",\"blare\",\"squib\",\"spoon\",\"probe\",\"crepe\",\"knack\",\"force\",\"debut\",\"order\",\"haste\",\"teeth\",\"agent\",\"widen\",\"icily\",\"slice\",\"ingot\",\"clash\",\"juror\",\"blood\",\"abode\",\"throw\",\"unity\",\"pivot\",\"slept\",\"troop\",\"spare\",\"sewer\",\"parse\",\"morph\",\"cacti\",\"tacky\",\"spool\",\"demon\",\"moody\",\"annex\",\"begin\",\"fuzzy\",\"patch\",\"water\",\"lumpy\",\"admin\",\"omega\",\"limit\",\"tabby\",\"macho\",\"aisle\",\"skiff\",\"basis\",\"plank\",\"verge\",\"botch\",\"crawl\",\"lousy\",\"slain\",\"cubic\",\"raise\",\"wrack\",\"guide\",\"foist\",\"cameo\",\"under\",\"actor\",\"revue\",\"fraud\",\"harpy\",\"scoop\",\"climb\",\"refer\",\"olden\",\"clerk\",\"debar\",\"tally\",\"ethic\",\"cairn\",\"tulle\",\"ghoul\",\"hilly\",\"crude\",\"apart\",\"scale\",\"older\",\"plain\",\"sperm\",\"briny\",\"abbot\",\"rerun\",\"quest\",\"crisp\",\"bound\",\"befit\",\"drawn\",\"suite\",\"itchy\",\"cheer\",\"bagel\",\"guess\",\"broad\",\"axiom\",\"chard\",\"caput\",\"leant\",\"harsh\",\"curse\",\"proud\",\"swing\",\"opine\",\"taste\",\"lupus\",\"gumbo\",\"miner\",\"green\",\"chasm\",\"lipid\",\"topic\",\"armor\",\"brush\",\"crane\",\"mural\",\"abled\",\"habit\",\"bossy\",\"maker\",\"dusky\",\"dizzy\",\"lithe\",\"brook\",\"jazzy\",\"fifty\",\"sense\",\"giant\",\"surly\",\"legal\",\"fatal\",\"flunk\",\"began\",\"prune\",\"small\",\"slant\",\"scoff\",\"torus\",\"ninny\",\"covey\",\"viper\",\"taken\",\"moral\",\"vogue\",\"owing\",\"token\",\"entry\",\"booth\",\"voter\",\"chide\",\"elfin\",\"ebony\",\"neigh\",\"minim\",\"melon\",\"kneed\",\"decoy\",\"voila\",\"ankle\",\"arrow\",\"mushy\",\"tribe\",\"cease\",\"eager\",\"birth\",\"graph\",\"odder\",\"terra\",\"weird\",\"tried\",\"clack\",\"color\",\"rough\",\"weigh\",\"uncut\",\"ladle\",\"strip\",\"craft\",\"minus\",\"dicey\",\"titan\",\"lucid\",\"vicar\",\"dress\",\"ditch\",\"gypsy\",\"pasta\",\"taffy\",\"flame\",\"swoop\",\"aloof\",\"sight\",\"broke\",\"teary\",\"chart\",\"sixty\",\"wordy\",\"sheer\",\"leper\",\"nosey\",\"bulge\",\"savor\",\"clamp\",\"funky\",\"foamy\",\"toxic\",\"brand\",\"plumb\",\"dingy\",\"butte\",\"drill\",\"tripe\",\"bicep\",\"tenor\",\"krill\",\"worse\",\"drama\",\"hyena\",\"think\",\"ratio\",\"cobra\",\"basil\",\"scrum\",\"bused\",\"phone\",\"court\",\"camel\",\"proof\",\"heard\",\"angel\",\"petal\",\"pouty\",\"throb\",\"maybe\",\"fetal\",\"sprig\",\"spine\",\"shout\",\"cadet\",\"macro\",\"dodgy\",\"satyr\",\"rarer\",\"binge\",\"trend\",\"nutty\",\"leapt\",\"amiss\",\"split\",\"myrrh\",\"width\",\"sonar\",\"tower\",\"baron\",\"fever\",\"waver\",\"spark\",\"belie\",\"sloop\",\"expel\",\"smote\",\"baler\",\"above\",\"north\",\"wafer\",\"scant\",\"frill\",\"awash\",\"snack\",\"scowl\",\"frail\",\"drift\",\"limbo\",\"fence\",\"motel\",\"ounce\",\"wreak\",\"revel\",\"talon\",\"prior\",\"knelt\",\"cello\",\"flake\",\"debug\",\"anode\",\"crime\",\"salve\",\"scout\",\"imbue\",\"pinky\",\"stave\",\"vague\",\"chock\",\"fight\",\"video\",\"stone\",\"teach\",\"cleft\",\"frost\",\"prawn\",\"booty\",\"twist\",\"apnea\",\"stiff\",\"plaza\",\"ledge\",\"tweak\",\"board\",\"grant\",\"medic\",\"bacon\",\"cable\",\"brawl\",\"slunk\",\"raspy\",\"forum\",\"drone\",\"women\",\"mucus\",\"boast\",\"toddy\",\"coven\",\"tumor\",\"truer\",\"wrath\",\"stall\",\"steam\",\"axial\",\"purer\",\"daily\",\"trail\",\"niche\",\"mealy\",\"juice\",\"nylon\",\"plump\",\"merry\",\"flail\",\"papal\",\"wheat\",\"berry\",\"cower\",\"erect\",\"brute\",\"leggy\",\"snipe\",\"sinew\",\"skier\",\"penny\",\"jumpy\",\"rally\",\"umbra\",\"scary\",\"modem\",\"gross\",\"avian\",\"greed\",\"satin\",\"tonic\",\"parka\",\"sniff\",\"livid\",\"stark\",\"trump\",\"giddy\",\"reuse\",\"taboo\",\"avoid\",\"quote\",\"devil\",\"liken\",\"gloss\",\"gayer\",\"beret\",\"noise\",\"gland\",\"dealt\",\"sling\",\"rumor\",\"opera\",\"thigh\",\"tonga\",\"flare\",\"wound\",\"white\",\"bulky\",\"etude\",\"horse\",\"circa\",\"paddy\",\"inbox\",\"fizzy\",\"grain\",\"exert\",\"surge\",\"gleam\",\"belle\",\"salvo\",\"crush\",\"fruit\",\"sappy\",\"taker\",\"tract\",\"ovine\",\"spiky\",\"frank\",\"reedy\",\"filth\",\"spasm\",\"heave\",\"mambo\",\"right\",\"clank\",\"trust\",\"lumen\",\"borne\",\"spook\",\"sauce\",\"amber\",\"lathe\",\"carat\",\"corer\",\"dirty\",\"slyly\",\"affix\",\"alloy\",\"taint\",\"sheep\",\"kinky\",\"wooly\",\"mauve\",\"flung\",\"yacht\",\"fried\",\"quail\",\"brunt\",\"grimy\",\"curvy\",\"cagey\",\"rinse\",\"deuce\",\"state\",\"grasp\",\"milky\",\"bison\",\"graft\",\"sandy\",\"baste\",\"flask\",\"hedge\",\"girly\",\"swash\",\"boney\",\"coupe\",\"endow\",\"abhor\",\"welch\",\"blade\",\"tight\",\"geese\",\"miser\",\"mirth\",\"cloud\",\"cabal\",\"leech\",\"close\",\"tenth\",\"pecan\",\"droit\",\"grail\",\"clone\",\"guise\",\"ralph\",\"tango\",\"biddy\",\"smith\",\"mower\",\"payee\",\"serif\",\"drape\",\"fifth\",\"spank\",\"glaze\",\"allot\",\"truck\",\"kayak\",\"virus\",\"testy\",\"tepee\",\"fully\",\"zonal\",\"metro\",\"curry\",\"grand\",\"banjo\",\"axion\",\"bezel\",\"occur\",\"chain\",\"nasal\",\"gooey\",\"filer\",\"brace\",\"allay\",\"pubic\",\"raven\",\"plead\",\"gnash\",\"flaky\",\"munch\",\"dully\",\"eking\",\"thing\",\"slink\",\"hurry\",\"theft\",\"shorn\",\"pygmy\",\"ranch\",\"wring\",\"lemon\",\"shore\",\"mamma\",\"froze\",\"newer\",\"style\",\"moose\",\"antic\",\"drown\",\"vegan\",\"chess\",\"guppy\",\"union\",\"lever\",\"lorry\",\"image\",\"cabby\",\"druid\",\"exact\",\"truth\",\"dopey\",\"spear\",\"cried\",\"chime\",\"crony\",\"stunk\",\"timid\",\"batch\",\"gauge\",\"rotor\",\"crack\",\"curve\",\"latte\",\"witch\",\"bunch\",\"repel\",\"anvil\",\"soapy\",\"meter\",\"broth\",\"madly\",\"dried\",\"scene\",\"known\",\"magma\",\"roost\",\"woman\",\"thong\",\"punch\",\"pasty\",\"downy\",\"knead\",\"whirl\",\"rapid\",\"clang\",\"anger\",\"drive\",\"goofy\",\"email\",\"music\",\"stuff\",\"bleep\",\"rider\",\"mecca\",\"folio\",\"setup\",\"verso\",\"quash\",\"fauna\",\"gummy\",\"happy\",\"newly\",\"fussy\",\"relic\",\"guava\",\"ratty\",\"fudge\",\"femur\",\"chirp\",\"forte\",\"alibi\",\"whine\",\"petty\",\"golly\",\"plait\",\"fleck\",\"felon\",\"gourd\",\"brown\",\"thrum\",\"ficus\",\"stash\",\"decry\",\"wiser\",\"junta\",\"visor\",\"daunt\",\"scree\",\"impel\",\"await\",\"press\",\"whose\",\"turbo\",\"stoop\",\"speak\",\"mangy\",\"eying\",\"inlet\",\"crone\",\"pulse\",\"mossy\",\"staid\",\"hence\",\"pinch\",\"teddy\",\"sully\",\"snore\",\"ripen\",\"snowy\",\"attic\",\"going\",\"leach\",\"mouth\",\"hound\",\"clump\",\"tonal\",\"bigot\",\"peril\",\"piece\",\"blame\",\"haute\",\"spied\",\"undid\",\"intro\",\"basal\",\"shine\",\"gecko\",\"rodeo\",\"guard\",\"steer\",\"loamy\",\"scamp\",\"scram\",\"manly\",\"hello\",\"vaunt\",\"organ\",\"feral\",\"knock\",\"extra\",\"condo\",\"adapt\",\"willy\",\"polka\",\"rayon\",\"skirt\",\"faith\",\"torso\",\"match\",\"mercy\",\"tepid\",\"sleek\",\"riser\",\"twixt\",\"peace\",\"flush\",\"catty\",\"login\",\"eject\",\"roger\",\"rival\",\"untie\",\"refit\",\"aorta\",\"adult\",\"judge\",\"rower\",\"artsy\",\"rural\",\"shave\"]\n\nNext we‚Äôll turn this list into a Series object. We‚Äôll also sort the answers.\n\nanswers = pd.Series(answers_list).sort_values(ignore_index=True)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#wordles-clues-algorithm",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#wordles-clues-algorithm",
    "title": "Draining the Fun Out of Wordle",
    "section": "Wordle‚Äôs clues algorithm",
    "text": "Wordle‚Äôs clues algorithm\nAfter each guess Wordle provides you with clues as to how close your guess was. Instead of colors we‚Äôll use the following encoding:\n\nF (False), the letter does not appear in the word in any spot;\nP (Position), the letter appears in the word but is in the wrong spot;\nT (True), the letter is in the word and in the correct spot.\n\nThe match function generates the clues for a guess and an answer.\n\ndef match(guess, answer):\n    result = ['F'] * 5\n    chars = list(answer)\n    \n    # Mark correct letter and position as T\n    for i in range(5):\n        if guess[i] == answer[i]:\n            result[i] = 'T'\n            chars[i] = '_'\n    \n    # Mark correct letter, wrong position as P\n    for i in range(5):\n        for j in range(5):\n            if guess[i] == chars[j] and result[i] == 'F':\n                result[i] = 'P'\n                chars[j] = '_'\n    \n    # All other positions are marked as F by default\n    \n    return ''.join(result)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#filling-the-dataframe",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#filling-the-dataframe",
    "title": "Draining the Fun Out of Wordle",
    "section": "Filling the DataFrame",
    "text": "Filling the DataFrame\nUsing the wordlist and the match function we can create the DataFrame we‚Äôll use to build the decision tree.\n\n# Add column with possible answers\ndf = answers.to_frame(name=\"answer\")\n\n\n# Suppress PerformanceWarning\nsimplefilter(action=\"ignore\", category=pd.errors.PerformanceWarning)\n\n# Add columns for answers\nfor index, value in answers.items():\n    df[value] = df[\"answer\"].map(lambda v: match(value, v))\n\nLet‚Äôs print the first ten rows to see how things turned out.\n\ndf.head(10)\n\n\n\n\n\n\n\n\nanswer\naback\nabase\nabate\nabbey\nabbot\nabhor\nabide\nabled\nabode\n...\nwryly\nyacht\nyearn\nyeast\nyield\nyoung\nyouth\nzebra\nzesty\nzonal\n\n\n\n\n0\naback\nTTTTT\nTTTFF\nTTTFF\nTTFFF\nTTFFF\nTTFFF\nTTFFF\nTTFFF\nTTFFF\n...\nFFFFF\nFPPFF\nFFTFF\nFFTFF\nFFFFF\nFFFFF\nFFFFF\nFFPFP\nFFFFF\nFFFPF\n\n\n1\nabase\nTTTFF\nTTTTT\nTTTFT\nTTFPF\nTTFFF\nTTFFF\nTTFFT\nTTFPF\nTTFFT\n...\nFFFFF\nFPFFF\nFPTFF\nFPTTF\nFFPFF\nFFFFF\nFFFFF\nFPPFP\nFPPFF\nFFFPF\n\n\n2\nabate\nTTTFF\nTTTFT\nTTTTT\nTTFPF\nTTFFP\nTTFFF\nTTFFT\nTTFPF\nTTFFT\n...\nFFFFF\nFPFFP\nFPTFF\nFPTFP\nFFPFF\nFFFFF\nFFFTF\nFPPFP\nFPFTF\nFFFPF\n\n\n3\nabbey\nTTFFF\nTTFFP\nTTFFP\nTTTTT\nTTTFF\nTTFFF\nTTFFP\nTTFTF\nTTFFP\n...\nFFFFT\nPPFFF\nPPPFF\nPPPFF\nPFPFF\nPFFFF\nPFFFF\nFPTFP\nFPFFT\nFFFPF\n\n\n4\nabbot\nTTFFF\nTTFFF\nTTFPF\nTTTFF\nTTTTT\nTTFTF\nTTFFF\nTTFFF\nTTPFF\n...\nFFFFF\nFPFFT\nFFPFF\nFFPFT\nFFFFF\nFPFFF\nFPFPF\nFFTFP\nFFFPF\nFPFPF\n\n\n5\nabhor\nTTFFF\nTTFFF\nTTFFF\nTTFFF\nTTFTF\nTTTTT\nTTFFF\nTTFFF\nTTPFF\n...\nFPFFF\nFPFPF\nFFPPF\nFFPFF\nFFFFF\nFPFFF\nFPFFP\nFFPPP\nFFFFF\nFPFPF\n\n\n6\nabide\nTTFFF\nTTFFT\nTTFFT\nTTFPF\nTTFFF\nTTFFF\nTTTTT\nTTFPP\nTTFTT\n...\nFFFFF\nFPFFF\nFPPFF\nFPPFF\nFPPFP\nFFFFF\nFFFFF\nFPPFP\nFPFFF\nFFFPF\n\n\n7\nabled\nTTFFF\nTTFFP\nTTFFP\nTTFTF\nTTFFF\nTTFFF\nTTFPP\nTTTTT\nTTFPP\n...\nFFFPF\nFPFFF\nFPPFF\nFPPFF\nFFPPT\nFFFFF\nFFFFF\nFPPFP\nFPFFF\nFFFPP\n\n\n8\nabode\nTTFFF\nTTFFT\nTTFFT\nTTFPF\nTTFPF\nTTFPF\nTTFTT\nTTFPP\nTTTTT\n...\nFFFFF\nFPFFF\nFPPFF\nFPPFF\nFFPFP\nFPFFF\nFPFFF\nFPPFP\nFPFFF\nFPFPF\n\n\n9\nabort\nTTFFF\nTTFFF\nTTFPF\nTTFFF\nTTFPT\nTTFPP\nTTFFF\nTTFFF\nTTTFF\n...\nFPFFF\nFPFFT\nFFPTF\nFFPFT\nFFFFF\nFPFFF\nFPFPF\nFFPTP\nFFFPF\nFPFPF\n\n\n\n\n10 rows √ó 2310 columns"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#preprocessing",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#preprocessing",
    "title": "Draining the Fun Out of Wordle",
    "section": "Preprocessing",
    "text": "Preprocessing\nWe‚Äôll separate the DataFrame into features and the target variable. Then we‚Äôll use sklearn‚Äôs LabelEncoder to convert the features into numeric values. We‚Äôll use the same encoding for all columns. We do this because in our tree induction algorithm below we use sklearn‚Äôs mutual_info_classif function that expects features to be numeric.\n\nX = df.drop(columns=\"answer\")\ny = df[\"answer\"]\n\nLet‚Äôs prepare the label encoder.\n\nle = LabelEncoder()\nle.fit(X.stack().unique())\n\nLabelEncoder()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LabelEncoderLabelEncoder()\n\n\nNow we can convert all columns.\n\nX = X.apply(le.transform)\n\nAgain, let‚Äôs print the first few rows to check if the encoding went alright.\n\nX.head()\n\n\n\n\n\n\n\n\naback\nabase\nabate\nabbey\nabbot\nabhor\nabide\nabled\nabode\nabort\n...\nwryly\nyacht\nyearn\nyeast\nyield\nyoung\nyouth\nzebra\nzesty\nzonal\n\n\n\n\n0\n237\n231\n231\n214\n214\n214\n214\n214\n214\n214\n...\n0\n36\n18\n18\n0\n0\n0\n10\n0\n3\n\n\n1\n231\n237\n233\n217\n214\n214\n216\n217\n216\n214\n...\n0\n27\n45\n51\n9\n0\n0\n37\n36\n3\n\n\n2\n231\n233\n237\n217\n215\n214\n216\n217\n216\n215\n...\n0\n28\n45\n46\n9\n0\n6\n37\n33\n3\n\n\n3\n214\n215\n215\n237\n231\n214\n215\n220\n215\n214\n...\n2\n108\n117\n117\n90\n81\n81\n46\n29\n3\n\n\n4\n214\n214\n217\n231\n237\n220\n214\n214\n223\n225\n...\n0\n29\n9\n11\n0\n27\n30\n19\n3\n30\n\n\n\n\n5 rows √ó 2309 columns\n\n\n\nWe can see that the patterns have been replaced by numbers. Every number is an index of a value in the le.classes_ array. For demonstration purposes, let‚Äôs look at the first 10 items of this array.\n\nle.classes_[:10]\n\narray(['FFFFF', 'FFFFP', 'FFFFT', 'FFFPF', 'FFFPP', 'FFFPT', 'FFFTF',\n       'FFFTP', 'FFFTT', 'FFPFF'], dtype=object)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#tree-induction",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#tree-induction",
    "title": "Draining the Fun Out of Wordle",
    "section": "Tree induction",
    "text": "Tree induction\nNow we‚Äôre ready to generate our tree.\nSeveral tree induction algorithms exist. They generally work top down and use some metric to determine what feature to split by at each node. The sklearn library provides CART (Classification And Regression Trees) that by default use the Gini impurity as a metric. Nodes in CART, however, only support binary splits which would make our decision tree unnecessarily deep and large. An alternative candidate algorithm could be ID3 or ID4.5. These algorithms use a concept known as information gain (the reduction in entropy after splitting by a variable) to determine what feature to split by, and they support non-binary nodes. A few Python libraries exist that implement ID3/ID4.5. We could use one of those. However, we require a bit more control over how we select the best feature, which is why we roll our own tree induction algorithm.\nTo determine what feature (word) to split by in each node, we use a metric called mutual information which is the expected value of the information gain. This metric is commonly used for feature selection and is already provided by the sklearn library as mutual_info_classif. At each node multiple words might be equally good candidates; therefor, in addition to mutual information, we will also consider whether a feature could actually be the correct answer which will generally lead to slightly more optimal trees.\nThe approach I describe here won‚Äôt guarantee an optimal tree. We‚Äôre using a greedy strategy to select the most promising features. Selecting less promising features earlier on might yield more optimal splits at a later stage; however, tree induction would take much longer. We‚Äôll still end up with an efficient tree for solving the daily Wordle, there‚Äôs just no guarantee it will be the optimal one. Realise that this is true for tree induction algorithms like CART/ID3/ID4.5 as well. Tree induction algorithms simply make locally optimal choices at each split based on the available data, and these choices may not lead to the overall best tree structure.\n\nclass WordleDecisionTree:\n    def fit(self, input, output, labels):\n        data = input.copy()\n        data[output.name] = output\n        self.labels = labels\n        self.tree = self.decision_tree(data, data, input.columns, output.name)\n\n    def decision_tree(self, data, orginal_data, feature_attribute_names, target_attribute_name):\n        unique_classes = np.unique(data[target_attribute_name])\n        if len(unique_classes) &lt;= 1:\n            return unique_classes[0]\n        else:\n            # determine best feature using mutual information\n            stats = dict(zip(feature_attribute_names, mutual_info_classif(\n                data[feature_attribute_names], \n                data[target_attribute_name], \n                discrete_features=True)\n            ))\n            best_feature = max(stats, key=lambda key: stats[key])\n            \n            # create tree structure, empty at first\n            tree = {best_feature: {}}\n\n            # remove best feature from available features, it will become the parent node\n            feature_attribute_names = [i for i in feature_attribute_names if i != best_feature]\n\n            # create nodes under parent node\n            parent_attribute_values = np.unique(data[best_feature])\n            for value in parent_attribute_values:\n                sub_data = data.where(data[best_feature] == value).dropna()\n                \n                remaining_features = np.unique(sub_data[target_attribute_name])\n                if len(remaining_features) &lt;= 2:\n                    subtree = self.decision_tree(sub_data, orginal_data, remaining_features, target_attribute_name)\n                else:\n                    subtree = self.decision_tree(sub_data, orginal_data, feature_attribute_names, target_attribute_name)\n                \n                # add subtree to original tree\n                if self.labels[int(value)] != \"TTTTT\":\n                    tree[best_feature][self.labels[int(value)]] = subtree\n            \n            return tree\n\nWe‚Äôll instantiate this class and generate the tree. This took about 12 minutes on my machine.\nmodel = WordleDecisionTree()\nmodel.fit(X, y, le.classes_)\nThe tree is stored as a nested Python dictionary. Let‚Äôs convert it to a JSON string and print the first fifteen lines.\n\nprint('\\n'.join(json.dumps(model.tree, indent=4).split('\\n')[:15]))\n\n{\n    \"raise\": {\n        \"FFFFF\": {\n            \"mulch\": {\n                \"FFFFF\": {\n                    \"goody\": {\n                        \"FFTFF\": \"known\",\n                        \"FTFFT\": {\n                            \"bobby\": {\n                                \"FTFFT\": \"poppy\"\n                            }\n                        },\n                        \"FTFPT\": \"downy\",\n                        \"FTFTT\": {\n                            \"dowdy\": {\n\n\nThe root node of this tree shows the best word to start with. Again, remember that we are only considering words that could actually be a valid answer. We can‚Äôt make any claims about this word being the best word to start with. What we can claim however is that on some day we will guess the correct answer on a first try.\n\nprint(next(iter(model.tree)))\n\nraise\n\n\nWe can determine the max depth of the decision tree.\n\ndef depth(d):\n    queue = deque([(id(d), d, 1)])\n    memo = set()\n    while queue:\n        id_, o, level = queue.popleft()\n        if id_ in memo:\n            continue\n        memo.add(id_)\n        if isinstance(o, dict):\n            queue += ((id(v), v, level + 1) for v in o.values())\n    return level\n\n\ndepth(model.tree)\n\n11\n\n\nEvery level in this nested dictionary is either a guess or a response. So a depth of 11 shows we can always guess the correct answer in 6 tries or less. I imagine you letting out a huge sigh of relief now."
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#saving-the-decision-tree",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#saving-the-decision-tree",
    "title": "Draining the Fun Out of Wordle",
    "section": "Saving the decision tree",
    "text": "Saving the decision tree\nWe‚Äôll save the decision tree as a JSON file so we don‚Äôt have to rerun the previous steps.\n\nwith open('wordle.json', 'w') as fp:\n    json.dump(model.tree, fp)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#loading-the-decision-tree",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#loading-the-decision-tree",
    "title": "Draining the Fun Out of Wordle",
    "section": "Loading the decision tree",
    "text": "Loading the decision tree\nWhenever we want to use the decision tree, we can just load it. Here we load it into the variable tree.\n\nwith open('wordle.json', 'r') as fp:\n    tree = json.load(fp)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#using-the-decision-tree",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#using-the-decision-tree",
    "title": "Draining the Fun Out of Wordle",
    "section": "Using the decision tree",
    "text": "Using the decision tree\nThe first word to try, as we‚Äôve already seen is:\n\nprint(next(iter(tree)))\n\nraise\n\n\nAfter we try raise we might get feedback such as ‚ÄòFPFFP‚Äô. We can use this to get the next guess:\n\nprint(next(iter(tree['raise']['FPFFP'])))\n\ncleat\n\n\nSuppose that after trying this word we get back ‚ÄòFTTTT‚Äô. We can just expand the chain of keys to find out what the next guess should be.\n\nprint(next(iter(tree['raise']['FPFFP']['cleat']['FTTTT'])))\n\nbleat\n\n\nAnd so on until the word has been guessed."
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#creating-the-user-interface",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#creating-the-user-interface",
    "title": "Draining the Fun Out of Wordle",
    "section": "Creating the user interface",
    "text": "Creating the user interface\nTraversing the decision tree like this is a bit cumbersome. Let‚Äôs build the GUI using Jupyter widgets to ease navigating the tree. We‚Äôll display a grid which shows the next guess. Every element in this grid is a button widget. We change the caption on these buttons to display the next word to try. By clicking these buttons you can change their color to enter the clues Wordle provides as feedback.\nWe let traverse_tree be equal to the root node of the decision tree. We start at the top row of the grid.\n\ntraverse_tree = tree\nactive_row = 0\n\nWe update the color of the button every time it is clicked. On every update we traverse the tree and find the next guess.\n\ndef on_btn_click(b, row, col):\n    global traverse_tree\n    global active_row\n    \n    for r in range(6):\n        enable_row(r, r==row)\n    \n    if active_row &lt; row:\n        traverse_tree = traverse_tree[get_word(row - 1)][get_pattern(row - 1)]\n        active_row = row\n    \n    if b.style.button_color == '#FFFFFF':\n        b.style.button_color = '#C9B458'\n    elif b.style.button_color == '#C9B458':\n        b.style.button_color = '#787C7E'\n    elif b.style.button_color == '#787C7E':\n        b.style.button_color = '#6AAA64'\n    elif b.style.button_color == '#6AAA64':\n        b.style.button_color = '#C9B458'\n    \n    if row &lt; 6:\n        pattern = get_pattern(row)\n        if pattern:\n            set_word(row + 1, get_next_word(row).upper())\n        else:\n            set_word(row + 1, \"     \")\n    \n        enable_row(row + 1, get_word(row + 1).strip())\n\nThe following function finds the next guess in the tree.\n\ndef get_next_word(row):\n    try:\n        if isinstance(traverse_tree[get_word(row)][get_pattern(row)],str):\n            return traverse_tree[get_word(row)][get_pattern(row)]\n        return next(iter(traverse_tree[get_word(row)][get_pattern(row)]))\n    except:\n        return \"     \"\n    return \"     \"\n\nWe want to call on_btn_click() for every button in the interface. A function that handles a click on a button only takes one argument, the button that is clicked. However, the on_btn_click() takes three arguments: the button, the row and the column. To bind the on_btn_click() to each button we use some glue code. The following function returns a handler for every button‚Äôs click. Each handler encapsulates the row and column in the grid and forwards the call to the on_btn_click().\n\ndef create_on_btn_click_fun(row, col):\n    def _on_btn_click(b):\n        on_btn_click(b, row, col)\n    return _on_btn_click\n\nWe need a function the display the next guess in a row in the grid.\n\ndef set_word(row, word):\n    for c in range(5):\n        vbox.children[row].children[c].description = word[c]\n\nWe want the player to only press buttons in the currently active row. For this we create a function that can enable or disable a row.\n\ndef enable_row(row,b):\n    for c in range(5):\n        vbox.children[row].children[c].disabled = not b\n\nOnce the user has completely set the pattern in a row we want to return this pattern. The following function takes care of this. If not all colors have been set yet, it will return None.\n\ndef get_pattern(row):\n    pattern = []\n    for c in range(5):\n        if vbox.children[row].children[c].style.button_color == '#FFFFFF':\n            return None\n        elif vbox.children[row].children[c].style.button_color == '#C9B458':\n            pattern.append('P')\n        elif vbox.children[row].children[c].style.button_color == '#787C7E':\n            pattern.append('F')\n        elif vbox.children[row].children[c].style.button_color == '#6AAA64':\n            pattern.append('T')\n    return ''.join(pattern)\n\nWe also write a function that returns the word in a row.\n\ndef get_word(row):\n    letters = []\n    for c in range(5):\n        letters.append(vbox.children[row].children[c].description)\n    return ''.join(letters).lower()\n\nWe need to be able to clear the grid and set it up to solve another puzzle.\n\ndef on_reset_button_click(b):\n    global traverse_tree\n    global active_row\n    for r in range(6):\n        enable_row(r, r==0)\n        for c in range(5):\n            b = vbox.children[r].children[c]\n            b.style.button_color = '#FFFFFF'\n            b.description = ' '\n    traverse_tree = tree\n    active_row = 0\n    set_word(0, next(iter(traverse_tree)).upper())\n\nNow, let‚Äôs display the actual grid and a reset button.\n\nvbox_items = []\nfor r in range(6):\n    hbox_items = []\n    for c in range(5):\n        button = widgets.Button(description=' ', style=dict(button_color='#FFFFFF', font_weight='bold'), layout=widgets.Layout(width='32px', height='32px', border='solid 1px'))\n        button.on_click(create_on_btn_click_fun(r,c))\n        hbox_items.append(button)\n    vbox_items.append(widgets.HBox(hbox_items))\n\nvbox = widgets.VBox(vbox_items)\nreset_button = widgets.Button(description=\"Reset\")\nreset_button.on_click(on_reset_button_click)\ndisplay(vbox, reset_button)\non_reset_button_click(reset_button)\n\n\n\n\n\n\n\nTo use this GUI, you simply enter the suggested word into Wordle. By clicking the letters you change the colors and get the next guess.\n\n\n\n\nVictory in three guesses!"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#taking-back-control-of-your-life",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#taking-back-control-of-your-life",
    "title": "Draining the Fun Out of Wordle",
    "section": "Taking back control of your life",
    "text": "Taking back control of your life\nUse one of the following links to play with an interactive version:\n   \nThe binder link points to a minimal Voila web app version that just loads the decision tree from file and displays the user interface. The other links include the actual tree induction algorithm.\nNow you no longer need to worry about keeping your streak going. Please go back to doing something useful!"
  },
  {
    "objectID": "posts/from-camt053-to-charts/index.html",
    "href": "posts/from-camt053-to-charts/index.html",
    "title": "From CAMT.053 to Charts",
    "section": "",
    "text": "The CAMT.053 file format is a standard XML format for exporting transactions and account balances to, for example, an accounting package. Most (European) banks allow their customers to download their transactions and balances in this file format from their banking portal. In this post I‚Äôll show how to read CAMT.053 files into Pandas dataframes.\nI wrote this code because I wanted to get a better grip on how I‚Äôm spending my hard-earned money. Besides showing how to read CAMT.053 files into dataframes, I‚Äôll also demonstrate how to categorize transactions and display some pretty graphs using Matplotlib."
  },
  {
    "objectID": "posts/from-camt053-to-charts/index.html#about-the-camt.053-file-format",
    "href": "posts/from-camt053-to-charts/index.html#about-the-camt.053-file-format",
    "title": "From CAMT.053 to Charts",
    "section": "About the CAMT.053 file format",
    "text": "About the CAMT.053 file format\nSchematically, a CAMT.053 file has the following structure:\n\nGroup Header\nStatements\n\nBalances\nEntries\n\nEntry Details\n\n\n\nEach file starts with a group header followed by one or more statements. Each statement may contain multiple account balances and multiple transactions (entries). Each entry (transaction) can contain one or more entry details.\nPandas can read XML files using the read_xml() function. However, because of how deeply nested CAMT.053 files are, we need to first flatten its structure using XSLT stylesheets.\nI created a set of stylesheets for flattening group headers, balances, statements and entries. Using these, we‚Äôll be able to read each of these into a separate dataframe.\n\n\nFile: groupheader.xsl\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xsl:stylesheet version=\"1.0\" \n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" \n  xmlns:camt=\"urn:iso:std:iso:20022:tech:xsd:camt.053.001.02\"&gt;\n\n&lt;xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/&gt;\n\n&lt;xsl:template match=\"/camt:Document/camt:BkToCstmrStmt/camt:GrpHdr\"&gt; \n&lt;data&gt;\n  &lt;row&gt;\n    &lt;MessageIdentification&gt;&lt;xsl:value-of select=\"camt:MsgId\"/&gt;&lt;/MessageIdentification&gt;\n    &lt;CreationDateTime&gt;&lt;xsl:value-of select=\"camt:CreDtTm\"/&gt;&lt;/CreationDateTime&gt;\n    &lt;xsl:if test=\"camt:MsgPgntn\"&gt;\n      &lt;PageNumber&gt;&lt;xsl:value-of select=\"camt:MsgPgntn/camt:PgNb\"/&gt;&lt;/PageNumber&gt;\n      &lt;LastPageIndicator&gt;&lt;xsl:value-of select=\"camt:MsgPgntn/camt:LastPgInd\"/&gt;&lt;/LastPageIndicator&gt;\n    &lt;/xsl:if&gt;\n  &lt;/row&gt;\n&lt;/data&gt;\n&lt;/xsl:template&gt;\n \n&lt;/xsl:stylesheet&gt;\n\n\n\nFile: balance.xsl\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xsl:stylesheet version=\"1.0\" \n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" \n  xmlns:camt=\"urn:iso:std:iso:20022:tech:xsd:camt.053.001.02\"&gt;\n\n&lt;xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/&gt;\n\n&lt;xsl:template match=\"/camt:Document/camt:BkToCstmrStmt\"&gt; \n&lt;data&gt;\n    &lt;xsl:for-each select=\"camt:Stmt/camt:Bal\"&gt;\n    &lt;row&gt;    \n      &lt;Identification&gt;&lt;xsl:value-of select=\"../camt:Id\"/&gt;&lt;/Identification&gt;\n      &lt;xsl:if test=\"camt:Tp/camt:CdOrPrtry/camt:Cd\"&gt;\n        &lt;Code&gt;&lt;xsl:value-of select=\"camt:Tp/camt:CdOrPrtry/camt:Cd\"/&gt;&lt;/Code&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:Tp/camt:CdOrPrtry/camt:Prtry\"&gt;\n        &lt;Proprietary&gt;&lt;xsl:value-of select=\"camt:Tp/camt:CdOrPrtry/camt:Prtry\"/&gt;&lt;/Proprietary&gt;\n      &lt;/xsl:if&gt;\n      &lt;Amount&gt;&lt;xsl:value-of select=\"camt:Amt\"/&gt;&lt;/Amount&gt;\n      &lt;Currency&gt;&lt;xsl:value-of select=\"camt:Amt/@Ccy\"/&gt;&lt;/Currency&gt;\n      &lt;CreditDebitIndicator&gt;&lt;xsl:value-of select=\"camt:CdtDbtInd\"/&gt;&lt;/CreditDebitIndicator&gt;\n      &lt;Date&gt;&lt;xsl:value-of select=\"camt:Dt\"/&gt;&lt;/Date&gt;\n    &lt;/row&gt;\n  &lt;/xsl:for-each&gt;\n&lt;/data&gt;\n&lt;/xsl:template&gt;\n \n&lt;/xsl:stylesheet&gt;\n\n\n\nFile: statement.xsl\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xsl:stylesheet version=\"1.0\" \n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" \n  xmlns:camt=\"urn:iso:std:iso:20022:tech:xsd:camt.053.001.02\"&gt;\n\n&lt;xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/&gt;\n\n&lt;xsl:template match=\"/camt:Document/camt:BkToCstmrStmt\"&gt; \n&lt;data&gt;\n  &lt;row&gt;\n    &lt;xsl:for-each select=\"camt:Stmt\"&gt;\n      &lt;MessageIdentification&gt;&lt;xsl:value-of select=\"/camt:Document/camt:BkToCstmrStmt/camt:GrpHdr/camt:MsgId\"/&gt;&lt;/MessageIdentification&gt;\n      &lt;Identification&gt;&lt;xsl:value-of select=\"camt:Id\"/&gt;&lt;/Identification&gt;\n      &lt;xsl:if test=\"camt:ElctrncSeqNb\"&gt;\n        &lt;ElectronicSequenceNumber&gt;&lt;xsl:value-of select=\"camt:ElctrncSeqNb\"/&gt;&lt;/ElectronicSequenceNumber&gt;\n      &lt;/xsl:if&gt;\n      &lt;CreationDateTime&gt;&lt;xsl:value-of select=\"camt:CreDtTm\"/&gt;&lt;/CreationDateTime&gt;\n      &lt;IBAN&gt;&lt;xsl:value-of select=\"camt:Acct/camt:Id/camt:IBAN\"/&gt;&lt;/IBAN&gt;\n      &lt;xsl:if test=\"camt:Acct/camt:Ccy\"&gt;\n        &lt;Currency&gt;&lt;xsl:value-of select=\"camt:Acct/camt:Ccy\"/&gt;&lt;/Currency&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:Acct/camt:Svcr\"&gt;\n        &lt;BIC&gt;&lt;xsl:value-of select=\"camt:Acct/camt:Svcr/camt:FinInstnId/camt:BIC\"/&gt;&lt;/BIC&gt;\n      &lt;/xsl:if&gt;\n    &lt;/xsl:for-each&gt;\n  &lt;/row&gt;\n&lt;/data&gt;\n&lt;/xsl:template&gt;\n \n&lt;/xsl:stylesheet&gt;\n\n\n\nFile: entry.xsl\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xsl:stylesheet version=\"1.0\" \n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" \n  xmlns:camt=\"urn:iso:std:iso:20022:tech:xsd:camt.053.001.02\"&gt;\n\n&lt;xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\"/&gt;\n\n&lt;xsl:template match=\"/camt:Document/camt:BkToCstmrStmt\"&gt; \n&lt;data&gt;\n  &lt;xsl:for-each select=\"camt:Stmt/camt:Ntry\"&gt;\n    &lt;row&gt;     \n      &lt;Identification&gt;&lt;xsl:value-of select=\"../camt:Id\"/&gt;&lt;/Identification&gt;\n      &lt;Amount&gt;&lt;xsl:value-of select=\"camt:Amt\"/&gt;&lt;/Amount&gt;\n      &lt;Currency&gt;&lt;xsl:value-of select=\"camt:Amt/@Ccy\"/&gt;&lt;/Currency&gt;\n      &lt;CreditDebitIndicator&gt;&lt;xsl:value-of select=\"camt:CdtDbtInd\"/&gt;&lt;/CreditDebitIndicator&gt;\n      &lt;Status&gt;&lt;xsl:value-of select=\"camt:Sts\"/&gt;&lt;/Status&gt;\n      &lt;xsl:if test=\"camt:BookgDt\"&gt;\n        &lt;BookingDate&gt;&lt;xsl:value-of select=\"camt:BookgDt/camt:Dt\"/&gt;&lt;/BookingDate&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:ValDt\"&gt;\n        &lt;ValueDate&gt;&lt;xsl:value-of select=\"camt:ValDt/camt:Dt\"/&gt;&lt;/ValueDate&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:AcctSvcrRef\"&gt;\n        &lt;AccountServicerReference&gt;&lt;xsl:value-of select=\"camt:AcctSvcrRef\"/&gt;&lt;/AccountServicerReference&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:BkTxCd/camt:Domn\"&gt;\n        &lt;DomainCode&gt;&lt;xsl:value-of select=\"camt:BkTxCd/camt:Domn/camt:Cd\"/&gt;&lt;/DomainCode&gt;\n    &lt;FamilyCode&gt;&lt;xsl:value-of select=\"camt:BkTxCd/camt:Domn/camt:Fmly/camt:Cd\"/&gt;&lt;/FamilyCode&gt;\n    &lt;SubFamilyCode&gt;&lt;xsl:value-of select=\"camt:BkTxCd/camt:Domn/camt:Fmly/camt:SubFmlyCd\"/&gt;&lt;/SubFamilyCode&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:BkTxCd/camt:Prtry\"&gt;\n        &lt;ProprietaryCode&gt;&lt;xsl:value-of select=\"camt:BkTxCd/camt:Prtry/camt:Cd\"/&gt;&lt;/ProprietaryCode&gt;\n    &lt;xsl:if test=\"camt:BkTxCd/camt:Prtry/camt:Issr\"&gt;\n      &lt;Issuer&gt;&lt;xsl:value-of select=\"camt:BkTxCd/camt:Prtry/camt:Issr\"/&gt;&lt;/Issuer&gt;\n        &lt;/xsl:if&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:MsgId\"&gt;\n        &lt;DetailsMessageIdentification&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:MsgId\"/&gt;&lt;/DetailsMessageIdentification&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:InstrId\"&gt;\n        &lt;DetailsInstructionIdentification&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:InstrId\"/&gt;&lt;/DetailsInstructionIdentification&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:AcctSvcrRef\"&gt;\n        &lt;DetailsAccountServicerReference&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:AcctSvcrRef\"/&gt;&lt;/DetailsAccountServicerReference&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:EndToEndId\"&gt;\n        &lt;DetailsEndToEndIdentification&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:EndToEndId\"/&gt;&lt;/DetailsEndToEndIdentification&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:MndtId\"&gt;\n        &lt;DetailsMandateIdentification&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:MndtId\"/&gt;&lt;/DetailsMandateIdentification&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:TxId\"&gt;\n        &lt;DetailsTransactionIdentification&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:Refs/camt:TxId\"/&gt;&lt;/DetailsTransactionIdentification&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:AmtDtls/camt:TxAmt/camt:Amt\"&gt;\n        &lt;DetailsAmount&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:AmtDtls/camt:TxAmt/camt:Amt\"/&gt;&lt;/DetailsAmount&gt;\n    &lt;DetailsCurrency&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:AmtDtls/camt:TxAmt/camt:Amt/@Ccy\"/&gt;&lt;/DetailsCurrency&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:Cdtr/camt:Nm\"&gt;\n        &lt;DetailsCreditorName&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:Cdtr/camt:Nm\"/&gt;&lt;/DetailsCreditorName&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:Cdtr/camt:PstlAdr/camt:Ctry\"&gt;\n        &lt;DetailsCreditorCountry&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:Cdtr/camt:PstlAdr/camt:Ctry\"/&gt;&lt;/DetailsCreditorCountry&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:Dbtr/camt:Nm\"&gt;\n        &lt;DetailsDebtorName&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:Dbtr/camt:Nm\"/&gt;&lt;/DetailsDebtorName&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:CdtrAcct/camt:Id/camt:IBAN\"&gt;\n        &lt;DetailsCreditorIBAN&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:CdtrAcct/camt:Id/camt:IBAN\"/&gt;&lt;/DetailsCreditorIBAN&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:DbtrAcct/camt:Id/camt:IBAN\"&gt;\n        &lt;DetailsDebtorIBAN&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:RltdPties/camt:DbAcct/camt:Id/camt:IBAN\"/&gt;&lt;/DetailsDebtorIBAN&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:RltdAgts/camt:DbtrAgt/camt:FinInstnId/camt:BIC\"&gt;\n        &lt;DetailsDebtorAgentBIC&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:RltdAgts/camt:DbtrAgt/camt:FinInstnId/camt:BIC\"/&gt;&lt;/DetailsDebtorAgentBIC&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:RltdAgts/camt:CdtrAgt/camt:FinInstnId/camt:BIC\"&gt;\n        &lt;DetailsCreditorAgentBIC&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:RltdAgts/camt:CdtrAgt/camt:FinInstnId/camt:BIC\"/&gt;&lt;/DetailsCreditorAgentBIC&gt;\n&lt;/xsl:if&gt;\n&lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:RltdAgts/camt:DbtrAgt/camt:FinInstnId/camt:BIC\"&gt;\n        &lt;DetailsDebtorAgentBIC&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:RltdAgts/camt:DbtrAgt/camt:FinInstnId/camt:BIC\"/&gt;&lt;/DetailsDebtorAgentBIC&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:NtryDtls/camt:TxDtls/camt:RmtInf/camt:Ustrd\"&gt;\n        &lt;DetailsRemittanceInformationUnstructured&gt;&lt;xsl:value-of select=\"camt:NtryDtls/camt:TxDtls/camt:RmtInf/camt:Ustrd\"/&gt;&lt;/DetailsRemittanceInformationUnstructured&gt;\n      &lt;/xsl:if&gt;\n      &lt;xsl:if test=\"camt:AddtlNtryInf\"&gt;\n        &lt;AdditionalEntryInformation&gt;&lt;xsl:value-of select=\"camt:AddtlNtryInf\"/&gt;&lt;/AdditionalEntryInformation&gt;\n      &lt;/xsl:if&gt;\n    &lt;/row&gt;\n  &lt;/xsl:for-each&gt;\n&lt;/data&gt;\n&lt;/xsl:template&gt;\n \n&lt;/xsl:stylesheet&gt;\n\nMany of the values in the CAMT.053 files are optional and it depends on your bank whether or not certain fields are provided. I tested the stylesheets on the XML files provided by the banks I have accounts with. It might be that your bank provides additional values that you‚Äôre interested in. In that case you‚Äôll have to extend one or more of the stylesheets.\nSee this document for all the nitty-gritty details on the CAMT.053 format and its structure."
  },
  {
    "objectID": "posts/from-camt053-to-charts/index.html#importing-dependencies",
    "href": "posts/from-camt053-to-charts/index.html#importing-dependencies",
    "title": "From CAMT.053 to Charts",
    "section": "Importing dependencies",
    "text": "Importing dependencies\nWe start by importing the necessary dependencies.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nimport ipywidgets as widgets\nimport numpy as np\n\nimport calendar\nfrom datetime import datetime, timedelta\n\nimport os\n\nfrom babel.numbers import format_currency\n\nfrom ipywidgets import interact"
  },
  {
    "objectID": "posts/from-camt053-to-charts/index.html#reading-camt.053-files",
    "href": "posts/from-camt053-to-charts/index.html#reading-camt.053-files",
    "title": "From CAMT.053 to Charts",
    "section": "Reading CAMT.053 files",
    "text": "Reading CAMT.053 files\nThe following constant defines where we will read the CAMT.053 files from.\n\nIMPORT_PATH = \"import\"\n\nMake sure that you place all CAMT.053 files you download from your banking portal into this directory.\nNow we‚Äôre ready to import all files in the import directory into a set of dataframes. Note how we provide the stylesheets as an argument to the read_xml call.\ngroupheaders = pd.DataFrame()\nstatements = pd.DataFrame()\nbalances = pd.DataFrame()\nentries = pd.DataFrame()\n\nfor file in os.listdir(IMPORT_PATH):\n    # groupheaders\n    df = pd.read_xml(os.path.join(IMPORT_PATH, file), stylesheet=\"groupheader.xsl\")\n    df.insert(0, \"FileName\", file)\n    groupheaders = pd.concat([groupheaders, df], ignore_index=True)\n\n    # statements\n    df = pd.read_xml(os.path.join(IMPORT_PATH, file), stylesheet=\"statement.xsl\")\n    df.insert(0, \"FileName\", file)\n    statements = pd.concat([statements, df], ignore_index=True)\n\n    # balances\n    df = pd.read_xml(os.path.join(IMPORT_PATH, file), stylesheet=\"balance.xsl\")\n    df.insert(0, \"FileName\", file)\n    balances = pd.concat([balances, df], ignore_index=True)\n\n    df = pd.read_xml(os.path.join(IMPORT_PATH, file), stylesheet=\"entry.xsl\")\n    df.insert(0, \"FileName\", file)\n    entries = pd.concat([entries, df], ignore_index=True)\n\ngroupheaders['CreationDateTime'] = pd.to_datetime(groupheaders.CreationDateTime)\ngroupheaders.sort_values('CreationDateTime', ignore_index=True, inplace=True)\n\nstatements['CreationDateTime'] = pd.to_datetime(statements.CreationDateTime)\nstatements.sort_values('CreationDateTime', ignore_index=True, inplace=True)\n\nbalances['Date'] = pd.to_datetime(balances.Date)\nbalances.sort_values('Date', ignore_index=True, inplace=True)\n\nentries['BookingDate'] = pd.to_datetime(entries.BookingDate)\nentries['ValueDate'] = pd.to_datetime(entries.ValueDate)\nentries.sort_values('BookingDate', ignore_index=True, inplace=True)\nThe groupheaders dataframe has the following structure:\ngroupheaders.info()\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 707 entries, 0 to 706\nData columns (total 5 columns):\n #   Column                 Non-Null Count  Dtype  \n---  ------                 --------------  -----  \n 0   FileName               707 non-null    object \n 1   MessageIdentification  707 non-null    object \n 2   CreationDateTime       707 non-null    object \n 3   PageNumber             705 non-null    float64\n 4   LastPageIndicator      705 non-null    object \ndtypes: float64(1), object(4)\nmemory usage: 27.7+ KB\nThe statements dataframe looks like this:\nstatements.info()\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 707 entries, 0 to 706\nData columns (total 8 columns):\n #   Column                    Non-Null Count  Dtype \n---  ------                    --------------  ----- \n 0   FileName                  707 non-null    object\n 1   MessageIdentification     707 non-null    object\n 2   Identification            707 non-null    object\n 3   ElectronicSequenceNumber  707 non-null    int64 \n 4   CreationDateTime          707 non-null    object\n 5   IBAN                      707 non-null    object\n 6   Currency                  707 non-null    object\n 7   BIC                       707 non-null    object\ndtypes: int64(1), object(7)\nmemory usage: 44.3+ KB\nThe account balances can be found in the balances dataframe.\nbalances.info()\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1426 entries, 0 to 1425\nData columns (total 7 columns):\n #   Column                Non-Null Count  Dtype         \n---  ------                --------------  -----         \n 0   FileName              1426 non-null   object        \n 1   Identification        1426 non-null   object        \n 2   Code                  1426 non-null   object        \n 3   Amount                1426 non-null   float64       \n 4   Currency              1426 non-null   object        \n 5   CreditDebitIndicator  1426 non-null   object        \n 6   Date                  1426 non-null   datetime64[ns]\ndtypes: datetime64[ns](1), float64(1), object(5)\nmemory usage: 78.1+ KB\nThe entries dataframe has the most columns and contains each transaction.\nentries.info()\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2308 entries, 0 to 2307\nData columns (total 31 columns):\n #   Column                                    Non-Null Count  Dtype         \n---  ------                                    --------------  -----         \n 0   FileName                                  2308 non-null   object        \n 1   Identification                            2308 non-null   object        \n 2   Amount                                    2308 non-null   float64       \n 3   Currency                                  2308 non-null   object        \n 4   CreditDebitIndicator                      2308 non-null   object        \n 5   Status                                    2308 non-null   object        \n 6   BookingDate                               2308 non-null   datetime64[ns]\n 7   ValueDate                                 2308 non-null   datetime64[ns]\n 8   AccountServicerReference                  1319 non-null   object        \n 9   DomainCode                                2203 non-null   object        \n 10  FamilyCode                                2203 non-null   object        \n 11  SubFamilyCode                             2203 non-null   object        \n 12  ProprietaryCode                           2308 non-null   object        \n 13  Issuer                                    2308 non-null   object        \n 14  AdditionalEntryInformation                2203 non-null   object        \n 15  DetailsAccountServicerReference           603 non-null    object        \n 16  DetailsEndToEndIdentification             677 non-null    object        \n 17  DetailsAmount                             603 non-null    float64       \n 18  DetailsCurrency                           603 non-null    object        \n 19  DetailsCreditorName                       512 non-null    object        \n 20  DetailsCreditorIBAN                       512 non-null    object        \n 21  DetailsDebtorAgentBIC                     636 non-null    object        \n 22  DetailsCreditorAgentBIC                   644 non-null    object        \n 23  DetailsRemittanceInformationUnstructured  703 non-null    object        \n 24  DetailsMessageIdentification              393 non-null    object        \n 25  DetailsDebtorName                         165 non-null    object        \n 26  DetailsDebtorIBAN                         0 non-null      float64       \n 27  DetailsMandateIdentification              357 non-null    object        \n 28  DetailsCreditorCountry                    254 non-null    object        \n 29  DetailsInstructionIdentification          74 non-null     object        \n 30  DetailsTransactionIdentification          74 non-null     object        \ndtypes: datetime64[ns](2), float64(3), object(26)\nmemory usage: 559.1+ KB\nYour dataframe may contain less columns if your bank doesn‚Äôt provide that specific data in its CAMT.053 files."
  },
  {
    "objectID": "posts/from-camt053-to-charts/index.html#creating-some-useful-plots",
    "href": "posts/from-camt053-to-charts/index.html#creating-some-useful-plots",
    "title": "From CAMT.053 to Charts",
    "section": "Creating some useful plots",
    "text": "Creating some useful plots\nNow let‚Äôs see how we can use this data to create some nice looking graphs.\n\nAccount balance over time\nBy joining the balances and statements dataframes we can plot the account balance over time. A dropdown widget is used to select the account number. For each month, we‚Äôll plot the mean balance. For obvious reasons I‚Äôm showing ficticious data.\n@interact(iban=widgets.Dropdown(options=statements.IBAN.unique(), description='Account:'))\ndef plot_account_balance(iban):\n    statement_balances = pd.merge(left=balances, right=statements, left_on=['FileName','Identification'], right_on=['FileName','Identification']).query('Code==\"CLBD\" & IBAN==@iban')\n    statement_balances.loc[statement_balances['CreditDebitIndicator'] == 'DBIT', 'Amount'] *= -1\n\n    xticks = [(y, m) for y, m in statement_balances.groupby([statement_balances.Date.dt.year, statement_balances.Date.dt.month]).size().index]\n    xtick_labels = [\"{}, {}\".format(y, m) for y, _, m in statement_balances.groupby([statement_balances.Date.dt.year, statement_balances.Date.dt.month, statement_balances.Date.dt.month_name()]).size().index]\n    \n    ax = (statement_balances\n        .groupby([statement_balances.Date.dt.year, statement_balances.Date.dt.month])['Amount'].mean()\n        .plot(kind='line', figsize=(14,5))\n    )\n    ax.set_xticks(np.arange(0,len(xticks),1))\n    ax.set_xticklabels(xtick_labels, rotation = 90)\n    ax.set_xlabel(None)\n    ax.yaxis.set_major_formatter(ticker.FormatStrFormatter(\"\\u20ac%d\"))\n    \n    plt.plot()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIncome vs.¬†expenses over time\nTo get an idea of one‚Äôs monthly income and expenses over time we can plot a grouped bar chart. We‚Äôll use a dropdown widget to select the account number and a slider to select the date range.\ndates = pd.date_range(entries.ValueDate.min(), entries.ValueDate.max() + timedelta(days=31), freq='M')\n@interact(\n    iban=widgets.Dropdown(options=statements.IBAN.unique(), description='Account:', layout={'width': '500px'}), \n    date_range=widgets.SelectionRangeSlider(\n        options=[(date.strftime(' %b %Y '), date) for date in dates],\n        index=(0, len(dates)-1),\n        description='Dates:',\n        layout={'width': '500px'}\n    )\n)\ndef plot_income_expenses(iban, date_range):\n    start_date = datetime(date_range[0].year, date_range[0].month, 1)\n    end_date = date_range[1]\n    transactions = pd.merge(left=statements, right=entries, left_on=['FileName', 'Identification'], right_on=['FileName', 'Identification']).query('IBAN == @iban & ValueDate &gt;= @start_date & ValueDate &lt;= @end_date')\n    \n    xticks = [\"{}, {}\".format(y, m) for y, _, m in transactions.groupby([transactions.ValueDate.dt.year, transactions.ValueDate.dt.month, transactions.ValueDate.dt.month_name()]).size().index]\n    \n    ax = (transactions\n        .groupby([transactions.ValueDate.dt.year, transactions.ValueDate.dt.month, 'CreditDebitIndicator'])['Amount'].sum().unstack('CreditDebitIndicator')\n        .plot(kind='bar', figsize=(14,5), color=['tab:blue', 'tab:orange'])\n    )\n    ax.legend(['Income', 'Expenses'])\n    ax.set_xticklabels(xticks)\n    ax.set_xlabel(None)\n    ax.yaxis.set_major_formatter(ticker.FormatStrFormatter(\"\\u20ac%d\"))\n\n    # Calculate average values\n    averages = transactions.groupby([transactions.ValueDate.dt.year, transactions.ValueDate.dt.month, 'CreditDebitIndicator'])['Amount'].sum().unstack('CreditDebitIndicator').mean()\n    \n    # Plot average lines\n    ax.axhline(y=averages.get('CRDT', 0), linestyle='--', color='tab:blue')\n    ax.axhline(y=averages.get('DBIT', 0), linestyle='--', color='tab:orange')\n    \n    plt.plot()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe two horizontal lines show the average income and expenses in the selected date range.\n\n\nHeatmap of income and expenses\nWe can subtract the expenses from the income for each month and turn this into a heatmap. This shows the monthly increase or decrease of money in an account.\n@interact(iban=widgets.Dropdown(options=statements.IBAN.unique(), description='Account:'))\ndef plot_heatmap_income_expenses(iban):\n    transactions = pd.merge(left=statements, right=entries, left_on=['FileName', 'Identification'], right_on=['FileName', 'Identification']).query('IBAN == @iban')\n    transactions.loc[transactions['CreditDebitIndicator'] == 'DBIT', 'Amount'] *= -1\n    df = (transactions.groupby([transactions.ValueDate.dt.year, transactions.ValueDate.dt.month])['Amount'].sum().unstack(1)\n        .rename_axis('Year').rename_axis('Month', axis='columns')\n        .reindex(list(range(1,13)), axis='columns', fill_value=0)\n        .rename(columns=lambda x: list(calendar.month_name)[x]))\n    v = max(df.max(axis=None), df.min(axis=None))\n    display(df\n        .style.format(na_rep=0, precision=2).background_gradient(cmap='RdBu', vmin=-v, vmax=v)\n        .applymap(lambda x: 'background-color: white; color: white;' if pd.isnull(x) or x==0 else '')\n    )\n\n\n\n\n\n\n\n\n\n\nMonth\nJanuary\nFebruary\nMarch\nApril\nMay\nJune\nJuly\nAugust\nSeptember\nOctober\nNovember\nDecember\n\n\nYear\n¬†\n¬†\n¬†\n¬†\n¬†\n¬†\n¬†\n¬†\n¬†\n¬†\n¬†\n¬†\n\n\n\n\n2021\n0\n0\n50.12\n-61.77\n21.83\n247.10\n-8.50\n69.29\n-99.98\n141.42\n27.40\n146.08\n\n\n2022\n44.12\n279.10\n143.02\n178.19\n274.45\n111.13\n179.65\n131.15\n-24.88\n-10.51\n159.53\n246.07\n\n\n2023\n244.03\n259.47\n289.19\n-44.69\n229.24\n83.17\n250.44\n280.18\n208.55\n135.56\n105.18\n249.79\n\n\n2024\n-6.29\n-21.15\n-23.76\n274.46\n-95.00\n0\n0\n0\n0\n0\n0\n0\n\n\n\n\n\nA blue positive number means we spent less than we earned. A red negative number means we spent more than we earned. A negative number doesn‚Äôt mean we are in debt. Similarly, a positive blue number doesn‚Äôt mean that we have money in our account. The numbers and colors only indicate whether our account balance has increased or decreased and by how much."
  },
  {
    "objectID": "posts/from-camt053-to-charts/index.html#categorizing-transactions",
    "href": "posts/from-camt053-to-charts/index.html#categorizing-transactions",
    "title": "From CAMT.053 to Charts",
    "section": "Categorizing transactions",
    "text": "Categorizing transactions\nBy categorizing bank transactions we can get a better sense of where our money is going. I tried to automatically categorize transactions using an LLM and also experimented with active learning. In the end I concluded that matching keywords in transaction descriptions actually worked best. For example, transactions with ‚ÄúStarbucks‚Äù or ‚ÄúLidl‚Äù can be tagged as food, while those with ‚ÄúUber‚Äù or ‚ÄúLyft‚Äù would be categorized under transportation.\nWe start out with a dataframe of uncategorized transactions.\ntransactions = pd.merge(left=statements, right=entries, left_on=['FileName', 'Identification'], right_on=['FileName', 'Identification'])\nComing up with a good list of categories was challenging. In the end I settled on the categories suggested here.\ncategories = {\n    \"Income\": [\"Salary\", ...],\n    \"Giving\": [\"Gift\", \"WWF\", ...],\n    \"Saving\": [\"Savings\", \"Retirement\", ...],\n    \"Food\": [\"Albert Heijn\", \"Jumbo\", \"Lidl\", \"Starbucks\", \"Restaurant\", ...],\n    \"Utilities\": [\"Vitens\", \"KPN\", \"Vattenfall\", \"Internet Services\", ...],\n    \"Housing\": [\"Mortage\", ...],\n    \"Transportation\": [\"NS\", \"OV-Chipkaart\", \"Uber\", \"Lyft\", ...],\n    \"Health\": [\"Infomedics\", ...],\n    \"Insurance\": [\"AEGON\", \"Centraal beheer\", ...],\n    \"Trips and Entertainment\": [\"Booking.com\", \"AirBnB\", ...],\n    \"Personal Spending\": [\"Hairsalon\", \"Shoes\", ...],\n    \"Miscellaneous\": [\"ATM\", ...]\n}\nI‚Äôve included some of the keywords I‚Äôm using. The food category has the most keywords and in my case contains a list of supermarkets, vending machines, coffee places and restaurants I frequent. You might want to split this category into ‚Äògroceries‚Äô and ‚Äòeating out‚Äô, depending on how detailed you want your categories.\nThe following function uses the dictionary above to classify each transaction. I‚Äôm only matching keywords in the columns AdditionalEntryInformation and DetailsRemittanceInformationUnstructured. If you want to match by other columns (such as account number) you can extend this list.\ndef categorize_transaction(row):\n    columns = ['AdditionalEntryInformation', 'DetailsRemittanceInformationUnstructured']\n    for (category, keywords) in categories.items():\n        for column in columns:\n            if isinstance(row[column], str) and any([row[column].lower().find(kw.lower()) &gt;= 0 for kw in keywords]):\n                return category\n    return None\nA new column will be added to the dataframe with the hopefully correct categorization.\ntransactions['Category'] = transactions.apply(categorize_transaction, axis=1)\n\nInspecting categories\nIt requires a bit of trial and error to come up with a good list of keywords. With the following code, we can see which transactions fall into each category. By selecting ‚ÄòUncategorized‚Äô we can see which transactions haven‚Äôt been assigned to a category yet.\n@interact(iban=widgets.Dropdown(options=statements.IBAN.unique(), description='Account:'), category=widgets.Dropdown(options=list(categories.keys()) + ['Uncategorized'], description='Category:'))\ndef show_transactions(iban, category):\n    columns = ['IBAN', 'Amount','CreditDebitIndicator', 'BookingDate', 'ValueDate', 'Issuer', 'AdditionalEntryInformation', 'DetailsAmount', 'DetailsCurrency',\n       'DetailsCreditorName', 'DetailsCreditorIBAN', 'DetailsRemittanceInformationUnstructured', 'DetailsDebtorName', 'DetailsDebtorIBAN', 'DetailsCreditorCountry']\n    if category == \"Uncategorized\":\n        display(transactions.query('IBAN == @iban & Category.isnull()')[columns])\n    else:\n        display(transactions.query('IBAN == @iban & Category == @category')[columns])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIBAN\nAmount\nCreditDebitIndicator\nBookingDate\nValueDate\nIssuer\nAdditionalEntryInformation\nDetailsAmount\nDetailsCurrency\nDetailsCreditorName\nDetailsCreditorIBAN\nDetailsRemittanceInformationUnstructured\nDetailsDebtorName\nDetailsDebtorIBAN\nDetailsCreditorCountry\n\n\n\n\n\n\n\n\n\nIn this case all transactions have been categorized.\n\n\nPlotting the expenses per category\nLet‚Äôs use a donut chart to visualize how much is spent in each category.\n@interact(\n    iban=widgets.Dropdown(options=statements.IBAN.unique(), description='Account:', layout={'width': '500px'}), \n    date_range=widgets.SelectionRangeSlider(\n        options=[(date.strftime(' %b %Y '), date) for date in dates],\n        index=(0, len(dates)-1),\n        description='Dates:',\n        layout={'width': '500px'}\n    )\n)\ndef plot_expenses_by_category(iban, date_range):\n    start_date = datetime(date_range[0].year, date_range[0].month, 1)\n    end_date = date_range[1]\n    df = transactions.query('IBAN == @iban & ValueDate &gt;= @start_date & ValueDate &lt;= @end_date & Category != \"Income\"').groupby('Category')['Amount'].sum()\n    total = df.sum()\n    ax = df.plot(kind='pie', startangle=90, figsize=(10,10), legend=False, autopct=lambda v: '{:.1f}%\\n\\u20ac{:.2f}'.format(v, total*v/100))\n    ax.set_title(\"Expenses\")\n    ax.axis('off')\n    ax.add_artist(plt.Circle(xy=(0,0), radius=.75, facecolor='white'))\n    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe slider allows for setting a date range. In the example above, I‚Äôve set the date range to the year 2023."
  },
  {
    "objectID": "posts/from-camt053-to-charts/index.html#analyzing-your-own-finances",
    "href": "posts/from-camt053-to-charts/index.html#analyzing-your-own-finances",
    "title": "From CAMT.053 to Charts",
    "section": "Analyzing your own finances",
    "text": "Analyzing your own finances\nIf you want to try this out with your own data, you can find all the code and the complete Jupyter Notebook in the following GitHub repository:\n\nHappy tracking!"
  },
  {
    "objectID": "posts/skyline-puzzle/index.html",
    "href": "posts/skyline-puzzle/index.html",
    "title": "Skyline Puzzle",
    "section": "",
    "text": "A coworker of mine recently introduced me to this puzzle:\nThe puzzle is called Skyline and it‚Äôs a packing puzzle. The objective is to place the metal rod in one of the holes in the base and place the nine wooden pieces around it. It was designed by Jean Claude Constantin.\nWhen solved, the puzzle looks something like this:\nIn this blog post I present some Prolog code to generate all solutions for each rod position."
  },
  {
    "objectID": "posts/skyline-puzzle/index.html#solving-this-puzzle-using-prolog",
    "href": "posts/skyline-puzzle/index.html#solving-this-puzzle-using-prolog",
    "title": "Skyline Puzzle",
    "section": "Solving this puzzle using Prolog",
    "text": "Solving this puzzle using Prolog\nIt‚Äôs a breeze to program a Skyline solver using Prolog‚Äôs built-in backtracking mechanism.\n\n\nskyline.pl\n\n% A Prolog solver for the Skyline puzzle\n% http://www.constantin-jean-clau.de/\n\nprint_solution(X,Y) :- solve(X,Y,Sol), print_board(Sol).\n\npos(X,Y,_) :- member(X,[1,2,3,4,5,6,7]), member(Y,[1,2,3,4,5,6,7]).\n\nboard(Board) :- findall(pos(X,Y,_),pos(X,Y,_),Board).\n\nsolve(X,Y,Board) :- \n    board(Board), \n    member(pos(X,Y,' '),Board),\n    solve(1,1,Board,[]).\n\nsolve(7,7,_,_) :- !.\nsolve(8,Y,Board,Placed) :-\n    Yn is Y + 1,\n    solve(1,Yn,Board,Placed), !.\nsolve(X,Y,Board,Placed) :-\n    member(pos(X,Y,V),Board),\n    nonvar(V),\n    Xn is X + 1,\n    solve(Xn,Y,Board,Placed).\nsolve(X,Y,Board,Placed) :-\n    member(pos(X,Y,V),Board),\n    var(V),\n    member(Piece,[i,g,h,f,e,d,a,c,b]),\n    not(member(Piece,Placed)),\n    piece(Piece,Locs),\n    place_piece(Piece,X,Y,Locs,Board),\n    Xn is X + 1,\n    solve(Xn,Y,Board,[Piece|Placed]).\n\nprint_board(Board) :- \n    write('+-------+'), nl,\n    findall(_,(member(Y,[1,2,3,4,5,6,7]),print_line(Y,Board)),_),\n    write('+-------+'), nl.\n\nprint_line(Y,Board) :- \n    write('|'), \n    findall(_,(member(X,[1,2,3,4,5,6,7]),print_piece(X,Y,Board)),_), \n    write('|'),\n    nl.\n\nprint_piece(X,Y,Board) :- \n    member(pos(X,Y,P),Board), \n    not(var(P)),\n    write(P), !.\nprint_piece(_,_,_) :- \n    write('_').\n\nplace_piece(_,_,_,[],_).\nplace_piece(Piece,X0,Y0,[(Xd,Yd)|Locs],Board) :-\n    X is X0 + Xd, X &gt; 0, X =&lt; 7, \n    Y is Y0 + Yd, Y &gt; 0, Y =&lt; 7,\n    member(pos(X,Y,Piece),Board),\n    place_piece(Piece,X0,Y0,Locs,Board).\n\npiece(a,[(0,0),(0,1),(0,2),(0,3),(0,4)]).\npiece(a,[(0,0),(1,0),(2,0),(3,0),(4,0)]).\n\npiece(b,[(0,0),(1,0)]).\npiece(b,[(0,0),(0,1)]).\n\npiece(c,[(0,0),(-1,1),(0,1),(1,1)]).\npiece(c,[(0,0),(1,0),(1,1),(2,0)]).\npiece(c,[(0,0),(0,1),(-1,1),(0,2)]).\npiece(c,[(0,0),(0,1),(1,1),(0,2)]).\n\npiece(d,[(0,0),(0,1),(1,1),(1,2),(2,2)]).\npiece(d,[(0,0),(1,0),(-1,1),(0,1),(-1,2)]).\npiece(d,[(0,0),(1,0),(1,1),(2,1),(2,2)]). \npiece(d,[(0,0),(-1,1),(0,1),(-2,2),(-1,2)]).\n\npiece(e,[(0,0),(0,1),(0,2),(0,3),(1,1)]).\npiece(e,[(0,0),(1,0),(2,0),(3,0),(2,1)]).\npiece(e,[(0,0),(0,1),(0,2),(0,3),(-1,2)]).\npiece(e,[(0,0),(-1,1),(0,1),(1,1),(2,1)]).\n\npiece(f,[(0,0),(-1,1),(0,1),(-2,2),(-1,2),(0,2)]).\npiece(f,[(0,0),(0,1),(1,1),(0,2),(1,2),(2,2)]).\npiece(f,[(0,0),(1,0),(2,0),(0,1),(1,1),(0,2)]).\npiece(f,[(0,0),(1,0),(2,0),(1,1),(2,1),(2,2)]).\n\npiece(g,[(0,0),(1,0),(0,1),(1,1),(2,1),(0,2),(1,2)]).\npiece(g,[(0,0),(1,0),(2,0),(0,1),(1,1),(2,1),(1,2)]).\npiece(g,[(0,0),(1,0),(-1,1),(0,1),(1,1),(0,2),(1,2)]).\npiece(g,[(0,0),(-1,1),(0,1),(1,1),(-1,2),(0,2),(1,2)]).\n\npiece(h,[(0,0),(0,1),(0,2),(0,3),(1,1),(1,2)]).\npiece(h,[(0,0),(1,0),(2,0),(3,0),(1,1),(2,1)]).\npiece(h,[(0,0),(-1,1),(0,1),(-1,2),(0,2),(0,3)]).\npiece(h,[(0,0),(1,0),(-1,1),(0,1),(1,1),(2,1)]).\n\npiece(i,[(0,0),(-2,1),(-1,1),(0,1),(-2,2),(-1,2),(0,2),(-1,3)]).\npiece(i,[(0,0),(1,0),(-1,1),(0,1),(1,1),(0,2),(1,2),(2,2)]).\npiece(i,[(0,0),(-1,1),(0,1),(1,1),(-1,2),(0,2),(1,2),(-1,3)]).\npiece(i,[(0,0),(1,0),(2,0),(1,1),(2,1),(3,1),(1,2),(2,2)]).\n\nYou can find a copy of this code as a GitHub gist here.\nThe solve/3 predicate is the main predicate that solves the puzzle. It takes as input the X and Y coordinates of the empty cell on the board and returns a solution, which is a list of pos(X,Y,P) terms representing the placement of the pieces on the board. The solve/4 predicate is a helper predicate that recursively places the pieces on the board.\nThe program also includes several other predicates that define the properties of the puzzle, such as the shape and size of each piece, and the rules for placing the pieces on the board. The piece/2 predicate defines the shape of each piece, and the place_piece/5 predicate checks whether a piece can be placed on a given location on the board.\nFinally, the print_board/1 predicate is used to print the solution to the puzzle in a readable format."
  },
  {
    "objectID": "posts/skyline-puzzle/index.html#how-to-use-this-solver",
    "href": "posts/skyline-puzzle/index.html#how-to-use-this-solver",
    "title": "Skyline Puzzle",
    "section": "How to use this solver",
    "text": "How to use this solver\nTo use this program, open the skyline.pl file in your preferred Prolog interpreter (I personally prefer SWI-Prolog). To find find a solution for when the metal rod is in position (4, 4), simply type the following:\nprint_solution(4,4).\n+-------+\n|ggeeeeh|\n|gggdehh|\n|ggiddhh|\n|iii ddh|\n|iiicfff|\n|bicccff|\n|baaaaaf|\n+-------+\ntrue\nThe helper predicate print_solution/2 calls the solve/3 to solve and print_board/1 to display the solution.\nYou can press ; to find alternative solutions.\nIf you want to see all solutions for a given rod position, you can type:\nfindall(_,print_solution(4,4),_)."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html",
    "href": "posts/solving-word-ladders-with-prolog/index.html",
    "title": "Solving Word Ladders with Prolog",
    "section": "",
    "text": "A few weeks ago, a friend saw that I had created a Wordle solver and he thought I might enjoy another word puzzle called Weaver. However, he couldn‚Äôt have been more wrong! I actually hate puzzles, especially the ones involving words.\nWhen I can‚Äôt solve them quickly enough, frustration sets in. It‚Äôs followed by self-doubt, anger towards myself, and eventually, resentment towards the creators of these puzzles, the universe, and life itself. For me, the only way to escape this mental turmoil is to create a solver and be done with them once and for all.\nRead on to discover how I once again managed to avoid spiraling into an existential crisis."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#so-what-is-weaver",
    "href": "posts/solving-word-ladders-with-prolog/index.html#so-what-is-weaver",
    "title": "Solving Word Ladders with Prolog",
    "section": "So what is Weaver?",
    "text": "So what is Weaver?\nWeaver is an online game where players are presented with word ladder puzzles. In these puzzles, players must transform a starting word into a target word by changing one letter at a time, while forming valid English words in each step.\n\n\n\n\n\n\n\n\n\n\nThe objective is to make the chain as short as possible. If you complete a puzzle you‚Äôll get feedback on how close you were on getting a shortest solution. Weaver uses a dictionary to check if the words you enter are valid English words. The example above shows the puzzle on the left, and a (shortest) solution on the right.\nWord ladders are nothing new. Their origin can be traced back to Lewis Carroll, who introduced them in the 19th century. He called them Doublets.\nWeaver uses four-letter words only, so that‚Äôs what I‚Äôll do as well."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#getting-the-word-list",
    "href": "posts/solving-word-ladders-with-prolog/index.html#getting-the-word-list",
    "title": "Solving Word Ladders with Prolog",
    "section": "Getting the word list",
    "text": "Getting the word list\nI started by getting the word list from Weaver‚Äôs JavaScript source code. It currently consists of 4029 four-letter words. I put this word list in my Prolog source code as follows:\nwords([aahs, aals, abas, abba, abbe, abed, abet, able, ably|...]).\nIn Weaver‚Äôs source code I also found a five-letter word list, but it doesn‚Äôt seem to be used. If you want to include five-letter words as well, you can just extend the list. Of course you can‚Äôt weave from a four to a five-letter word or vice versa."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#specifying-a-graph-structure",
    "href": "posts/solving-word-ladders-with-prolog/index.html#specifying-a-graph-structure",
    "title": "Solving Word Ladders with Prolog",
    "section": "Specifying a graph structure",
    "text": "Specifying a graph structure\nTo solve word ladders, we can start by representing the word list as a graph where each node represents a word, and there is an edge between two nodes if and only if the corresponding words differ by exactly one letter. A small subset of this graph would look like this:\n\n\n\n\n\n\n\n\n\n\nPORT\n\nPORT\n\n\n\nSORT\n\nSORT\n\n\n\nPORT--SORT\n\n\n\n\nMORT\n\nMORT\n\n\n\nPORT--MORT\n\n\n\n\nBORT\n\nBORT\n\n\n\nPORT--BORT\n\n\n\n\nFORT\n\nFORT\n\n\n\nPORT--FORT\n\n\n\n\nSORT--MORT\n\n\n\n\nSORT--BORT\n\n\n\n\nSORT--FORT\n\n\n\n\nSORD\n\nSORD\n\n\n\nSORT--SORD\n\n\n\n\nMORT--BORT\n\n\n\n\nBORT--FORT\n\n\n\n\nCORD\n\nCORD\n\n\n\nSORD--CORD\n\n\n\n\nFORD\n\nFORD\n\n\n\nSORD--FORD\n\n\n\n\nLORD\n\nLORD\n\n\n\nSORD--LORD\n\n\n\n\nCORD--FORD\n\n\n\n\nCORD--LORD\n\n\n\n\nFORD--FORT\n\n\n\n\nFORD--LORD\n\n\n\n\nFOLD\n\nFOLD\n\n\n\nFORD--FOLD\n\n\n\n\nFARD\n\nFARD\n\n\n\nFORD--FARD\n\n\n\n\nFOND\n\nFOND\n\n\n\nFORD--FOND\n\n\n\n\nFOLD--FOND\n\n\n\n\nBOND\n\nBOND\n\n\n\nFOND--BOND\n\n\n\n\nFIND\n\nFIND\n\n\n\nFOND--FIND\n\n\n\n\nFEND\n\nFEND\n\n\n\nFOND--FEND\n\n\n\n\nBIND\n\nBIND\n\n\n\nBOND--BIND\n\n\n\n\nFIND--BIND\n\n\n\n\nKIND\n\nKIND\n\n\n\nFIND--KIND\n\n\n\n\nFINE\n\nFINE\n\n\n\nFIND--FINE\n\n\n\n\nHIND\n\nHIND\n\n\n\nFIND--HIND\n\n\n\n\nFEND--FIND\n\n\n\n\nBIND--KIND\n\n\n\n\nBIND--HIND\n\n\n\n\nKIND--HIND\n\n\n\n\nKINE\n\nKINE\n\n\n\nKIND--KINE\n\n\n\n\nKINA\n\nKINA\n\n\n\nKIND--KINA\n\n\n\n\nFINE--KINE\n\n\n\n\nKINE--KINA\n\n\n\n\n\n\n\n\n\nSolving a word ladder would be the equivalent of finding the shortest path between two nodes in a graph.\n\n\n\n\n\n\n\n\n\n\nPORT\n\nPORT\n\n\n\nSORT\n\nSORT\n\n\n\nPORT--SORT\n\n\n\n\nMORT\n\nMORT\n\n\n\nPORT--MORT\n\n\n\n\nBORT\n\nBORT\n\n\n\nPORT--BORT\n\n\n\n\nFORT\n\nFORT\n\n\n\nPORT--FORT\n\n\n\n\nSORT--MORT\n\n\n\n\nSORT--BORT\n\n\n\n\nSORT--FORT\n\n\n\n\nSORD\n\nSORD\n\n\n\nSORT--SORD\n\n\n\n\nMORT--BORT\n\n\n\n\nBORT--FORT\n\n\n\n\nCORD\n\nCORD\n\n\n\nSORD--CORD\n\n\n\n\nFORD\n\nFORD\n\n\n\nSORD--FORD\n\n\n\n\nLORD\n\nLORD\n\n\n\nSORD--LORD\n\n\n\n\nCORD--FORD\n\n\n\n\nCORD--LORD\n\n\n\n\nFORD--FORT\n\n\n\n\nFORD--LORD\n\n\n\n\nFOLD\n\nFOLD\n\n\n\nFORD--FOLD\n\n\n\n\nFARD\n\nFARD\n\n\n\nFORD--FARD\n\n\n\n\nFOND\n\nFOND\n\n\n\nFORD--FOND\n\n\n\n\nFOLD--FOND\n\n\n\n\nBOND\n\nBOND\n\n\n\nFOND--BOND\n\n\n\n\nFIND\n\nFIND\n\n\n\nFOND--FIND\n\n\n\n\nFEND\n\nFEND\n\n\n\nFOND--FEND\n\n\n\n\nBIND\n\nBIND\n\n\n\nBOND--BIND\n\n\n\n\nFIND--BIND\n\n\n\n\nKIND\n\nKIND\n\n\n\nFIND--KIND\n\n\n\n\nFINE\n\nFINE\n\n\n\nFIND--FINE\n\n\n\n\nHIND\n\nHIND\n\n\n\nFIND--HIND\n\n\n\n\nFEND--FIND\n\n\n\n\nBIND--KIND\n\n\n\n\nBIND--HIND\n\n\n\n\nKIND--HIND\n\n\n\n\nKINE\n\nKINE\n\n\n\nKIND--KINE\n\n\n\n\nKINA\n\nKINA\n\n\n\nKIND--KINA\n\n\n\n\nFINE--KINE\n\n\n\n\nKINE--KINA\n\n\n\n\n\n\n\n\n\nHere we marked the shortest path between the words sort and kind, which is the answer to the puzzle we saw above.\nI defined the following predicates that specify the connectivity of the graph.\n% Helper predicates\ncount_different_elements([], [], 0).\ncount_different_elements([X|Xs], [Y|Ys], N) :-\n    X \\= Y,\n    count_different_elements(Xs, Ys, M),\n    N is M + 1.\ncount_different_elements([X|Xs], [X|Ys], N) :-\n    count_different_elements(Xs, Ys, N).\n\ncount_different_characters(A, B, N) :-\n    atom_chars(A, L1),\n    atom_chars(B, L2),\n    count_different_elements(L1, L2, N).\n\n% The successor predicate\ns(N, M, 1) :-\n    words(Words),\n    member(M,Words),\n    count_different_characters(N, M, 1).\nThe predicates count_different_elements/3 and count_different_characters/3 are helper predicates that handle the counting of different characters between two words. They are used to determine the cost or distance between two words in terms of the number of character differences.\nThe s/3 predicate defines a successor relation between words. It establishes that a successor word M is connected to an initial word N if they have exactly one different character. We assume all transitions have a cost of 1.\nOne question that might arise is whether the full graph that contains all words is a connected graph. In other words, if there is always a path between two arbitrary nodes.\nLet‚Äôs find out how many (if any) words are not connected to any other word by entering the following query:\nwords(W), bagof(M,(member(M,W), not(s(M,_,_))),Bag), length(Bag,L).\nW = [aahs, aals, abas, abba, abbe, abed, abet, able, ably|...],\nBag = [abri, adze, ahoy, amok, ankh, aqua, arak, asci, auld|...],\nL = 62.\nWe find that for 62 words there was no successor found. This alone tells us that the graph is disconnected which means that for some pairs of words you can‚Äôt make a word ladder. There are also smaller groups of word clusters that form their own little subgraph. For instance the words ordo, orzo, and ouzo form their own little graph disconnected from any other words.\n\n\n\n\n\n\n\n\n\n\nORDO\n\nORDO\n\n\n\nORZO\n\nORZO\n\n\n\nORDO--ORZO\n\n\n\n\nOUZO\n\nOUZO\n\n\n\nORZO--OUZO\n\n\n\n\n\n\n\n\n\nSuch a cute little graph. Imagine the psychological torment you‚Äôd cause by asking the biggest Weaver afficionado to create a word ladder going from beer to ouzo. Just kidding, don‚Äôt be evil."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#the-a-search-algorithm",
    "href": "posts/solving-word-ladders-with-prolog/index.html#the-a-search-algorithm",
    "title": "Solving Word Ladders with Prolog",
    "section": "The A* search algorithm",
    "text": "The A* search algorithm\nThe A* algorithm is a popular pathfinding algorithm used for finding the shortest path between a start node and a goal node in a weighted graph. It uses a combination of the actual cost (path cost from the start node) and the heuristic cost (estimated cost from the current node to the goal) to guide the search towards the goal while exploring the graph efficiently.\nBecause this algorithm works on weighted graphs only, we set the weight of all edges equal to 1. You can find many implementations of A* for a variety of programming languages online. I adapted one from here for use in the solver.\n% A* with cycle checking\na_star(Start, Answer) :-\n    h(Start, H), !,\n    a_star([[(0, H), Start]], [], Answer, 0).\n\na_star([ [_, FinalState | Path ] | _], _, Answer, _) :-\n    goal(FinalState), !,\n    reverse([FinalState | Path], Answer).\na_star([ [(Gval,_),  FinalState | Path ]| OtherPaths], OldStates, Answer, NumExpanded) :-\n    cycle_check(FinalState, Gval, OldStates),\n    bagof((C, N), s(FinalState, N, C), Neighbours),\n    expand(Gval, FinalState , Path, Neighbours,  NewPaths),\n    prune(NewPaths,PrunedPaths, OldStates), \n    combine(PrunedPaths, OtherPaths, NewFrontier),\n    N is NumExpanded + 1, !,\n    (N =&lt; 9999 -&gt; a_star(NewFrontier, [(FinalState, Gval)|OldStates], Answer,N) ; !, fail).\na_star([ _ | OtherPaths], OldStates, Answer,NumExpanded) :-\n    !, a_star(OtherPaths, OldStates, Answer,NumExpanded).\n\nexpand(_, _, _, [], []).\nexpand(Gval, State, Path,\n    [(Cost,NewState) | RestNeigh], [[(NGval, NHval), NewState, State | Path] | RestNewPaths]) :-\n    NGval is Gval + Cost,\n    h(NewState, NHval),\n    expand(Gval, State, Path, RestNeigh, RestNewPaths).\n\ncycle_check(_, _, []).\ncycle_check(State, Gval, [(State, OldGval) | Rest]) :-\n    Gval &lt; OldGval, !,\n    cycle_check(State, Gval, Rest).\ncycle_check(State, Gval, [(OldState, _) | Rest]) :-\n    State \\== OldState, !,\n    cycle_check(State, Gval, Rest).\n\nprune([ NewPath | RestNPaths], PrunedPaths, OldStates) :-\n    NewPath = [(Gval, _), FinalState | _],\n    cycle_check(FinalState, Gval, OldStates), !,\n    prune(RestNPaths, RestPruned, OldStates),\n    PrunedPaths = [NewPath | RestPruned].\nprune([ _ | RestNPaths], PrunedPaths, OldStates) :-\n    prune(RestNPaths, PrunedPaths, OldStates).\nprune([], [], _).\n\ncombine([NewState|RestNewStates], OldStates, NewFrontier) :-\n    insert(NewState, OldStates, New),\n    combine(RestNewStates, New, NewFrontier).\ncombine([], AllAdded, AllAdded) :- !.\n\ninsert_list([NewState|RestNewStates], OldStates, NewFrontier) :-\n    insert(NewState, OldStates, New),\n    insert_list(RestNewStates, New, NewFrontier).\ninsert_list([], AllAdded, AllAdded) :- !.\n\ninsert(NewState, [OldState|RestOld], \n    [NewState, OldState|RestOld]) :-\n    lower_or_equal_f_value(NewState, OldState), !.\ninsert(NewState, [OldState|RestOld], \n    [OldState|InsertedIntoRest]) :-\n    greater_f_value(NewState, OldState),\n    insert(NewState, RestOld, InsertedIntoRest), !.\ninsert(NewState, [], [NewState]).\n\nlower_or_equal_f_value([(G1,H1) | _], [(G2, H2) | _]) :-\n    X is G1 + H1, Y is G2 + H2, X =&lt; Y, !.\n\ngreater_f_value([(G1,H1) | _], [(G2, H2) | _]) :-\n    X is G1 + H1, Y is G2 + H2, X &gt; Y, !.\nIt assumes a successor predicate s/3 that we‚Äôve defined above. Furthermore, it expects a predicate h/2 that defines a heuristic to guide the search and a goal/1 predicate that gets satisfied once the search has reached the final node.\nThe heuristic I used is the number of letters that are different from the target word. The closer we are to the final node, the more letters are expected to be correct.\n% The heuristic\nh(N, H) :-\n    goal(M),\n    count_different_characters(N, M, H).\nThe A* search algorithm is guarenteed to find the shortest path if the heuristic we choose is admissible. A heuristic is said to be admissible if it never overestimates the cost of reaching the goal. In our case we know it never overestimates the cost, because if n letters are different from the target word, we need at least n more steps.\nThe goal/1 predicate is dynamically added to the Prolog database before we commence our search. The weaver/3 predicate is the top-level predicate that you call when you want to solve a puzzle.\n:- dynamic goal/1.\n\nweaver(Start, Goal, Solution) :-\n    retractall(goal(_)),\n    assert(goal(Goal)),\n    a_star(Start, Solution).\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#running-the-solver",
    "href": "posts/solving-word-ladders-with-prolog/index.html#running-the-solver",
    "title": "Solving Word Ladders with Prolog",
    "section": "Running the solver",
    "text": "Running the solver\nTo run the solver, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the solver by typing:\n[weaver].\nThis loads the weaver.pl file. To solve a word ladder going from sort to kind, you‚Äôd enter:\nweaver(sort, kind, Solution).\nSolution = [sort, sord, ford, fond, find, kind].\nThere you have it! No more emotional distress over not being able to solve word ladders."
  },
  {
    "objectID": "posts/vba-iban-validator/index.html",
    "href": "posts/vba-iban-validator/index.html",
    "title": "VBA IBAN Validator",
    "section": "",
    "text": "From February 2014 onwards, IBAN will be the new European standard for bank account numbers. This standardization is part of the SEPA initiative to improve the efficiency of cross-border euro payments.\nI wrote an IBAN validator in VBA for an MS Access database I‚Äôm maintaining, but you can also use it in Excel or any other application that supports VBA.\n\n\nmodValidIban.bas\n\nOption Compare Database\nOption Explicit\n\n' http://en.wikipedia.org/wiki/International_Bank_Account_Number\nPrivate Const IbanCountryLengths As String = \"AL28AD24AT20AZ28BH22BE16BA20BR29BG22CR21HR21CY28CZ24DK18DO28EE20FO18\" & _\n                                             \"FI18FR27GE22DE22GI23GR27GL18GT28HU28IS26IE22IL23IT27KZ20KW30LV21LB28\" & _\n                                             \"LI21LT20LU20MK19MT31MR27MU30MC27MD24ME22NL18NO15PK24PS29PL28PT25RO24\" & _\n                                             \"SM27SA24RS22SK24SI19ES24SE24CH21TN24TR26AE23GB22VG24QA29\"\n\nPrivate Function ValidIbanCountryLength(CountryCode As String, IbanLength As Integer) As Boolean\n    Dim i As Integer\n    For i = 0 To Len(IbanCountryLengths) / 4 - 1\n        If Mid(IbanCountryLengths, i * 4 + 1, 2) = CountryCode And _\n                    CInt(Mid(IbanCountryLengths, i * 4 + 3, 2)) = IbanLength Then\n            ValidIbanCountryLength = True\n            Exit Function\n        End If\n    Next i\n    ValidIbanCountryLength = False\nEnd Function\n\nPrivate Function Mod97(Num As String) As Integer\n    Dim lngTemp As Long\n    Dim strTemp As String\n\n    Do While Val(Num) &gt;= 97\n        If Len(Num) &gt; 5 Then\n            strTemp = Left(Num, 5)\n            Num = Right(Num, Len(Num) - 5)\n        Else\n            strTemp = Num\n            Num = \"\"\n        End If\n        lngTemp = CLng(strTemp)\n        lngTemp = lngTemp Mod 97\n        strTemp = CStr(lngTemp)\n        Num = strTemp & Num\n    Loop\n    Mod97 = CInt(Num)\nEnd Function\n\nPublic Function ValidIban(IBAN As String) As Boolean\n    Dim strIban As String\n    Dim i As Integer\n\n    strIban = UCase(IBAN)\n    ' Remove spaces\n    strIban = Replace(strIban, \" \", \"\")\n\n    ' Check if IBAN contains only uppercase characters and numbers\n    For i = 1 To Len(strIban)\n        If Not ((Asc(Mid(strIban, i, 1)) &lt;= Asc(\"9\") And Asc(Mid(strIban, i, 1)) &gt;= Asc(\"0\")) Or _\n                (Asc(Mid(strIban, i, 1)) &lt;= Asc(\"Z\") And Asc(Mid(strIban, i, 1)) &gt;= Asc(\"A\"))) Then\n            ValidIban = False\n            Exit Function\n        End If\n    Next i\n\n    ' Check if length of IBAN equals expected length for country\n    If Not ValidIbanCountryLength(Left(strIban, 2), Len(strIban)) Then\n        ValidIban = False\n        Exit Function\n    End If\n\n    ' Rearrange\n    strIban = Right(strIban, Len(strIban) - 4) & Left(strIban, 4)\n\n    ' Replace characters\n    For i = 0 To 25\n        strIban = Replace(strIban, Chr(i + Asc(\"A\")), i + 10)\n    Next i\n\n    ' Check remainder\n    ValidIban = Mod97(strIban) = 1\nEnd Function\n\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/icosian-game/index.html",
    "href": "posts/icosian-game/index.html",
    "title": "Icosian Game",
    "section": "",
    "text": "The Irish mathematician William Rowan Hamilton is probably best known for discovering quaternions. He is also the inventor of the Icosian game.\nIn this blog post I‚Äôll describe the game and share some Prolog code for solving it."
  },
  {
    "objectID": "posts/icosian-game/index.html#how-to-play-the-icosian-game",
    "href": "posts/icosian-game/index.html#how-to-play-the-icosian-game",
    "title": "Icosian Game",
    "section": "How to play the Icosian game",
    "text": "How to play the Icosian game\nThe game‚Äôs objective is to find a path around a dodecahedron such that every vertex is visited once, no edge is visited multiple times, and the path ends in de same vertex it started from. Instead of using a 3d dodecahedron, the game was distributed as a pegboard with holes at the vertices of the 2d dodecahedral graph.\n\n\n\nOne of the few remaining copies (from the collection of the puzzle museum)\n\n\nThe game was meant to be played by two people. The first player would set up the challenge by placing the first five pegs in any five consecutive holes and then the second player would be required to place the remaining fifteen pegs consecutively in such a way that the succession would be cyclical."
  },
  {
    "objectID": "posts/icosian-game/index.html#some-graph-theory",
    "href": "posts/icosian-game/index.html#some-graph-theory",
    "title": "Icosian Game",
    "section": "Some graph theory",
    "text": "Some graph theory\nIn graph theory, a path that visits every vertex of a graph once is now known as a Hamiltonian path. A path that visits every vertex once and that ends in the same vertex as it started off from is called a Hamiltonian cycle. So playing this game is essentially searching for a Hamiltonian cycle in the dodecahedral graph."
  },
  {
    "objectID": "posts/icosian-game/index.html#solving-this-game-using-prolog",
    "href": "posts/icosian-game/index.html#solving-this-game-using-prolog",
    "title": "Icosian Game",
    "section": "Solving this game using Prolog",
    "text": "Solving this game using Prolog\nThe Icosian game was never a commercial success, probably because it‚Äôs too easy. I wrote some Prolog code to solve this game and explore possible solutions.\n\n\nicosian.pl\n\n% A Prolog solver for the Icosian game\n% https://en.wikipedia.org/wiki/Icosian_game\n\nicosian_puzzle_edges([\n    (b,c), (b,g), (b,z), (c,d), (c,p), (d,f), (d,m), (f,g), (f,k), (g,h), \n    (h,j), (h,x), (j,k), (j,v), (k,l), (l,t), (l,m), (m,n), (n,p), (n,s), \n    (p,q), (q,z), (q,r), (r,s), (r,w), (s,t), (t,v), (v,w), (w,x), (x,z)\n]).\n\nconnected(Adj,P,Q) :- member((P,Q),Adj); member((Q,P),Adj).\n\ngraph_order(Adj,N) :- \n    findall(A,connected(Adj,A,_),B0), \n    sort(B0,B), \n    length(B,N). \n\nhamiltonian_cycle(Adj,[Start|TourRest]) :-\n    graph_order(Adj,N),\n    append([[Start],MidTour,[Start]],[Start|TourRest]),\n    length([Start|MidTour],N),\n    hamiltonian_cycle(Adj,Start,MidTour,[Start]).\n\nhamiltonian_cycle(Adj,Start,[],[LastVisited|_]) :-\n    connected(Adj,LastVisited,Start).\nhamiltonian_cycle(Adj,Start,[Head|Tail],[VisitedHead|VisitedTail]) :-\n    connected(Adj,VisitedHead,Head),\n    not(member(Head,[VisitedHead|VisitedTail])),\n    hamiltonian_cycle(Adj,Start,Tail,[Head,VisitedHead|VisitedTail]).\n\nprint_icosian_puzzle :- print_icosian_solution([]).\n\nedge_in_tour(P,Q,Tour) :-\n    append([_,[P,Q],_],Tour);\n    append([_,[Q,P],_],Tour).\n\nformat_edge(P,Q,Tour,Atom,Out) :-\n    edge_in_tour(P,Q,Tour),\n    format(atom(Out),'\\e[31m~w\\e[0m',[Atom]), !.\nformat_edge(_P,_Q,_Tour,Atom,Atom).\n\nprint_icosian_solution(Tour) :-\n    findall(F,(member((P,Q,A),[\n        (b,c,'-'), (b,g,'/'), (b,z,'\\\\'), (c,d,'\\\\'), (c,p,'/'), \n        (d,f,'/'), (d,m,'\\\\'), (f,g,'\\\\'), (f,k,'|'), (g,h,'/'),\n        (h,j,'\\\\'), (h,x,'\\\\'), (j,k,'/'), (j,v,'/'), (k,l,'\\\\'),\n        (l,t,'\\\\'), (l,m,'/'), (m,n,'/'), (n,p,'\\\\'), (n,s,'---'),\n        (p,q,'\\\\'), (q,z,'/'), (q,r,'|'), (r,s,'\\\\'), (r,w,'/'),\n        (s,t,'/'), (t,v,'-------'), (v,w,'\\\\'), (w,x,'---'), (x,z,'/')\n    ]),format_edge(P,Q,Tour,A,F)),[BC,BG,BZ,CD,CP,DF,DM,FG,FK,GH,\n        HJ,HX,JK,JV,KL,LT,LM,MN,NP,NS,PQ,QZ,QR,RS,RW,ST,TV,VW,WX,XZ]),\n    format('            R',[]), nl,\n    format('           ~w~w~w',[RW,QR,RS]), nl,\n    format('          ~w ~w ~w',[RW,QR,RS]), nl,\n    format('         ~w  ~w  ~w',[RW,QR,RS]), nl,\n    format('        ~w   Q   ~w',[RW,RS]), nl,\n    format('       ~w   ~w ~w   ~w',[RW,QZ,PQ,RS]), nl,\n    format('      ~w   ~w   ~w   ~w',[RW,QZ,PQ,RS]), nl,\n    format('     ~w   Z     P   ~w',[RW,RS]), nl,\n    format('    ~w   ~w ~w   ~w ~w   ~w',[RW,XZ,BZ,CP,NP,RS]), nl,\n    format('   ~w   ~w   B~wC   ~w   ~w',[RW,XZ,BC,NP,RS]), nl,\n    format('  ~w   ~w   ~w   ~w   ~w   ~w',[RW,XZ,BG,CD,NP,RS]), nl,\n    format(' ~w   ~w   G     D   ~w   ~w',[RW,XZ,NP,RS]), nl,\n    format('W~wX   ~w ~w   ~w ~w   N~wS',[WX,GH,FG,DF,DM,NS]), nl,\n    format(' ~w   ~w ~w   ~w ~w   ~w ~w   ~w',[VW,HX,GH,FG,DF,DM,MN,ST]), nl,\n    format('  ~w   H     F     M   ~w',[VW,ST]), nl,\n    format('   ~w   ~w    ~w    ~w   ~w',[VW,HJ,FK,LM,ST]), nl,\n    format('    ~w   ~w   K   ~w   ~w',[VW,HJ,LM,ST]), nl,\n    format('     ~w   ~w ~w ~w ~w   ~w',[VW,HJ,JK,KL,LM,ST]), nl,\n    format('      ~w   J   L   ~w',[VW,ST]), nl,\n    format('       ~w ~w     ~w ~w',[VW,JV,LT,ST]), nl,\n    format('        V~wT',[TV]), nl.\n\nsolve_icosian_puzzle :-\n    icosian_puzzle_edges(Adj), \n    hamiltonian_cycle(Adj,Tour), \n    print_icosian_solution(Tour).\n\nThe icosian_puzzle_edges/1 predicate defines the graph by specifying a list of edges between vertices. This list is used by the connected/3 predicate which checks whether there is an edge between two vertices.\nThe hamiltonian_cycle/2 predicate defines the main algorithm for finding a Hamiltonian cycle on the graph, given a starting vertex. After determining the number of vertices in the graph, it recursively tries to find a cycle that visits each vertex exactly once.\nThe print_icosian_solution/1 predicate prints out the solution to the Icosian game, highlighting the edges in the Hamiltonian cycle found by the hamiltonian_cycle/2 predicate.\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/icosian-game/index.html#how-to-use-this-code",
    "href": "posts/icosian-game/index.html#how-to-use-this-code",
    "title": "Icosian Game",
    "section": "How to use this code",
    "text": "How to use this code\nTo use this program, open the icosian.pl file in your preferred Prolog interpreter (I always use SWI-Prolog). Entering solve_icosian_puzzle. and pressing ; repeatedly will yield possible solutions.\n\nSuppose you want to explore how the cycle that starts with the vertices Q, R, S, N, P could be continued, you would enter:\nicosian_puzzle_edges(Adj), Tour = [q,r,s,n,p|Rest], hamiltonian_cycle(Adj,Tour), print_icosian_solution(Tour).\nThis game might remind you of the Travelling Salesman Problem (TSP). Finding a Hamiltonian cycle can be considered a special case of the TSP, namely, one where each pair of vertices with an edge between them has distance 1, while vertex pairs without an edge between them are separated by a distance of infinity."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html",
    "href": "posts/making-sense-of-sorting/index.html",
    "title": "Making Sense of Sorting",
    "section": "",
    "text": "Sorting algorithms are a fundamental concept in computer science, but understanding how they work can be tricky. In this blog post, I‚Äôll demonstrate an easy way to visualize their inner workings. By the end, you‚Äôll not only be able to visualize sorting algorithms, but other list algorithms as well. Let‚Äôs dive in!"
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#importing-libraries",
    "href": "posts/making-sense-of-sorting/index.html#importing-libraries",
    "title": "Making Sense of Sorting",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing the necessary libraries.\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation\nimport random\n\nfrom copy import copy\nfrom queue import Queue\nfrom IPython.display import HTML"
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#the-sorting-algorithms",
    "href": "posts/making-sense-of-sorting/index.html#the-sorting-algorithms",
    "title": "Making Sense of Sorting",
    "section": "The sorting algorithms",
    "text": "The sorting algorithms\nI will use the Selection sort and Quicksort algorithms as examples.\n\nSelection sort\nSelection sort iterates through a list, selects the smallest element, and swaps it with the first element. It then repeats this process for the remaining unsorted portion of the list until it is fully sorted.\nHere‚Äôs what it looks like in Python:\n\ndef selection_sort(a):\n    n = len(a)\n    for i in range(0, n-1):\n        k = i\n        for j in range(i+1, n):\n            if a[j] &lt; a[k]:\n                k = j\n        a[i], a[k] = a[k], a[i]\n\nIt‚Äôs short but, with an \\(\\mathcal{O}(n^2)\\) time complexity, not very efficient.\n\n\nQuicksort\nAs the name suggests, Quicksort is much faster. The algorithm works by selecting a pivot element and partitioning the list into two sub-lists: one with elements less than the pivot and another with elements greater than the pivot. This process is repeated recursively on each sub-list until the entire list is sorted.\n\ndef quick_sort(a, l=0, h=0):\n    if h == 0:\n        h = len(a) - 1\n    m = a[(l + h) // 2]\n    i = l\n    j = h\n    while i &lt;= j:\n        while a[i] &lt; m:\n            i += 1\n        while a[j] &gt; m:\n            j -= 1\n        if i &lt;= j:\n            a[i], a[j] = a[j], a[i]\n            i += 1\n            j -= 1\n    if l &lt; j:\n        quick_sort(a, l, j)\n    if i &lt; h:\n        quick_sort(a, i, h)\n\nQuicksort has a time complexity of \\(\\mathcal{O}(n\\log{}n)\\)."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#subclassing-list",
    "href": "posts/making-sense-of-sorting/index.html#subclassing-list",
    "title": "Making Sense of Sorting",
    "section": "Subclassing list",
    "text": "Subclassing list\nThe approach I take here is to create a special type of list called MonitoredList that keeps track of when its items are being accessed or changed. It does this by recording all these actions into a queue.\n\nclass MonitoredList(list):\n    def __init__(self, q, iterable):\n        super().__init__(iterable)\n        self.queue = q\n    \n    def __getitem__(self, index):\n        self.queue.put({\n            'method': '__getitem__',\n            'object': copy(self),\n            'args': [index]\n        })\n        return super().__getitem__(index)\n    \n    def __setitem__(self, index, value):\n        self.queue.put({\n            'method': '__setitem__',\n            'object': copy(self),\n            'args': [index, value]\n        })\n        super().__setitem__(index, value)\n    \n    def state_to_queue(self):\n        self.queue.put({\n            'method': 'state_to_queue',\n            'object': copy(self),\n            'args': []\n        })\n\nWhenever an item in the list is read or modified, the MonitoredList class logs information about the operation (like what method was used and what the arguments were) into the queue.\nAdditionally, the class has a method called state_to_queue which allows you to log the entire state of the list at any given time.\nTo demonstrate how the MonitoredList class is used, take a look at the following code:\n\nl = [1, 2, 3, 4]\n\nq = Queue(-1)\nml = MonitoredList(q, l)\n\nml[0] = 5 # This calls __setitem__\nml[2] = 4 # This calls __setitem__\n\nv = ml[3] # This calls __getitem__\n\nml.state_to_queue()\n\nWe start by creating a list l with four elements: [1, 2, 3, 4] and a Queue object q.\nNext, we create a MonitoredList object ml by passing q and l as parameters.\nThe next two lines of code modify ml by setting its first and third elements to 5 and 4 respectively. These modifications call the __setitem__ method of the MonitoredList object which logs information about the operation into the q queue.\nThe next line accesses the fourth element of ml and assigns its value to v. This access operation calls the __getitem__ method of the MonitoredList object which also logs information about the operation into the q queue.\nFinally, the state_to_queue method of the MonitoredList object is called which logs the current state of the list into the q queue.\nWe can get a record of all the operations that have been performed on the MonitoredList by reading the contents of the q queue.\n\nwhile not q.empty():\n    print(q.get())\n\n{'method': '__setitem__', 'object': [1, 2, 3, 4], 'args': [0, 5]}\n{'method': '__setitem__', 'object': [5, 2, 3, 4], 'args': [2, 4]}\n{'method': '__getitem__', 'object': [5, 2, 4, 4], 'args': [3]}\n{'method': 'state_to_queue', 'object': [5, 2, 4, 4], 'args': []}\n\n\nIf we apply a sorting algorithm on a MonitoredList, any direct access and modification operations performed on individual elements by the sorting algorithm will be logged into the queue. We can then use the contents of this queue to create an animation."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#animating-list-algorithms",
    "href": "posts/making-sense-of-sorting/index.html#animating-list-algorithms",
    "title": "Making Sense of Sorting",
    "section": "Animating list algorithms",
    "text": "Animating list algorithms\nThe animate_algorithm function below takes a sorting function and a list as input, and visualizes the sorting process by creating a Matplotlib animation that highlights the list elements being accessed and modified during the sorting process. It achieves this by creating a MonitoredList object to track all changes made to the list into a queue. The function then defines an animation function that extracts the elements from the queue and creates the visualization.\n\ndef animate_algorithm(fun, inp):\n    global bars\n    \n    q = Queue(-1)\n    values = MonitoredList(q, inp)\n    \n    fun(values)\n    values.state_to_queue()\n    \n    def gen_func():\n        while not q.empty():\n            item = q.get()\n            if item['method'] in ['__getitem__', '__setitem__', 'state_to_queue']:\n                yield item\n    \n    def animate(elem):\n        global bars\n        bars.remove()\n        ax.clear()\n        ax.axis('off')\n        bars = ax.bar(x_pos, elem['object'], color='steelblue', width=1.0)\n        if elem['method'] == '__getitem__':\n            x = elem['args'][0]\n            ax.plot([x,x],[0,max(elem['object'])], color='green')\n        elif elem['method'] == '__setitem__':\n            x = elem['args'][0]\n            ax.plot([x,x],[0,max(elem['object'])], color='red')\n    \n    x_pos = list(range(len(values)))\n    plt.style.use('default')\n    fig, ax = plt.subplots()\n    ax.axis('off')\n    bars = ax.bar(x_pos, values, width=1.0)\n    plt.close()\n    \n    anim = matplotlib.animation.FuncAnimation(fig, animate, frames=gen_func, save_count=999999999999)\n    \n    return anim\n\nThe visualization was inspired by this video. A bar chart is used to display the contents of the list. The visualization highlights the accessed and modified elements by adding a green line and a red line respectively to the chart."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#creating-the-animations",
    "href": "posts/making-sense-of-sorting/index.html#creating-the-animations",
    "title": "Making Sense of Sorting",
    "section": "Creating the animations",
    "text": "Creating the animations\nAlright, let‚Äôs generate some animations. We first have to create a randomized list that we can sort, so let‚Äôs begin by doing that.\n\nvalues = list(range(30))\nrandom.shuffle(values)\n\n\nSelection sort\nNow, we‚Äôre going to create an animation for the selection sort algorithm. To do so, we pass the function and the list of random values to the animate_algorithm function.\n\nanim = animate_algorithm(selection_sort, values)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n\n\nQuicksort\nWe can do the same for quicksort.\n\nanim = animate_algorithm(quick_sort, values)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n\n\nRandom shuffle\nIn addition to sorting algorithms, we can animate other list manipulation algorithms as well. For example, let‚Äôs animate the random.shuffle function.\n\nanim = animate_algorithm(random.shuffle, list(range(30)))\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nIt appears that random.shuffle implements the Fisher-Yates shuffle."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#conclusion",
    "href": "posts/making-sense-of-sorting/index.html#conclusion",
    "title": "Making Sense of Sorting",
    "section": "Conclusion",
    "text": "Conclusion\nSo there you have it! By following the steps laid out in this post, you can easily visualize sorting and other list algorithms. The provided code hopefully allows you to gain a deeper understanding of how these algorithms work.\nIf you want to animate other (sorting) algorithms, check out one of the following links:"
  },
  {
    "objectID": "posts/blocbirds/index.html",
    "href": "posts/blocbirds/index.html",
    "title": "BLOCBIRDS",
    "section": "",
    "text": "A few years ago, I visited the BLOCBIRDS exhibition while it was on display at the Frisian Museum of Natural History. The exhibition featured 25 compositions, each one inspired by different bird species and crafted entirely from rectangular shapes.\nEach composition represents the colors and proportions of a bird‚Äôs plumage. Take for example the composition based on the Bluethroat bird species.\nIn this blog post, we‚Äôll explore how to use machine learning to create similar avian-inspired art."
  },
  {
    "objectID": "posts/blocbirds/index.html#importing-libraries",
    "href": "posts/blocbirds/index.html#importing-libraries",
    "title": "BLOCBIRDS",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe‚Äôll start by importing some libraries.\n\nfrom PIL import Image\nfrom rembg import remove\nfrom IPython.display import display, clear_output\nfrom sklearn.cluster import KMeans\n\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nimport numpy as np\nimport squarify\nimport random\n\nThe rembg module implements U¬≤-Net, a neural network architecture that performs Salient Object Detection. Salient object detection is a computer vision technique that aims to identify the most visually significant objects or regions in an image. We will use it to separate the bird we‚Äôre interested in from the background.\nWe will use KMeans to extract the color palette. The squarify module is needed to plot the artwork."
  },
  {
    "objectID": "posts/blocbirds/index.html#loading-an-image-and-removing-the-background",
    "href": "posts/blocbirds/index.html#loading-an-image-and-removing-the-background",
    "title": "BLOCBIRDS",
    "section": "Loading an image and removing the background",
    "text": "Loading an image and removing the background\nWe‚Äôll start by loading an image of the Spangled cotinga which I got from here.\n\nimage = Image.open(\"spangled-continga.jpg\")\nimage\n\n\n\n\n\n\n\n\nTo create a BLOCBIRDS-like artwork based on this image of this colorful bird, we need to extract its color palette while excluding the background. We can achieve this by utilizing the aforementioned rembg module, which allows us to remove the background and focus solely on the bird‚Äôs plumage. The algorithm makes all irrelevant pixels transparent.\n\nimage = remove(image)\nimage\n\n\n\n\n\n\n\n\nNotice how it even removes the branch the bird was perching on."
  },
  {
    "objectID": "posts/blocbirds/index.html#extracting-the-palette",
    "href": "posts/blocbirds/index.html#extracting-the-palette",
    "title": "BLOCBIRDS",
    "section": "Extracting the palette",
    "text": "Extracting the palette\nK-means clustering can be used to extract dominant colors from an image. The idea is to group the pixels of the image into k clusters based on their color similarity. The algorithm then computes the average color of each cluster and assigns it as the representative color for that cluster. These representative colors can be used to create a color palette for the image.\n\nGetting the pixels\nWe first need to extract the pixels from our image. To do this we first convert the PIL image to a numpy array.\n\nnp_image = np.array(image)\n\nThis numpy array will have the same dimensions as the image. Next we select all pixels that aren‚Äôt transparent.\n\nh, w, d = np_image.shape\nif d == 4:\n    pixels = np_image[np_image[:,:,3] == 255]\n    pixels = pixels[:,:3]\nelse:\n    pixels = np_image.reshape((h * w, d))\n\n\n\nDetermining the colors\nBefore applying k-means clustering, we must determine the number of clusters, denoted by k, that we want to generate. This value represents the desired number of colors in the final palette. In this case, we will use 12 clusters or colors, although determining the ideal number is a matter of taste and some experimentation.\n\nn_clusters = 12\n\nOnce we have defined these parameters, we can apply the k-means algorithm to the pixel data of the image. Euclidean distance is used as a distance metric.\n\n# cluster pixels\nclt = KMeans(n_clusters=n_clusters, n_init='auto')\nclt.fit(pixels)\n\nKMeans(n_clusters=12, n_init='auto')In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.KMeansKMeans(n_clusters=12, n_init='auto')\n\n\nThe algorithm iteratively assigns each pixel to the nearest cluster center, updates the cluster centers based on the new pixel assignments, and repeats this process until convergence. At convergence, we have the k cluster centers or centroids which represent the dominant colors in the image.\nTo translate these centroids to actual colors we use a helper function.\n\ndef rgb_to_hex(r, g, b):\n    return \"#{:02x}{:02x}{:02x}\".format(r, g, b)\n\nWe then extract all colors and also the number of pixels that fall within that cluster.\n\ncolors = [rgb_to_hex(int(r), int(g), int(b)) for r, g, b in clt.cluster_centers_]\n_, sizes = np.unique(clt.labels_, return_counts=True)"
  },
  {
    "objectID": "posts/blocbirds/index.html#plotting-our-art",
    "href": "posts/blocbirds/index.html#plotting-our-art",
    "title": "BLOCBIRDS",
    "section": "Plotting our art",
    "text": "Plotting our art\nFinally, we can use these extracted colors and number of pixels per color to plot our artwork.\n\nfig, ax = plt.subplots(figsize=(7,7))\nsquarify.plot(sizes=sizes, color=colors, ax=ax)\nax.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\nBeautiful! Wouldn‚Äôt you agree?"
  },
  {
    "objectID": "posts/blocbirds/index.html#customizing-the-composition",
    "href": "posts/blocbirds/index.html#customizing-the-composition",
    "title": "BLOCBIRDS",
    "section": "Customizing the composition",
    "text": "Customizing the composition\nThe way the squarify function plots the rectangles is influenced by the order of elements in the colors and sizes lists. By shuffling these two lists, we can experiment with different compositions.\n\nsquares = list(zip(sizes, colors))\nrandom.shuffle(squares)\nshuffled_sizes, shuffled_colors = zip(*squares)\n\nNow, we can visualize a new composition based on these shuffled lists.\n\nfig, ax = plt.subplots(figsize=(7,7))\nsquarify.plot(sizes=shuffled_sizes, color=shuffled_colors, ax=ax)\nax.axis('off')\nplt.show()"
  },
  {
    "objectID": "posts/blocbirds/index.html#splitting-up-the-rectangles",
    "href": "posts/blocbirds/index.html#splitting-up-the-rectangles",
    "title": "BLOCBIRDS",
    "section": "Splitting up the rectangles",
    "text": "Splitting up the rectangles\nIn our plots every color gets represented by exactly one rectangle. In the BLOCBIRDS` compositions multiple rectangles can have the same color. To play around with this we can create a set of sliders, one for each color and use these to set the number of rectangles that a color can use.\n\nsliders = [widgets.IntSlider(value=1, min=1, max=20, style={'handle_color': color}) for color in colors]\n\nupdate_button = widgets.Button(description='Update')\n\noutput = widgets.Output()\n\nvbox = widgets.VBox(sliders + [update_button])\nhbox = widgets.HBox([vbox, output])\n\nThe colors and sizes for each rectangle are kept as tuples in a list.\n\nrectangles = []\n\nWe have added an ‚ÄúUpdate‚Äù button that should update this list of rectangles based on the selected number of rectangles for each color. When clicked this button executes the on_update_button_clicked(b) function.\n\ndef on_update_button_clicked(b):\n    global rectangles, fig\n    with output:\n        clear_output(wait=True)\n        splits = [slider.value for slider in sliders]\n        rectangles = []\n        for i, c in enumerate(splits):\n            rectangles += [(sizes[i] // c, colors[i])] * c\n        \n        random.shuffle(rectangles)\n        shuffled_sizes, shuffled_colors = zip(*rectangles)\n        \n        fig, ax = plt.subplots(figsize=(7,7))\n        squarify.plot(sizes=shuffled_sizes, color=shuffled_colors, ax=ax)\n        ax.axis('off')\n        plt.show()\n\nupdate_button.on_click(on_update_button_clicked)\n\n# Draw the first plot \non_update_button_clicked(None)\n\nThe purpose of this function is to plot a new composition based on the values of the sliders.\nNow we show our sliders, button and plot.\n\ndisplay(hbox)"
  },
  {
    "objectID": "posts/blocbirds/index.html#saving-the-artwork",
    "href": "posts/blocbirds/index.html#saving-the-artwork",
    "title": "BLOCBIRDS",
    "section": "Saving the artwork",
    "text": "Saving the artwork\nOnce you‚Äôre happy with a composition you can save it to file.\n\nfig.tight_layout()\nfig.savefig('spangled-continga-art.png')"
  },
  {
    "objectID": "posts/blocbirds/index.html#some-more-examples",
    "href": "posts/blocbirds/index.html#some-more-examples",
    "title": "BLOCBIRDS",
    "section": "Some more examples",
    "text": "Some more examples\nThe first few examples are all based on images I got from this site.\n\nGolden pheasant\n\n\n\n\n\n\n\n\n\n\n\n\nMandarin duck\n\n\n\n\n\n\n\n\n\n\n\n\nIndian peafowl\nIn this case I didn‚Äôt remove the background because the bird already took up the entire frame. I set the number of rectangles for all colors but one shade of blue to quite high to mimic the pattern of the tail of this blue bird.\n\n\n\n\n\n\n\n\n\n\n\n\nHalfmoon betta fish\nInstead of just birds we can also use pictures of other animals, like this Halfmoon betta fish.\n\n\n\n\n\n\n\n\n\n\n\n\nCalifornia spangled\nOr we create an abstract of the California spangled. I set the number of rectangles to two for green to mimic the eyes.\n\n\n\n\n\n\n\n\n\n\n\n\nThe Matrix\nInstead of animals we can use a movie still.\n\n\n\n\n\n\n\n\n\n\n\n\nBLACKPINK\nOr perhaps you‚Äôre more into the visual aesthetics of BLACKPINK‚Äôs DDU-DU DDU-DU."
  },
  {
    "objectID": "posts/blocbirds/index.html#creating-your-own-artwork",
    "href": "posts/blocbirds/index.html#creating-your-own-artwork",
    "title": "BLOCBIRDS",
    "section": "Creating your own artwork",
    "text": "Creating your own artwork\nIf you want to create your own piece of art, check out one of the following links:"
  },
  {
    "objectID": "posts/solving-takuzu-puzzles-with-sql/index.html",
    "href": "posts/solving-takuzu-puzzles-with-sql/index.html",
    "title": "Solving Takuzu Puzzles with SQL",
    "section": "",
    "text": "The SQLite documentation on CTEs has some pretty interesting examples on what you can do with recursive CTEs in SQL. One particular example that caught my eye shows how to solve Sudoku puzzles using a single SQL query. To better understand how it worked I decided to write a solver for Takuzu puzzles using the same approach."
  },
  {
    "objectID": "posts/solving-takuzu-puzzles-with-sql/index.html#whats-a-takuzu-puzzle",
    "href": "posts/solving-takuzu-puzzles-with-sql/index.html#whats-a-takuzu-puzzle",
    "title": "Solving Takuzu Puzzles with SQL",
    "section": "What‚Äôs a Takuzu puzzle?",
    "text": "What‚Äôs a Takuzu puzzle?\nTakuzu puzzles, also known as Binary puzzles, consist of an even-sized grid of cells (e.g.¬†6√ó6, 8√ó8, 12√ó12). Each cell must contain either a 0 or a 1.\nJust as with Sudoku, you start with a partially filled grid and have to fill in the missing values. A valid solution must satisfy three rules:\n\nNo row or column may contain three consecutive identical values\nEvery row and every column must contain exactly the same number of 0s and 1s.\nNo two rows may be identical, and no two columns may be identical.\n\nA well designed puzzle has exactly one valid solution.\nHere‚Äôs an example:\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n\n\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\n\n\n\n\n1\n\n\n\n\n1\n\n\n1\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n0\n\n\n\n\n\n\n1\n\n\n\n\n\n\nIts (unique) solution looks like this:\n\n\n\n\n1\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n\n\n0\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n0\n\n\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n1\n\n\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n0\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n\n0"
  },
  {
    "objectID": "posts/solving-takuzu-puzzles-with-sql/index.html#the-solver-in-sql",
    "href": "posts/solving-takuzu-puzzles-with-sql/index.html#the-solver-in-sql",
    "title": "Solving Takuzu Puzzles with SQL",
    "section": "The solver in SQL",
    "text": "The solver in SQL\nThis is the code I came up with:\nWITH RECURSIVE\n  input(puz) AS (\n    VALUES ('....00.0....' ||\n            '1....0....11' ||\n            '.1......00..' ||\n            '............' ||\n            '.00...1.....' ||\n            '.......0..0.' ||\n            '.1.11...1...' ||\n            '0......0....' ||\n            '..1..1......' || \n            '.0..0....0..' ||\n            '.......01.1.' ||\n            '...1...0..1.')\n  ),\n  side_len(n) AS (\n    SELECT CAST(sqrt(length(puz)) AS INT) FROM input\n  ),\n  bits(b) AS (\n    VALUES ('0'), ('1')\n  ),\n  idx(i) AS (\n    SELECT 0\n    UNION ALL \n    SELECT i + 1 FROM idx, side_len WHERE i + 1 &lt; n\n  ),\n  x(s, ind) AS (\n    SELECT puz, instr(puz, '.') FROM input\n    UNION ALL\n    SELECT\n      substr(s,1,ind-1) || b || substr(s,ind+1),\n      instr(substr(s,1,ind-1) || b || substr(s,ind+1), '.')\n    FROM x, bits, side_len\n    WHERE ind &gt; 0\n      -- No row may contain three consecutive identical values\n      AND substr(substr(s,1,ind-1) || b || substr(s,ind+1), ((ind-1)/n)*n + 1, n) NOT LIKE '%' || b || b || b || '%'\n      -- No column may contain three consecutive identical values\n      AND NOT EXISTS (\n        SELECT 1\n        FROM idx i\n        WHERE i &lt;= n-3\n          AND substr(substr(s,1,ind-1) || b || substr(s,ind+1), i*n + ((ind-1)%n) + 1, 1) = b\n          AND substr(substr(s,1,ind-1) || b || substr(s,ind+1), (i+1)*n + ((ind-1)%n) + 1, 1) = b\n          AND substr(substr(s,1,ind-1) || b || substr(s,ind+1), (i+2)*n + ((ind-1)%n) + 1, 1) = b\n      )\n      -- Every row must contain exactly the same number of 0s and 1s.\n      AND (\n        SELECT count(*)\n        FROM idx i\n        WHERE substr(substr(s,1,ind-1) || b || substr(s,ind+1), ((ind-1)/n)*n + i + 1, 1) = b\n      ) &lt;= n/2\n      -- Every column must contain exactly the same number of 0s and 1s.\n      AND (\n        SELECT count(*)\n        FROM idx i\n        WHERE substr(substr(s,1,ind-1) || b || substr(s,ind+1), i*n + ((ind-1)%n) + 1, 1) = b\n      ) &lt;= n/2\n  )\nSELECT x.s\nFROM x, side_len\nWHERE ind = 0\n-- No two rows may be identical.\nAND (SELECT count(*) = count(DISTINCT substr(x.s, i*n + 1, n)) FROM idx i)\n-- No two columns may be identical.\nAND (\n  SELECT count(*) = count(DISTINCT \n    (SELECT group_concat(substr(x.s, r.i*n + c.i + 1, 1), '') FROM idx r)\n  ) \n  FROM idx c\n);"
  },
  {
    "objectID": "posts/solving-takuzu-puzzles-with-sql/index.html#understanding-the-query",
    "href": "posts/solving-takuzu-puzzles-with-sql/index.html#understanding-the-query",
    "title": "Solving Takuzu Puzzles with SQL",
    "section": "Understanding the query",
    "text": "Understanding the query\nLet‚Äôs go over this query step by step.\nFirstly, you need to know what a CTE (Common Table Expression) actually is. It‚Äôs simply a temporary, named result set in SQL that you can reference within a single query. It is often used to simplify complex queries or enable recursion.\nA CTE is said to be recursive, if it references itself.\nThe query contains a few CTEs, both recursive, and ordinary. CTEs are defined after the WITH keyword. When you want to use recursive CTEs you also need to add the keyword RECURSIVE.\nNow you understand the first line of the query.\nLet‚Äôs go over each CTE one by one and explain what they do.\nThe input CTE defines the input Takuzu puzzle. The puzzle is represented as a single string, with . for empty cells and 0 or 1 for known values.\nWe could codify a puzzle as one long string, but for readability I have used the || concatenation opererator to show each row on a separate line.\nThe side_len simply calculates the side length by taking the square root of the length of the puzzle.\nThe bits CTE defines the possible values for each cell.\nThe first recursive CTE is idx. It produces the sequence of integers 0 to n-1, and that single sequence is then reused everywhere we need to ‚Äòloop‚Äô over rows or columns. Note how the first SELECT 0 is the base case, and the second recursive SELECT refers to the CTE itself and runs repeatedly while the number produced (i + 1) is smaller than the length of a side (n in side_len).\nThe bulk of work of solving the puzzle is done by the recursive CTE x(s, ind). An entry in x means that the string s represents a valid Takuzu puzzle up to this point (it does not violate the first two Takuzu rules), and that the first unknown cell is at position ind, or ind = 0 if all cells have been filled in. The goal of the recursion is to compute entries in x with ind = 0, which correspond to complete solutions.\nThe solver works by adding new entries to the recursive table x. For each prior entry, the recursive part tries to fill the first empty position with both possible values (0 and 1). A candidate string is only kept if it satisfies the first two of the three aforementioned Takuzu rules. The complicated looking WHERE clause checks for these rules. They prune the search space by discarding any candidate string that would immediately violate Takuzu rules, so that the recursion only continues with valid partial solutions.\nThe final answer is found by selecting entries where ind = 0, that is, puzzles that have no remaining empty cells, and entries where there are no duplicate rows and columns (the third rule). The check for this third rule is kept outside the CTE x because we can only check for duplicate rows and columns once all cells are filled.\nIf the original puzzle has a unique solution, the query will return a single string representing that solution. If there are multiple solutions, the query will return all of them. If the puzzle is unsolvable, no rows will be returned."
  },
  {
    "objectID": "posts/solving-takuzu-puzzles-with-sql/index.html#running-the-solver",
    "href": "posts/solving-takuzu-puzzles-with-sql/index.html#running-the-solver",
    "title": "Solving Takuzu Puzzles with SQL",
    "section": "Running the solver",
    "text": "Running the solver\nYou can run this query as follows from the command-line:\nsqlite3 &lt; takuzu.sql\nThe output will be the solved puzzle as a single string.\n101100101100100110010011010011010011011001101100100110110010101001001101010110011001011010100110101001010101100101011001011010101010010101100110\nMost modern database engines support recursive CTEs but the syntax might be slightly different. Getting it to run on anything other than SQLite may need some tweaking."
  },
  {
    "objectID": "posts/solving-takuzu-puzzles-with-sql/index.html#some-words-about-efficiency",
    "href": "posts/solving-takuzu-puzzles-with-sql/index.html#some-words-about-efficiency",
    "title": "Solving Takuzu Puzzles with SQL",
    "section": "Some words about efficiency",
    "text": "Some words about efficiency\nThis is definitely not a fast solver and I wouldn‚Äôt recommend using SQL for something like this. It‚Äôs interesting though.\nIt‚Äôs also good to understand what‚Äôs happening under the hood. How we write recursive CTEs might remind you of how we write depth-first search (DFS) backtracking algorithms. In DFS a stack (explicitly or implicitly via recursive function calling) is used to keep track of candidate solutions. However, when we inspect the SQLite source code we can read in the comments that when recursive CTEs are executed, new entries are added via a (FIFO) queue. This, in effect, makes us do breadth-first search (BFS) instead. For the problem we‚Äôre tackling here BFS is exploring many unnecessary shallow candidate solutions. DFS would have been a faster option.\nYou may find the query as a gist here:"
  }
]