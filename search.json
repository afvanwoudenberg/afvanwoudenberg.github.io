[
  {
    "objectID": "posts/soma-cube/index.html",
    "href": "posts/soma-cube/index.html",
    "title": "Soma Cube",
    "section": "",
    "text": "The Soma cube is the brainchild of Danish mathematician, inventor, designer, writer and poet Piet Hein. The puzzle consists of seven pieces and the goal is to assemble these pieces into a 3x3x3 cube or other shapes.\nPiet Hein came up with this puzzle during a lecture on quantum physics by Werner Heisenberg. Instead of paying attention to the renowned theoretical physicist, Piet prefered idling away his time by thinking up frivolous brainteasers. Such a waste, not to mention rude! What’s even worse is that people seemed to actually enjoy his puzzle. This meant that Piet Hein’s invention wasn’t just a time-waster for him but for everyone who got hooked on it.\nInitially, the Soma cube was mostly known in Scandinavian countries, but things took a dark turn when Martin Gardner featured it in his Mathematical Games column in Scientific American in September 1958. Suddenly, the whole world got introduced to this time-waster.\nAs a self-proclaimed restorer of productivity, I hate to see people trifle away their lives trying to solve these inane puzzles. For this reason I’ve created a Soma solver in Python so people can go back to spending time on more fruitful pursuits.\nRead on to learn how I did this."
  },
  {
    "objectID": "posts/soma-cube/index.html#the-soma-puzzle-pieces",
    "href": "posts/soma-cube/index.html#the-soma-puzzle-pieces",
    "title": "Soma Cube",
    "section": "The Soma puzzle pieces",
    "text": "The Soma puzzle pieces\nEach of the seven pieces has a different shape. I’ve given each shape a different color to ease visualizing solutions later on.\n      \nAs mentioned above, the objective is to assemble these pieces into various shapes, like a cube."
  },
  {
    "objectID": "posts/soma-cube/index.html#importing-libraries",
    "href": "posts/soma-cube/index.html#importing-libraries",
    "title": "Soma Cube",
    "section": "Importing libraries",
    "text": "Importing libraries\nLet’s start by importing some libraries. We’ll use matplotlib to visualize solutions in 3D.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport ipywidgets as widgets\n\nfrom IPython.display import HTML\nfrom math import ceil"
  },
  {
    "objectID": "posts/soma-cube/index.html#representing-the-pieces",
    "href": "posts/soma-cube/index.html#representing-the-pieces",
    "title": "Soma Cube",
    "section": "Representing the pieces",
    "text": "Representing the pieces\nWe’ll represent each piece as a list of coordinates in 3D space. Each tuple is an (x, y, z) coordinate.\n\nz = [(0,0,0),(1,0,0),(1,1,0),(2,1,0)] # blue piece\np = [(0,0,0),(0,1,0),(0,1,1),(1,1,0)] # red piece\nt = [(0,0,0),(0,1,0),(1,1,0),(0,2,0)] # purple piece\nb = [(0,0,0),(1,0,0),(0,1,0),(0,1,1)] # brown piece\na = [(0,0,0),(0,0,1),(0,1,0),(1,1,0)] # yellow piece\nl = [(0,0,0),(1,0,0),(2,0,0),(0,1,0)] # orange piece\nv = [(0,0,0),(1,0,0),(0,1,0)] # green piece\n\nThe letters z, t, p, b, a, l, and v look (with some imagination) like the pieces.\nLet’s put all pieces and colors in a list so we can access them by index.\n\npieces = [z, p, t, b, a, l, v]\ncolors = [\"blue\", \"red\", \"purple\", \"brown\", \"yellow\", \"orange\", \"green\"]"
  },
  {
    "objectID": "posts/soma-cube/index.html#visualizing-the-pieces-and-solution",
    "href": "posts/soma-cube/index.html#visualizing-the-pieces-and-solution",
    "title": "Soma Cube",
    "section": "Visualizing the pieces and solution",
    "text": "Visualizing the pieces and solution\nBefore writing the solver, let’s consider how we can create a 3D visualization of the Soma cube. I’ve chosen to use Matplotlib for its 3D rendering capabilities.\nMatplotlib can draw voxels (3D pixels) which we can use to visualize a single piece, multiple pieces, or even the full solution in 3D. The following function takes a 3D numpy array that represents the voxels and plots them.\n\ndef plot_solution(colors, ax=None):\n    if not ax:\n        fig = plt.figure()\n\n        # axis with 3D projection\n        ax = fig.add_subplot(projection='3d')\n        \n    ax.set_aspect('equal')\n    ax.set_axis_off()\n\n    # draw each voxel with a color (each voxel unequal to None)\n    voxels = (colors != None)\n\n    ax.voxels(voxels, facecolors=colors, edgecolors=colors)\n\nTo use this function we need to call it with a 3D numpy array that represents each voxel.\n\nvoxels = np.empty((3,3,3), dtype='object')\n\nEach element in this array is initialized to None.\n\nvoxels\n\narray([[[None, None, None],\n        [None, None, None],\n        [None, None, None]],\n\n       [[None, None, None],\n        [None, None, None],\n        [None, None, None]],\n\n       [[None, None, None],\n        [None, None, None],\n        [None, None, None]]], dtype=object)\n\n\nLet’s set each element of voxels to a color and call plot_solution. We can set elements seperately, like this:\n\nvoxels[0][0][0] = 'yellow'\nvoxels[1][0][0] = 'yellow'\nvoxels[0][0][1] = 'yellow'\nvoxels[0][1][1] = 'yellow'\n\nOr we can set all elements at once.\n\nvoxels = np.array([\n    [['yellow', 'yellow', 'orange'],\n     ['brown',  'yellow', 'orange'],\n     ['brown',  'brown',  'orange']],\n    [['yellow', 'green',  'orange'],\n     ['brown',  'blue',   'blue'],\n     ['blue',   'blue',   'red']],\n    [['purple', 'green',  'green'],\n     ['purple', 'purple', 'red'],\n     ['purple', 'red',    'red']]\n])\n\n\nplot_solution(voxels)\nplt.show()\n\n\n\n\nThis is the same solution as shown above and one of the 240 possible unique ways of packing the seven Soma pieces into a 3x3x3 cube.\nLet’s see how we can visualize a single piece.\n\ndef plot_piece(piece, color, ax=None):\n    max_dim = np.max([np.max(piece) + 1, 3])\n    voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n    for x, y, z in piece:\n        voxels[x][y][z] = color\n    plot_solution(voxels, ax)\n\n\nplot_piece(z, \"blue\")\nplt.show()"
  },
  {
    "objectID": "posts/soma-cube/index.html#animating-a-solution",
    "href": "posts/soma-cube/index.html#animating-a-solution",
    "title": "Soma Cube",
    "section": "Animating a solution",
    "text": "Animating a solution\nIn the solution above it was impossible to tell how some pieces were positioned. The following function animates the assembly of a solution by adding pieces one by one.\n\ndef animate_solution(colors):\n    w, d, h = colors.shape\n    \n    show_order = []\n    for a in range(1,max(w, d, h)+1):\n        for z in range(min(a,h)):\n            for x in range(min(a,w)):\n                for y in range(d-1,d-1-min(a,d),-1):\n                    color = colors[x][y][z]\n                    if not (color is None or color in show_order):\n                        show_order.append(color)\n    \n    fig = plt.figure()\n    \n    ax = fig.add_subplot(projection='3d')\n    \n    def update(frame):\n        ax.clear()\n        ax.set_aspect('equal')\n        ax.set_axis_off()\n        \n        voxels = np.in1d(colors, show_order[:frame+1]).reshape(colors.shape)\n\n        ax.voxels(voxels, facecolors=colors, edgecolors=colors)\n\n    plt.close()\n\n    anim = animation.FuncAnimation(fig, update, frames=len(show_order), interval=1000)\n    \n    return anim\n\n\nanim = animate_solution(voxels)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nNow it’s much clearer how a solution is constructed."
  },
  {
    "objectID": "posts/soma-cube/index.html#rotating-pieces",
    "href": "posts/soma-cube/index.html#rotating-pieces",
    "title": "Soma Cube",
    "section": "Rotating pieces",
    "text": "Rotating pieces\nWe will implement the solver using a simple recursive backtracking algorithm. The solver will try to fit the pieces in their various orientations. For this reason, we define some helper functions to rotate a piece around an axis. I also defined an identity function that just returns the input as is. Its use will become clear later.\n\nrotate_x = lambda cubelets: [(x, z, -y) for (x, y, z) in cubelets]\nrotate_y = lambda cubelets: [(z, y, -x) for (x, y, z) in cubelets]\nrotate_z = lambda cubelets: [(-y, x, z) for (x, y, z) in cubelets]\nidentity = lambda cubelets: cubelets\n\nFor instance, to rotate piece z around the x-axis we can make use of rotate_x.\n\nrotate_x(z)\n\n[(0, 0, 0), (1, 0, 0), (1, 0, -1), (2, 0, -1)]\n\n\nWe can see that rotating a piece may make some coordinates negative. The following function translates a piece so that all x, y, z coordinates are minimal but positive.\n\ndef translate(piece):\n    d_x, d_y, d_z = np.min(np.array(piece), axis=0) * -1\n    return [(x + d_x, y + d_y, z + d_z) for (x, y, z) in piece]\n\nNow we can do the same rotation as above but end up with coordinates that are all positive.\n\ntranslate(rotate_x(z))\n\n[(0, 0, 1), (1, 0, 1), (1, 0, 0), (2, 0, 0)]\n\n\nWe will use this translate function when we display individual pieces."
  },
  {
    "objectID": "posts/soma-cube/index.html#generating-all-orientations-for-each-piece",
    "href": "posts/soma-cube/index.html#generating-all-orientations-for-each-piece",
    "title": "Soma Cube",
    "section": "Generating all orientations for each piece",
    "text": "Generating all orientations for each piece\nUsing the functions defined above we can generate all orientations for each piece. Several transformations are performed one after another. The identity function just returns the original orientation.\n\ndef generate_rotations(piece):\n    orientations = []\n    for f_a in [identity, rotate_x,  rotate_y, rotate_z]:\n        for f_b in [identity, rotate_x,  rotate_y, rotate_z]:\n            for f_c in [identity, rotate_x,  rotate_y, rotate_z]:\n                for f_d in [identity, rotate_x,  rotate_y, rotate_z]:\n                    for f_e in [identity, rotate_x,  rotate_y, rotate_z]:\n                        rot_piece = sorted(f_a(f_b(f_c(f_d(f_e(piece))))))\n                        min_x, min_y, min_z = rot_piece[0]\n                        trans_rot_piece = [(x - min_x, y - min_y, z - min_z) for x, y, z in rot_piece]\n                        if trans_rot_piece not in orientations:\n                            orientations.append(trans_rot_piece)\n                        \n    return orientations\n\nWe can call this function for one piece.\n\ngenerate_rotations(z)\n\n[[(0, 0, 0), (1, 0, 0), (1, 1, 0), (2, 1, 0)],\n [(0, 0, 0), (1, 0, -1), (1, 0, 0), (2, 0, -1)],\n [(0, 0, 0), (0, 0, 1), (0, 1, -1), (0, 1, 0)],\n [(0, 0, 0), (0, 1, 0), (1, -1, 0), (1, 0, 0)],\n [(0, 0, 0), (1, -1, 0), (1, 0, 0), (2, -1, 0)],\n [(0, 0, 0), (0, 1, 0), (0, 1, 1), (0, 2, 1)],\n [(0, 0, 0), (0, 0, 1), (1, 0, 1), (1, 0, 2)],\n [(0, 0, 0), (0, 1, -1), (0, 1, 0), (0, 2, -1)],\n [(0, 0, 0), (1, 0, 0), (1, 0, 1), (2, 0, 1)],\n [(0, 0, 0), (0, 1, 0), (1, 1, 0), (1, 2, 0)],\n [(0, 0, 0), (0, 0, 1), (0, 1, 1), (0, 1, 2)],\n [(0, 0, 0), (0, 0, 1), (1, 0, -1), (1, 0, 0)]]\n\n\nOr we can apply this function to every piece in the pieces list we defined above.\n\norientations = list(map(generate_rotations, pieces))\n\nWe can display all orientations for each piece. Note how we apply translate to make sure all coordinates end up in the positive quadrant.\n\ncols = 8\ntotal_number_of_orientations = sum(list(map(len,orientations)))\nrows = ceil(total_number_of_orientations / cols)\nfig, axs = plt.subplots(rows, cols, figsize=(cols*3,rows*3), \n    subplot_kw= { 'projection':'3d' }, gridspec_kw = {'wspace':0.0, 'hspace':0.0})\n\nfig.subplots_adjust(top=0.96)\nfig.suptitle(f\"Orientations\", fontsize=16)\n\ncount = 0\nfor i in range(len(pieces)):\n    for j in range(len(orientations[i])):\n        plot_piece(translate(orientations[i][j]), colors[i], axs[count // cols, count % cols])\n        count += 1\n\nwhile count &lt; cols * rows:\n    axs[count // cols, count % cols].set_axis_off()\n    count += 1\n\nplt.show()\n\n\n\n\nIn the solver below, for each piece we’ll see which orientation fits where."
  },
  {
    "objectID": "posts/soma-cube/index.html#writing-the-solver",
    "href": "posts/soma-cube/index.html#writing-the-solver",
    "title": "Soma Cube",
    "section": "Writing the solver",
    "text": "Writing the solver\nWe’re finally ready to work on the solver for the Soma cube. The solver will take in a list of coordinates (that make up the cube that we want to fill up with pieces) and recursively search for a solution.\nWe can generate this list of coordinates using a simple list comprehension.\n\ncube_coordinates = [(x, y, z) for x in range(3) for y in range(3) for z in range(3)]\n\n\ncube_coordinates\n\n[(0, 0, 0),\n (0, 0, 1),\n (0, 0, 2),\n (0, 1, 0),\n (0, 1, 1),\n (0, 1, 2),\n (0, 2, 0),\n (0, 2, 1),\n (0, 2, 2),\n (1, 0, 0),\n (1, 0, 1),\n (1, 0, 2),\n (1, 1, 0),\n (1, 1, 1),\n (1, 1, 2),\n (1, 2, 0),\n (1, 2, 1),\n (1, 2, 2),\n (2, 0, 0),\n (2, 0, 1),\n (2, 0, 2),\n (2, 1, 0),\n (2, 1, 1),\n (2, 1, 2),\n (2, 2, 0),\n (2, 2, 1),\n (2, 2, 2)]\n\n\nThe solver will yield the same list but each tuple will have an extra element indicating the color that coordinate will get after all pieces have been placed.\nWe’ll use a list of booleans to keep track of which pieces have been placed.\n\npieces_used = [False] * 7\n\n\ndef solve_soma_(solution, i):\n    if i == 27:\n        yield solution\n    else:\n        x, y, z, _ = solution[i]\n        for piece in range(7):\n            if not pieces_used[piece]:\n                for orientation in orientations[piece]:\n                    empty_coords = [(x + d_x, y + d_y, z + d_z, None) for (d_x, d_y, d_z) in orientation]\n                    if all([tup in solution for tup in empty_coords]):\n                        # placing piece: replace None with color\n                        pieces_used[piece] = True\n                        filled_coords = [(x + d_x, y + d_y, z + d_z, colors[piece]) for (d_x, d_y, d_z) in orientation]\n                        new_solution = sorted([tup for tup in solution if tup not in empty_coords] + filled_coords)\n                        \n                        # find next empty coordinate\n                        j = i\n                        while j &lt; 27 and new_solution[j][3]:\n                            j += 1\n                            \n                        # continue search\n                        yield from solve_soma_(new_solution, j)\n                        pieces_used[piece] = False\n\n\ndef solve_soma(coordinates):\n    global pieces_used\n    pieces_used = [False] * 7\n    \n    solution = sorted([(x, y, z, None) for x, y, z in coordinates])\n    yield from solve_soma_(solution, 0)\n\nYou call the solve_soma function with a list of coordinates representing the space that will be packed with Soma pieces. The actual algorithm is implemented in solve_soma_. The algorithm does the following:\n\nIt checks if all coordinates are filled. If so, it yields the solution.\nFor each possible orientation of a piece, it checks if it can be placed from the current coordinate without overlapping with filled coordinates that are already in the solution.\nIf a valid placement is found, it recursively explores how to fill from the next empty coordinate.\nAfter exploring a piece and its orientation, it tries other possibilities.\n\nDifferent solutions may be duplicates of each other in the sense that one solution is a rotation of another."
  },
  {
    "objectID": "posts/soma-cube/index.html#finding-and-displaying-a-solution",
    "href": "posts/soma-cube/index.html#finding-and-displaying-a-solution",
    "title": "Soma Cube",
    "section": "Finding and displaying a solution",
    "text": "Finding and displaying a solution\nThe solver is a generator function that yields all solutions one by one. Let’s start by just displaying the first solution it finds.\nThe following function finds the first solution given a list of coordinates to fill and plots this solution.\n\ndef solve_and_plot_first_solution(coordinates, ax=None):\n    # instantiate generator\n    gen = solve_soma(coordinates)\n\n    # find first solution\n    solution = next(gen)\n\n    # find voxel space size\n    max_dim = np.max(coordinates) + 1\n\n    # fill 3D voxel array and plot it\n    voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n    for x, y, z, color in solution:\n        voxels[x][y][z] = color\n\n    plot_solution(voxels, ax)\n\n\nsolve_and_plot_first_solution(cube_coordinates)\nplt.show()\n\n\n\n\nWe’ll also define a function that finds the first solution and then animates it.\n\ndef solve_and_animate_first_solution(coordinates):\n    # instantiate generator\n    gen = solve_soma(coordinates)\n\n    # find first solution\n    solution = next(gen)\n\n    # find voxel space size\n    max_dim = np.max(coordinates) + 1\n\n    # fill 3D voxel array and plot it\n    voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n    for x, y, z, color in solution:\n        voxels[x][y][z] = color\n\n    anim = animate_solution(voxels)\n    display(HTML(anim.to_jshtml(default_mode='once')))\n\n\nsolve_and_animate_first_solution(cube_coordinates)\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect"
  },
  {
    "objectID": "posts/soma-cube/index.html#creating-other-figures",
    "href": "posts/soma-cube/index.html#creating-other-figures",
    "title": "Soma Cube",
    "section": "Creating other figures",
    "text": "Creating other figures\nWe called the solver with cube_coordinates that contains the coordinates that make up a cube. Instead of a cube, we can also pass a sorted list of coordinates that make up another shape.\nLet’s look at some examples.\n\npyramid_coordinates = sorted(\n    [(x, y, 0) for x in range(1, 4) for y in range(5)] + \n    [(x, y, 0) for x in [0, 4] for y in range(1, 4)] +\n    [(2, y, 1) for y in range(1, 4)] + \n    [(1, 2, 1), (3, 2, 1), (2, 2, 2)]\n)\n\nturtle_coordinates = sorted(\n    [(x, y, z) for x in range(1, 4) for y in range(1, 4) for z in range(2)] +\n    [(4, 2, z) for z in range(3)] + \n    [(0, 2, 0), (1, 0, 0), (1, 4, 0), (3, 0, 0), (3, 4, 0), (5, 2, 2)]\n)\n\ntower_coordinates = sorted(\n    [(x, y, z) for x in range(2) for y in range(2) for z in range(7) if (x, y, z) != (1, 0, 6)]\n)\n\nbear_coordinates = sorted(\n    [(x, y, 0) for x in range(3) for y in range(2)] +\n    [(x, 1, z) for x in range(3) for z in range(1, 6)] + \n    [(x, 0, z) for x in [0, 2] for z in [1, 3, 4]]\n)\n\ntunnel_coordinates = sorted(\n    [(x, y, 0) for x in range(5) for y in range(3) if x != 2] +\n    [(x, y, 1) for x in range(1, 4) for y in range(3) if x != 2] +\n    [(x, y, 2) for x in range(1, 4) for y in range(3)]\n)\n\ntub_coordinates = sorted(\n    [(x, y, 0) for x in range(5) for y in range(3)] +\n    [(x, y, 1) for x in range(5) for y in range(3) if x in [0, 4] or y in [0, 2]]\n)\n\nairplane_coordinates = sorted(\n    [(x, y, 0) for x in range(1, 6) for y in range(7) if x == 3 or y in [0, 1]] +\n    [(x, y, 1) for x in range(7) for y in range(7) if y == 0 or (x == 3 and y != 5)]\n)\n\nbench_coordinates = sorted(\n    [(x, y, z) for x in range(5) for y in range(2) for z in range(3) if y == 1 or x in [0, 4]] +\n    [(x, 0, 1) for x in range(1, 4)] +\n    [(x, 1, 3) for x in range(1, 4)]\n)\n\nduck_coordinates = sorted(\n    [(x, y, z) for x in range(4) for y in range(3) for z in range(2)] +\n    [(3, 1, 2), (3, 1, 3), (4, 1, 3)]\n)\n\ncascade_coordinates = sorted(\n    [(x, y, z) for x in range(3) for y in range(3) for z in range(5) if (2-x) + y &gt;= z]\n)\n\nchair_coordinates = sorted(\n    [(x, y, z) for x in range(3) for y in range(3) for z in range(2)] +\n    [(x, 2, z) for x in range(3) for z in range(2, 5)]\n)\n\ncastle_coordinates = sorted(\n    [(x, y, 0) for x in range(5) for y in range(5) if (x, y) not in [(0,2), (4,2)]] +\n    [(0, 0, 1), (0, 4, 1), (4, 0, 1), (4, 4, 1)]\n)\n\ndog_coordinates = sorted(\n    [(x, y, 0) for x in range(6) for y in range(3) if (x, y) not in [(3, 0), (3, 2), (5, 1)]] +\n    [(x, y, 1) for x in range(5) for y in range(3) if x == 4 or y == 1] +\n    [(x, 1, z) for x in range(3, 6) for z in range(2, 4) if (x, z) != (5, 3)]\n)\n\ncross_coordinates = sorted(\n    [(x, y, z) for x in range(3) for y in range(3) for z in range(2)] +\n    [(1, y, 2) for y in range(3)] +\n    [(1, 1, z) for z in range(3, 7)] + \n    [(0, 1, 5), (2, 1, 5)]\n)\n\nelephant_coordinates = sorted(\n    [(0, 0, 0), (3, 0, 0), (0, 2, 0), (3, 2, 0)] + \n    [(x, y, 1) for x in range(4) for y in range(3) if (x, y) != (3, 1)] +\n    [(x, 1, z) for x in range(5) for z in range(2, 4) if (x, z) != (0, 3)] +\n    [(4, 1, 1), (2, 0, 2), (2, 2, 2)]\n)\n\nstairs_coordinates = sorted(\n    [(x, y, z) for y in range(3) for z in range(3) for x in range(4-z)]\n)\n\nsnake_coordinates = sorted(\n    [(x, y, z) for y in range(4) for z in range(2) for x in range(2*(3-y), (2*(3-y))+3)] +\n    [(x, 0, z) for x in range(8, 10) for z in range(2, 4) if x == 8 or z == 3]\n)\n\nskyscraper_coordinates = sorted(\n    [(x, y, 0) for x in range(3) for y in range(3)] +\n    [(x, y, z) for x in range(2) for y in range(1, 3) for z in range(1, 5)] + \n    [(1, 1, 5), (1, 1, 6)]\n)\n\nwall_coordinates = sorted(\n    [(x, x - 1, 0) for x in range(1, 6)] +\n    [(x, x, z) for x in range(6) for z in range(2)] +\n    [(x, x + 1, z) for x in range(5) for z in range(2)]\n)\n\nLet’s place these figures and their names into lists.\n\nfigure_names = [\"Cube\", \"Pyramid\", \"Turtle\", \"Tower\", \"Bear\", \"Tunnel\", \"Tub\", \"Airplane\", \n                \"Bench\", \"Duck\", \"Cascade\", \"Chair\", \"Castle\", \"Dog\", \"Cross\", \"Elephant\",\n                \"Stairs\", \"Snake\", \"Skyscraper\", \"Wall\"\n               ]\nfigure_coordinates = [\n    cube_coordinates, pyramid_coordinates, turtle_coordinates, \n    tower_coordinates, bear_coordinates, tunnel_coordinates,\n    tub_coordinates, airplane_coordinates, bench_coordinates,\n    duck_coordinates, cascade_coordinates, chair_coordinates,\n    castle_coordinates, dog_coordinates, cross_coordinates,\n    elephant_coordinates, stairs_coordinates, snake_coordinates,\n    skyscraper_coordinates, wall_coordinates\n]\n\nYou can add more figures if you want. Just make sure that each list contains exactly 27 coordinates.\nWe can plot all figures as subplots.\n\ncols = 5\nnumber_of_figures = len(figure_coordinates)\nrows = ceil(number_of_figures / cols)\nfig, axs = plt.subplots(rows, cols, figsize=(cols*3,rows*3), \n    subplot_kw= { 'projection':'3d' }, gridspec_kw = {'wspace':0.5, 'hspace':0.0})\n\nfig.suptitle(f\"Figures\", fontsize=16)\n\ncount = 0\nfor i in range(number_of_figures):\n    solve_and_plot_first_solution(figure_coordinates[i], axs[count // cols, count % cols])\n    axs[count // cols, count % cols].set_title(figure_names[i])\n    count += 1\n\nwhile count &lt; cols * rows:\n    axs[count // cols, count % cols].set_axis_off()\n    count += 1\n\nplt.show()\n\n\n\n\nI have to admit that some figures are pretty cute."
  },
  {
    "objectID": "posts/soma-cube/index.html#showing-solutions-one-by-one",
    "href": "posts/soma-cube/index.html#showing-solutions-one-by-one",
    "title": "Soma Cube",
    "section": "Showing solutions one by one",
    "text": "Showing solutions one by one\nMost figures can be assembled in more than one way. Using some widgets we can put together a simple GUI that lets us select a figure, solve it and iterate over the solutions.\nWe’ll use a dropdown menu, a button, an output widget, and a label widget. The solutions are shown as an animation we can step through.\nfigure_dropdown = widgets.Dropdown(options=zip(figure_names, figure_coordinates), value=cube_coordinates, description=\"Figure: \")\nnext_button = widgets.Button(description=\"Next\")\nhbox = widgets.HBox([figure_dropdown, next_button])\noutput = widgets.Output()\nlabel = widgets.Label()\n\ndisplay(hbox, output, label)\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nTo keep track of which solution to show next, we declare the following global variables:\ngen = None\nsolution = None\nThe gen is a generator object that generates solutions for a given figure using the solve_soma function. The solution variable stores the next solution to be displayed. It is updated each time the “Next” button is clicked to display the next solution.\ndef figure_dropdown_change(change):\n    global gen\n    global solution\n    \n    if change['type'] == 'change' and change['name'] == 'value':\n        value = change['new']\n        next_button.layout.display = 'none'\n        \n        output.clear_output()\n        \n        gen = solve_soma(value)\n        try:\n            solution = next(gen)            \n            with output:\n                # find voxel space size\n                max_dim = np.max(value) + 1\n\n                # fill 3D voxel array and plot it\n                voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n                for x, y, z, color in solution:\n                    voxels[x][y][z] = color\n\n                anim = animate_solution(voxels)\n                display(HTML(anim.to_jshtml(default_mode='once')))\n        except StopIteration:\n            label.value = \"No solutions found.\"\n            return\n\n        try:\n            solution = next(gen).copy()\n            label.value = \"\"\n            next_button.layout.display = 'inline-block'\n        except StopIteration:\n            label.value = \"\"\n\nfigure_dropdown.observe(figure_dropdown_change)\nThe figure_dropdown_change function handles changes to the figure dropdown menu. It clears the output widget, displays the first solution, and stores the next solution in the solution variable (if any).\ndef on_next_button_clicked(b):\n    global gen\n    global solution\n    \n    output.clear_output(wait=True)\n    with output:\n        # find voxel space size\n        max_dim = np.max(figure_dropdown.value) + 1\n\n        # fill 3D voxel array and plot it\n        voxels = np.empty((max_dim, max_dim, max_dim), dtype='object')\n        for x, y, z, color in solution:\n            voxels[x][y][z] = color\n\n        anim = animate_solution(voxels)\n        display(HTML(anim.to_jshtml(default_mode='once')))\n    \n    try:\n        solution = next(gen)\n    except StopIteration:\n        label.value = \"\"\n        next_button.layout.display = 'none'\n\nnext_button.on_click(on_next_button_clicked)\n\nfigure_dropdown_change({'type': 'change', 'name': 'value', 'new': figure_dropdown.value})\nThe on_next_button_clicked function handles clicks on the “Next” button by clearing the output widget, displaying the current solution, and generating the next solution."
  },
  {
    "objectID": "posts/soma-cube/index.html#solving-your-own-soma-puzzles",
    "href": "posts/soma-cube/index.html#solving-your-own-soma-puzzles",
    "title": "Soma Cube",
    "section": "Solving your own Soma puzzles",
    "text": "Solving your own Soma puzzles\nThere you have it! No more wasting time on solving Soma puzzles. If you want to experiment with an interactive version of the solver, you can check out on of the following links:\n  \nNow go do something useful!"
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html",
    "href": "posts/pictionary-air-mouse/index.html",
    "title": "Pictionary Air Mouse",
    "section": "",
    "text": "Pictionary Air is a modern take on the classic Pictionary game in which players draw in the air with an electronic pen instead of on paper. Using a special AR app on a smartphone or tablet teammates can see what is being drawn.\nI wanted to use the Pictionary Air pen with my laptop instead of my phone so I could play Pictionary on a larger screen, or use the pen as an alternative input device.\nRead on to learn how I did this."
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html#the-general-approach",
    "href": "posts/pictionary-air-mouse/index.html#the-general-approach",
    "title": "Pictionary Air Mouse",
    "section": "The general approach",
    "text": "The general approach\nThe Pictionary Air pen has a tip that can light up green or red. If you turn on the pen it lights up red. Pressing a button on the pen, turns the tip green, effectively putting it in drawing mode. To detect the position and color of the tip, we can use the webcam to capture real-time video and process it with OpenCV. We can apply color masking to isolate the red and green colors used by the pen.\nTo do color masking, we use OpenCV’s inRange() function to create a binary mask for each color we want to detect. The function takes a single frame and a range of colors we want to include in our mask. This range is specified as a lower and upper color threshold, which helps us include only pixels with values within a specified range. Pixels outside of this range are set to black in the mask, while pixels inside the range are set to white.\nFor instance, to create a mask that match all green pixels, we would write:\n# convert a frame to HSV color space\nhsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n\n# setting the lower and upper range for mask_green\nlower_green = np.array([55, 40, 40])\nupper_green = np.array([95, 255, 255])\nmask_green = cv2.inRange(hsv, lower_green, upper_green)\nNote that in this code, we first convert a camera frame (which is, by default, in BGR color space) to HSV color space. Using HSV color space makes creating a mask easier because HSV separates color information from brightness information.\nOnce we have our masks, we use the findContours() function to detect any contours in the binary images. Contours are the boundaries of objects with similar color or intensity values, so we can use them to locate the tip of the Pictionary Air pen. The function returns a list of contours, and we use the contourArea() function to find the contour with the largest area, which is likely to be the pen’s tip.\ncontours, _ = cv2.findContours(mask_green.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n# if the contours are formed\nif len(contours) &gt; 0:\n    # find the largest contour \n    contour = sorted(contours, key = cv2.contourArea, reverse = True)[0] \nAfter locating the pen’s tip, we can calculate its position and move the mouse pointer to the corresponding location on the screen. Additionally, we simulate a left-click by pressing and releasing the left mouse button when a green tip is detected and lost, respectively.\n    # get the radius and position of the enclosing circle\n    ((x, y), _) = cv2.minEnclosingCircle(contour)\n    x, y = int(x), int(y)\n\n    # move the mouse\n    mouse.position = (int(x * factor_x), int(y * factor_y))\n    # press the button is not pressed already\n    if not pressed:\n        pressed = True\n        mouse.press(Button.left)"
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html#one-slight-hurdle",
    "href": "posts/pictionary-air-mouse/index.html#one-slight-hurdle",
    "title": "Pictionary Air Mouse",
    "section": "One slight hurdle",
    "text": "One slight hurdle\nPlease take a look at the picture, taken through my webcam, of me holding a Pictionary Air pen:\n\nIs there anything that stands out to you? Is it my handsome face, my wrinkled shirt, or my messy bookcase?\nNotice the tip of the pen. Can you tell its color? It’s impossible to discern because bright light sources appear as white when seen through my laptop’s webcam. Unfortunately, this creates an issue since we need to accurately detect whether the pen’s tip is red or green."
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html#a-simple-solution",
    "href": "posts/pictionary-air-mouse/index.html#a-simple-solution",
    "title": "Pictionary Air Mouse",
    "section": "A simple solution",
    "text": "A simple solution\nThe solution is luckily quite simple. We just shorten the exposure time of the webcam.\nFor this, we can use the v4l2-ctl Linux command line tool.\nv4l2-ctl -c auto_exposure=1 -c exposure_dynamic_framerate=0 -c exposure_time_absolute=10\nThe picture now looks like this:\n\nAfter adjusting the exposure time, we can clearly see the color of the tip of the pen. Pressing the button on the pen turns its tip green.\n\nNow we can easily detect the position and color of the pen using the approach explained above. Additionally, shortening the exposure time hides irrelevant objects, such as my red shirt, that could throw off the detection algorithm."
  },
  {
    "objectID": "posts/pictionary-air-mouse/index.html#see-it-in-action",
    "href": "posts/pictionary-air-mouse/index.html#see-it-in-action",
    "title": "Pictionary Air Mouse",
    "section": "See it in action",
    "text": "See it in action\nCheck out the video below to see it in action.\n\nFor the complete program check out this repository. You don’t need to first adjust the exposure time before running the program. The Python program calls v4l2-ctl for you.\nThis program runs fine on my laptop, but you likely need to adjust webcam settings to make it work for you. Also, you need to run Linux. If this program doesn’t seem to function, try experimenting with the parameters in the calls that are made to the v4l2-ctl tool in the set_short_exposure_time and restore_camera_settings functions.\nEnter v4l2-ctl --all on the command line to see the available options."
  },
  {
    "objectID": "posts/skyline-puzzle/index.html",
    "href": "posts/skyline-puzzle/index.html",
    "title": "Skyline Puzzle",
    "section": "",
    "text": "A coworker of mine recently introduced me to this puzzle:\nThe puzzle is called Skyline and it’s a packing puzzle. The objective is to place the metal rod in one of the holes in the base and place the nine wooden pieces around it. It was designed by Jean Claude Constantin.\nWhen solved, the puzzle looks something like this:\nIn this blog post I present some Prolog code to generate all solutions for each rod position."
  },
  {
    "objectID": "posts/skyline-puzzle/index.html#solving-this-puzzle-using-prolog",
    "href": "posts/skyline-puzzle/index.html#solving-this-puzzle-using-prolog",
    "title": "Skyline Puzzle",
    "section": "Solving this puzzle using Prolog",
    "text": "Solving this puzzle using Prolog\nIt’s a breeze to program a Skyline solver using Prolog’s built-in backtracking mechanism.\n\n\nskyline.pl\n\n% A Prolog solver for the Skyline puzzle\n% http://www.constantin-jean-clau.de/\n\nprint_solution(X,Y) :- solve(X,Y,Sol), print_board(Sol).\n\npos(X,Y,_) :- member(X,[1,2,3,4,5,6,7]), member(Y,[1,2,3,4,5,6,7]).\n\nboard(Board) :- findall(pos(X,Y,_),pos(X,Y,_),Board).\n\nsolve(X,Y,Board) :- \n    board(Board), \n    member(pos(X,Y,' '),Board),\n    solve(1,1,Board,[]).\n\nsolve(7,7,_,_) :- !.\nsolve(8,Y,Board,Placed) :-\n    Yn is Y + 1,\n    solve(1,Yn,Board,Placed), !.\nsolve(X,Y,Board,Placed) :-\n    member(pos(X,Y,V),Board),\n    nonvar(V),\n    Xn is X + 1,\n    solve(Xn,Y,Board,Placed).\nsolve(X,Y,Board,Placed) :-\n    member(pos(X,Y,V),Board),\n    var(V),\n    member(Piece,[i,g,h,f,e,d,a,c,b]),\n    not(member(Piece,Placed)),\n    piece(Piece,Locs),\n    place_piece(Piece,X,Y,Locs,Board),\n    Xn is X + 1,\n    solve(Xn,Y,Board,[Piece|Placed]).\n\nprint_board(Board) :- \n    write('+-------+'), nl,\n    findall(_,(member(Y,[1,2,3,4,5,6,7]),print_line(Y,Board)),_),\n    write('+-------+'), nl.\n\nprint_line(Y,Board) :- \n    write('|'), \n    findall(_,(member(X,[1,2,3,4,5,6,7]),print_piece(X,Y,Board)),_), \n    write('|'),\n    nl.\n\nprint_piece(X,Y,Board) :- \n    member(pos(X,Y,P),Board), \n    not(var(P)),\n    write(P), !.\nprint_piece(_,_,_) :- \n    write('_').\n\nplace_piece(_,_,_,[],_).\nplace_piece(Piece,X0,Y0,[(Xd,Yd)|Locs],Board) :-\n    X is X0 + Xd, X &gt; 0, X =&lt; 7, \n    Y is Y0 + Yd, Y &gt; 0, Y =&lt; 7,\n    member(pos(X,Y,Piece),Board),\n    place_piece(Piece,X0,Y0,Locs,Board).\n\npiece(a,[(0,0),(0,1),(0,2),(0,3),(0,4)]).\npiece(a,[(0,0),(1,0),(2,0),(3,0),(4,0)]).\n\npiece(b,[(0,0),(1,0)]).\npiece(b,[(0,0),(0,1)]).\n\npiece(c,[(0,0),(-1,1),(0,1),(1,1)]).\npiece(c,[(0,0),(1,0),(1,1),(2,0)]).\npiece(c,[(0,0),(0,1),(-1,1),(0,2)]).\npiece(c,[(0,0),(0,1),(1,1),(0,2)]).\n\npiece(d,[(0,0),(0,1),(1,1),(1,2),(2,2)]).\npiece(d,[(0,0),(1,0),(-1,1),(0,1),(-1,2)]).\npiece(d,[(0,0),(1,0),(1,1),(2,1),(2,2)]). \npiece(d,[(0,0),(-1,1),(0,1),(-2,2),(-1,2)]).\n\npiece(e,[(0,0),(0,1),(0,2),(0,3),(1,1)]).\npiece(e,[(0,0),(1,0),(2,0),(3,0),(2,1)]).\npiece(e,[(0,0),(0,1),(0,2),(0,3),(-1,2)]).\npiece(e,[(0,0),(-1,1),(0,1),(1,1),(2,1)]).\n\npiece(f,[(0,0),(-1,1),(0,1),(-2,2),(-1,2),(0,2)]).\npiece(f,[(0,0),(0,1),(1,1),(0,2),(1,2),(2,2)]).\npiece(f,[(0,0),(1,0),(2,0),(0,1),(1,1),(0,2)]).\npiece(f,[(0,0),(1,0),(2,0),(1,1),(2,1),(2,2)]).\n\npiece(g,[(0,0),(1,0),(0,1),(1,1),(2,1),(0,2),(1,2)]).\npiece(g,[(0,0),(1,0),(2,0),(0,1),(1,1),(2,1),(1,2)]).\npiece(g,[(0,0),(1,0),(-1,1),(0,1),(1,1),(0,2),(1,2)]).\npiece(g,[(0,0),(-1,1),(0,1),(1,1),(-1,2),(0,2),(1,2)]).\n\npiece(h,[(0,0),(0,1),(0,2),(0,3),(1,1),(1,2)]).\npiece(h,[(0,0),(1,0),(2,0),(3,0),(1,1),(2,1)]).\npiece(h,[(0,0),(-1,1),(0,1),(-1,2),(0,2),(0,3)]).\npiece(h,[(0,0),(1,0),(-1,1),(0,1),(1,1),(2,1)]).\n\npiece(i,[(0,0),(-2,1),(-1,1),(0,1),(-2,2),(-1,2),(0,2),(-1,3)]).\npiece(i,[(0,0),(1,0),(-1,1),(0,1),(1,1),(0,2),(1,2),(2,2)]).\npiece(i,[(0,0),(-1,1),(0,1),(1,1),(-1,2),(0,2),(1,2),(-1,3)]).\npiece(i,[(0,0),(1,0),(2,0),(1,1),(2,1),(3,1),(1,2),(2,2)]).\n\nYou can find a copy of this code as a GitHub gist here.\nThe solve/3 predicate is the main predicate that solves the puzzle. It takes as input the X and Y coordinates of the empty cell on the board and returns a solution, which is a list of pos(X,Y,P) terms representing the placement of the pieces on the board. The solve/4 predicate is a helper predicate that recursively places the pieces on the board.\nThe program also includes several other predicates that define the properties of the puzzle, such as the shape and size of each piece, and the rules for placing the pieces on the board. The piece/2 predicate defines the shape of each piece, and the place_piece/5 predicate checks whether a piece can be placed on a given location on the board.\nFinally, the print_board/1 predicate is used to print the solution to the puzzle in a readable format."
  },
  {
    "objectID": "posts/skyline-puzzle/index.html#how-to-use-this-solver",
    "href": "posts/skyline-puzzle/index.html#how-to-use-this-solver",
    "title": "Skyline Puzzle",
    "section": "How to use this solver",
    "text": "How to use this solver\nTo use this program, open the skyline.pl file in your preferred Prolog interpreter (I personally prefer SWI-Prolog). To find find a solution for when the metal rod is in position (4, 4), simply type the following:\nprint_solution(4,4).\n+-------+\n|ggeeeeh|\n|gggdehh|\n|ggiddhh|\n|iii ddh|\n|iiicfff|\n|bicccff|\n|baaaaaf|\n+-------+\ntrue\nThe helper predicate print_solution/2 calls the solve/3 to solve and print_board/1 to display the solution.\nYou can press ; to find alternative solutions.\nIf you want to see all solutions for a given rod position, you can type:\nfindall(_,print_solution(4,4),_)."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html",
    "href": "posts/from-procrastination-to-productivity/index.html",
    "title": "From Procrastination to Productivity",
    "section": "",
    "text": "We’ve all been there - you sit down at your computer with the intention of getting work done, but suddenly find yourself lost in a rabbit hole of endless browsing. But what exactly are you doing when you’re procrastinating online?\nI decided to look into my own browser history to get better insight into my browsing behavior and hopefully build better habits.\nChrome, which is the browser I use, stores its history (like most browsers) in an SQLite database. This database can be queried from Python using the sqlite3 package. I use pandas for data manipulation and matplotlib and wordcloud to create visualizations.\nI wanted to answer questions, such as:\nRead on if you want to see my embarrasing browsing habits being visualized or want to learn how to analyze your own data."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#importing-libraries",
    "href": "posts/from-procrastination-to-productivity/index.html#importing-libraries",
    "title": "From Procrastination to Productivity",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe’ll start by importing sqlite3, pandas, matplotlib and some other packages.\n\nimport os\nimport sqlite3\nimport time\nimport datetime\nimport tzlocal\nimport math\nimport calendar\n\nimport pandas as pd\nimport numpy as np\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FixedLocator, MaxNLocator\n%matplotlib inline\n\nfrom IPython.display import display, HTML\nfrom urllib.parse import urlparse\nfrom pathlib import Path\nfrom wordcloud import WordCloud\nfrom ipywidgets import interact"
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#reading-database-tables",
    "href": "posts/from-procrastination-to-productivity/index.html#reading-database-tables",
    "title": "From Procrastination to Productivity",
    "section": "Reading database tables",
    "text": "Reading database tables\nOn Linux, the Chrome history database is stored in the ~/.config/google-chrome/Default/History file. If you’re on a different OS, or are using multiple profiles, you will have to update this path.\ndb_path = os.path.expanduser(\"~/.config/google-chrome/Default/History\")\nWe connect to this database using the sqlite3 driver. To open this file read-only, immutable needs to be set to 1. This not only prevents accidental changes, but also allows reading the database file when it’s locked by the Chrome browser.\n\ncon = sqlite3.connect(f\"file:{db_path}?immutable=1\", uri=True)\n\nLet’s look at what tables are stored in this database file.\n\n(pd.read_sql_query(\"SELECT name FROM sqlite_master WHERE type='table';\", con)\n    .sort_values('name')\n    .style.hide(axis='index'))\n\n\n\n\n\n\nname\n\n\n\n\ncluster_keywords\n\n\ncluster_visit_duplicates\n\n\nclusters\n\n\nclusters_and_visits\n\n\ncontent_annotations\n\n\ncontext_annotations\n\n\ndownloads\n\n\ndownloads_slices\n\n\ndownloads_url_chains\n\n\nhistory_sync_metadata\n\n\nkeyword_search_terms\n\n\nmeta\n\n\nsegment_usage\n\n\nsegments\n\n\nsqlite_sequence\n\n\ntyped_url_sync_metadata\n\n\nurls\n\n\nvisit_source\n\n\nvisits\n\n\n\n\n\nWe’ll read in tables using Pandas and explore their contents. There are quite a few tables, but I’ll only focus on a few of them.\n\ndownloads = pd.read_sql_query(\"SELECT * FROM downloads;\", con)\nkeyword_search_terms = pd.read_sql_query(\"SELECT * FROM keyword_search_terms;\", con)\nurls = pd.read_sql_query(\"SELECT * FROM urls;\", con)\nvisits = pd.read_sql_query(\"SELECT * FROM visits;\", con)\n\nAfter reading in the data we can close the database connection.\n\ncon.close()\n\nThere’s a limit to how much history is saved to these tables. We won’t be able to go years back unless we periodically backup the database. I won’t do that in this post though."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#common-search-terms",
    "href": "posts/from-procrastination-to-productivity/index.html#common-search-terms",
    "title": "From Procrastination to Productivity",
    "section": "Common search terms",
    "text": "Common search terms\nA browser session often starts with a (Google) search. Let’s visualize what common search terms I am using. I’ll do this using a word cloud.\nThe Chrome history database contains a keyword_search_terms table that records keywords that have been entered into search boxes. It has the following structure:\n\nkeyword_search_terms.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 4832 entries, 0 to 4831\nData columns (total 4 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   keyword_id       4832 non-null   int64 \n 1   url_id           4832 non-null   int64 \n 2   term             4832 non-null   object\n 3   normalized_term  4832 non-null   object\ndtypes: int64(2), object(2)\nmemory usage: 151.1+ KB\n\n\nThe url_id is a foreign key that links to records in the urls table. The urls table has the following structure:\n\nurls.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 11645 entries, 0 to 11644\nData columns (total 7 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   id               11645 non-null  int64 \n 1   url              11645 non-null  object\n 2   title            11645 non-null  object\n 3   visit_count      11645 non-null  int64 \n 4   typed_count      11645 non-null  int64 \n 5   last_visit_time  11645 non-null  int64 \n 6   hidden           11645 non-null  int64 \ndtypes: int64(5), object(2)\nmemory usage: 637.0+ KB\n\n\nThe urls table contains the actual URL and some other attributes. We could join the keyword_search_terms and urls tables using SQL, but here I’ll use Pandas’ merge method instead.\n\nkeyword_search_terms_urls = pd.merge(left=keyword_search_terms, right=urls, left_on='url_id', right_on='id')\n\nI want to be able to visualize what search terms I use per search box seperately. So I want to see which keywords I entered on Google, which ones I entered on YouTube, which ones on Bing, etc. I order to do this I’ll extract the network location from the URL. This becomes a new column in the dataframe called netloc.\n\nkeyword_search_terms_urls['netloc'] = keyword_search_terms_urls.url.map(lambda r: urlparse(r).netloc)\n\nI’ll use an dropdown widget to select the website I searched on and plot the word cloud.\n@interact(netloc=widgets.Dropdown(options=keyword_search_terms_urls.netloc.unique(), description='Website:'))\ndef search_wordcloud(netloc):\n    # Join all keywords into one lengthy string\n    keywords = ' '.join(keyword_search_terms_urls.query('netloc == @netloc').normalized_term)\n    width, height = 1200, 600 # Size of the word cloud\n    \n    px = 1/plt.rcParams['figure.dpi']  # pixel in inches    \n    fig, ax = plt.subplots(figsize=(width*px, height*px), subplot_kw={'xticks': [], 'yticks': []})\n\n    wordcloud = WordCloud(background_color=\"white\", width=width, height=height).generate_from_text(keywords)\n    ax.set_title(netloc)\n    ax.imshow(wordcloud, interpolation='bilinear', aspect='auto')\n    plt.show()\n\n\n\n\n\n\n\n\nMost searches, at least the ones on Google seem to be data science related. I recently hiked the Great Glen Way in Scotland so you can see some searches related to that."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#most-visited-websites",
    "href": "posts/from-procrastination-to-productivity/index.html#most-visited-websites",
    "title": "From Procrastination to Productivity",
    "section": "Most visited websites",
    "text": "Most visited websites\nLet’s see what websites I visit most. I’ll look at both how much time I spend on these websites and how frequently I visit them.\n\nMost visited websites by time spent\nThe visits table has the following structure:\n\nvisits.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 23181 entries, 0 to 23180\nData columns (total 15 columns):\n #   Column                           Non-Null Count  Dtype \n---  ------                           --------------  ----- \n 0   id                               23181 non-null  int64 \n 1   url                              23181 non-null  int64 \n 2   visit_time                       23181 non-null  int64 \n 3   from_visit                       23181 non-null  int64 \n 4   transition                       23181 non-null  int64 \n 5   segment_id                       23181 non-null  int64 \n 6   visit_duration                   23181 non-null  int64 \n 7   incremented_omnibox_typed_score  23181 non-null  int64 \n 8   opener_visit                     23181 non-null  int64 \n 9   originator_cache_guid            23181 non-null  object\n 10  originator_visit_id              23181 non-null  int64 \n 11  originator_from_visit            23181 non-null  int64 \n 12  originator_opener_visit          23181 non-null  int64 \n 13  is_known_to_sync                 23181 non-null  int64 \n 14  consider_for_ntp_most_visited    23181 non-null  int64 \ndtypes: int64(14), object(1)\nmemory usage: 2.7+ MB\n\n\nThe visit_duration holds how much time is spent on a specific URL in microseconds. The url column is a foreign key that again points to the urls table which contains the actual URL. Let’s join the two tables together.\n\nvisits_urls = pd.merge(left=visits, right=urls, left_on='url', right_on='id')\n\nColumns with duplicate names get appended with _x or _y. Because we end up with a url_x and an id_y column that both refer to the same value we can drop one of them.\n\nvisits_urls = visits_urls.drop(labels='url_x', axis=1)\n\nWe rename some columns to make it clear what attribute they represent.\n\nvisits_urls = visits_urls.rename(columns={'id_x': 'visit_id', 'id_y': 'url_id', 'url_y': 'url'})\n\nWe want to group by network location so we need to get this from the URL again like we did above.\n\nvisits_urls['netloc'] = visits_urls.url.map(lambda r: urlparse(r).netloc)\n\nI want to be able to filter by date range. We can use the visit_time column for that. This column contains WebKit/Chrome timestamps which we need to convert to human-readable date & Unix time. This timestamp format is used in web browsers such as Apple Safari (WebKit), Google Chrome and Opera (Chromium/Blink). It uses a 64-bit value for microseconds since Jan 1, 1601 00:00 UTC. I use a helper function to take care of the conversion.\n\ndef date_from_webkit(webkit_timestamp):\n    epoch_start = datetime.datetime(1601,1,1)\n    delta = datetime.timedelta(microseconds=int(webkit_timestamp))\n    return epoch_start + delta\n\n\nvisits_urls['visit_time_dt'] = pd.to_datetime(visits_urls.visit_time.map(date_from_webkit), utc=True).dt.tz_convert(tzlocal.get_localzone().key)\n\nI use a slider to select a date range and on each update the bar chart will redraw.\n\nstart_date = visits_urls['visit_time_dt'].min().date()\nend_date = visits_urls['visit_time_dt'].max().date()\n\ndates = pd.date_range(start_date, end_date, freq='D')\n\ndate_options = [(date.strftime('%d %b %Y'), date) for date in dates]\nindex = (0, len(date_options)-1)\n\n@interact(date_range=widgets.SelectionRangeSlider(options=date_options, index=index, description='Date range:', orientation='horizontal', layout={'width': '500px'}))\ndef plot_time_spent(date_range):\n    fig, ax = plt.subplots(figsize=(10,8))\n\n    tz = tzlocal.get_localzone().key\n    start_dt = pd.to_datetime(date_range[0]).tz_localize(tz)\n    end_dt = pd.to_datetime(date_range[1]).tz_localize(tz) + pd.Timedelta(days=1)\n    \n    top_visits_urls = visits_urls.query(\"visit_time_dt &gt;= @start_dt and visit_time_dt &lt; @end_dt\").groupby('netloc').visit_duration.sum()\n    top_visits_urls.sort_values().tail(20).plot(kind='barh', ax=ax, ylabel='', title=\"Top 20 websites most time spent on\")\n    \n    td = pd.to_timedelta(top_visits_urls.max(), unit='us')\n    for unit, n in td.components._asdict().items():\n        if n &gt; 0:\n            break\n    ticks_loc = [int(pd.to_timedelta(x, unit=unit) / pd.to_timedelta(1, unit='us')) for x in range(0, n+2, math.ceil((n+2)/5))]\n    \n    ax.xaxis.set_major_locator(FixedLocator(ticks_loc))\n    ax.set_xticklabels([\"{} {}\".format(pd.to_timedelta(x, unit='us').components._asdict()[unit], unit) for x in ticks_loc])\n    \n    plt.show()\n\n\n\n\n\n\n\n\nOverall I spend a lot of time on websites related to data science and software development. So that’s good. Most time is spent on Spotify, but that’s just because I always have a tab open to listen to music while I work (or procrastinate). I seem to waste a lot of time on YouTube but let’s pretend for now I’m mostly watching educational videos. The localhost:8888 is my local instance of Jupyter Lab and you can see I run another local development server on localhost.\n\n\nMost visited websites by frequency\nNow let’s produce a similar graph but this time based on how frequently I visit certain websites. I’ll use a slider again to be able to select date ranges.\n@interact(date_range=widgets.SelectionRangeSlider(options=date_options, index=index, description='Date range:', orientation='horizontal', layout={'width': '500px'}))\ndef plot_frequency(date_range):\n    fig, ax = plt.subplots(figsize=(10,8))\n\n    tz = tzlocal.get_localzone().key\n    start_dt = pd.to_datetime(date_range[0]).tz_localize(tz)\n    end_dt = pd.to_datetime(date_range[1]).tz_localize(tz) + pd.Timedelta(days=1)\n    \n    (visits_urls.query(\"visit_time_dt &gt;= @start_dt and visit_time_dt &lt; @end_dt\")\n         .groupby('netloc').size().sort_values().tail(20)\n         .plot(kind='barh', ax=ax, ylabel='', title=\"Top 20 most frequently visited websites\"))\n    plt.show()\n\n\n\n\n\n\n\n\nThis doesn’t look as flattering clearly.\nIt appears that I’m constantly checking Facebook, Instagram and the toxic cesspool that is Twitter, excuse me, 𝕏. I frequently visit the Dutch news website NOS to see if the world has fallen apart already. I also check the IMDB website quite often to see if there’s anything good to watch.\nI think some websites only make me feel annoyed and cynical, like Twitter and NOS, which then drives me to visit websites like IMDB in an attempt to search for movies or series to distract myself.\nI removed social media apps from my phone years ago but as you can tell from the chart above, I still visit the mobile website version of Facebook (m.facebook.com) way too often.\nI’m happy that in absolute time I don’t seem to waste too much time on social media but the frequency with which I visit those sites is definitely problematic. Most of it is mindless doomscrolling. Only occasionally I get a small dopamine hit when I see a cute cat video or someone likes one of my travel photos and I feel validated."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#youtube-videos",
    "href": "posts/from-procrastination-to-productivity/index.html#youtube-videos",
    "title": "From Procrastination to Productivity",
    "section": "YouTube videos",
    "text": "YouTube videos\nI seem to visit YouTube a lot both in frequency and time. What kind of stuff am I watching though? I’ll use a date picker to select a date and use a dropdown box to select if I want to see the YouTube videos or shorts I watched that day. I’ll make the links clickable.\n\ndef make_clickable(url, name):\n    return '&lt;a href=\"{}\" rel=\"noopener noreferrer\" target=\"_blank\"&gt;{}&lt;/a&gt;'.format(url, name)\n\n\n@interact(date=widgets.DatePicker(description='Date: ', disabled=False, value=end_date), \n          content_type=widgets.Dropdown(\n              options=[(\"Videos\", \"youtube.com/watch\"), \n                       (\"Shorts\", \"youtube.com/shorts\")], \n              value=\"youtube.com/watch\", description='Type:'))\ndef show_watched_videos(date, content_type):    \n    tz = tzlocal.get_localzone().key\n    start_dt = pd.to_datetime(date).tz_localize(tz)\n    end_dt = start_dt + pd.Timedelta(days=1)\n    \n    df = visits_urls.query(\"url.str.contains(@content_type) and visit_time_dt &gt;= @start_dt and visit_time_dt &lt; @end_dt\").copy()\n    df['YouTube video'] = df.apply(lambda x: make_clickable(x['url'], x['title']), axis=1)\n    if df.size:\n        display(df[['YouTube video']].style.hide(axis='index'))\n    else:\n        print(\"No YouTube URLs found for this type of content.\")\n\n\n\n\nThe stuff I watch is mostly related to music, science and AI/ML. I really appreciate good craftsmanship and there are some makers I follow. The frequency of my visits to YouTube is for the most part due to wanting to see if something new has been released."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#when-am-i-most-active",
    "href": "posts/from-procrastination-to-productivity/index.html#when-am-i-most-active",
    "title": "From Procrastination to Productivity",
    "section": "When am I most active?",
    "text": "When am I most active?\nLet’s see around what time I am most active online. I use Pandas conditional formatting to hightlight my most active hours each day of the week. A dropdown box is used to select the week.\n\ndates = pd.date_range(start_date, end_date, freq='W-MON')\noptions = [(\"{} - {}\".format(date.strftime('%d %b %Y'), (date + pd.Timedelta(days=7)).strftime('%d %b %Y')), (date, date + pd.Timedelta(days=7))) for date in dates]\noptions.insert(0, ('All weeks', (pd.to_datetime(start_date), pd.to_datetime(end_date))))\n\n\n@interact(date_range=widgets.Dropdown(options=options, description='Week:'))\ndef plot_activity(date_range):\n    tz = tzlocal.get_localzone().key\n    start_dt = pd.to_datetime(date_range[0]).tz_localize(tz)\n    end_dt = pd.to_datetime(date_range[1]).tz_localize(tz) + pd.Timedelta(days=1)\n        \n    df = (visits_urls.query(\"visit_time_dt &gt;= @start_dt and visit_time_dt &lt; @end_dt\")\n        .groupby([visits_urls.visit_time_dt.dt.day_of_week, visits_urls.visit_time_dt.dt.hour])\n        .size().unstack().reset_index(drop=True)\n        .reindex(list(range(0,7)), fill_value=0)\n        .reindex(list(range(0,24)), axis='columns', fill_value=0)\n    )\n    vmax = df.max(axis=None)\n    df.columns.name = None\n    display(df.rename(mapper=lambda x: list(calendar.day_name)[x])\n        .rename(columns=lambda y: str(y if y else 12) + \" am\" if y &lt; 12 else str(y if y==12 else y-12) + \" pm\")\n        .style.format(na_rep=0, precision=0).background_gradient(cmap='Blues', vmin=0, vmax=vmax)\n        .applymap(lambda x: 'background-color: white; color: black;' if pd.isnull(x) or x==0 else '')\n    )\n\n\n\n\nIt’s interesting to look at my browser usage by week, but by taking data from all weeks you can see a pattern emerge. I occasionally stay up way too late on Saturday night probably to make up for a lack of productivity (real or imagined) from the week before. I also come online quite early in the morning which is when I tend to waste most time on social media. Not a good way to start my day for sure."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#downloads",
    "href": "posts/from-procrastination-to-productivity/index.html#downloads",
    "title": "From Procrastination to Productivity",
    "section": "Downloads",
    "text": "Downloads\nFinally I wanted to look at my downloads and see if I could learn anything from that. Let’s look at the downloads table:\n\ndownloads.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 86 entries, 0 to 85\nData columns (total 28 columns):\n #   Column                  Non-Null Count  Dtype \n---  ------                  --------------  ----- \n 0   id                      86 non-null     int64 \n 1   guid                    86 non-null     object\n 2   current_path            86 non-null     object\n 3   target_path             86 non-null     object\n 4   start_time              86 non-null     int64 \n 5   received_bytes          86 non-null     int64 \n 6   total_bytes             86 non-null     int64 \n 7   state                   86 non-null     int64 \n 8   danger_type             86 non-null     int64 \n 9   interrupt_reason        86 non-null     int64 \n 10  hash                    86 non-null     object\n 11  end_time                86 non-null     int64 \n 12  opened                  86 non-null     int64 \n 13  last_access_time        86 non-null     int64 \n 14  transient               86 non-null     int64 \n 15  referrer                86 non-null     object\n 16  site_url                86 non-null     object\n 17  embedder_download_data  86 non-null     object\n 18  tab_url                 86 non-null     object\n 19  tab_referrer_url        86 non-null     object\n 20  http_method             86 non-null     object\n 21  by_ext_id               86 non-null     object\n 22  by_ext_name             86 non-null     object\n 23  etag                    86 non-null     object\n 24  last_modified           86 non-null     object\n 25  mime_type               86 non-null     object\n 26  original_mime_type      86 non-null     object\n 27  by_web_app_id           86 non-null     object\ndtypes: int64(11), object(17)\nmemory usage: 18.9+ KB\n\n\nThere are a few WebKit/Chrome timestamps that we need to convert to datetime format.\n\ndownloads['start_time_dt'] = pd.to_datetime(downloads.start_time.map(date_from_webkit), utc=True).dt.tz_convert(tzlocal.get_localzone().key)\n\n\ndownloads.loc[downloads.end_time &gt; 0, \"end_time_dt\"] = (pd.to_datetime(downloads.loc[downloads.end_time &gt; 0, \"end_time\"]\n    .map(date_from_webkit), utc=True).dt.tz_convert(tzlocal.get_localzone().key)\n)\n\n\ndownloads.loc[downloads.last_access_time &gt; 0, \"last_access_time_dt\"] = (pd.to_datetime(downloads.loc[downloads.last_access_time &gt; 0, \"last_access_time\"]\n    .map(date_from_webkit), utc=True).dt.tz_convert(tzlocal.get_localzone().key)\n)\n\n\nDownloads per month\nLet’s first look at how many GB of data I download each month.\n\nxticks = [\"{}, {}\".format(y, m) for y, _, m in downloads.groupby([downloads.start_time_dt.dt.year, downloads.start_time_dt.dt.month, downloads.start_time_dt.dt.month_name()]).size().index]\n\nax = downloads.groupby([downloads.start_time_dt.dt.year, downloads.start_time_dt.dt.month]).received_bytes.sum().plot(kind='bar', xlabel='', title=\"Downloads in GB by month\")\nax.set_xticklabels(xticks)\n\nticks_loc = ax.get_yticks().tolist()\nax.yaxis.set_major_locator(FixedLocator(ticks_loc))\nax.set_yticklabels(['{:,.0f}GB'.format(x/1e9) for x in ticks_loc])\n\nplt.show()\n\n\n\n\nI’ve been traveling in August which is why I haven’t downloaded as much as in July.\n\n\nDownloads by file type\nLet’s see what kind of files I download most by looking at its extension.\n\nfig, ax = plt.subplots(figsize=(10,8))\n(downloads.target_path.apply(lambda p: Path(p).suffix.lower())\n    .replace('', np.nan).dropna()\n    .value_counts().sort_values()\n    .plot(kind='barh', ax=ax, ylabel='', title=\"Most downloaded file types\"))\nax.xaxis.set_major_locator(MaxNLocator(integer=True))\nplt.show()\n\n\n\n\nMost of the files I download are PDFs.\n\n\nWhere I download most files from\nLet’s look at the top 10 websites I download most files from. I start by extracting the network location from the tab_url attribute which contains the URL that provided the download link.\n\ndownloads['netloc'] = downloads.tab_url.map(lambda r: urlparse(r).netloc)\n\n\n(downloads.query('netloc.str.len() &gt; 0')\n    .groupby('netloc').size().sort_values(ascending=False)\n    .to_frame().head(10).reset_index().rename({0: 'count'}, axis=1)\n    .style.hide(axis='index')\n)\n\n\n\n\n\n\nnetloc\ncount\n\n\n\n\nlibretexts.org\n17\n\n\nblackboard.nhlstenden.com\n10\n\n\nwww.classicalguitarmidi.com\n10\n\n\nwww.ns.nl\n5\n\n\ndevtools\n4\n\n\narchive.org\n3\n\n\nwww.google.com\n2\n\n\ns9.imslp.org\n2\n\n\nlearn-eu-central-1-prod-fleet01-xythos.content.blackboardcdn.com\n2\n\n\noutlook.office.com\n2"
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#wrapping-this-up",
    "href": "posts/from-procrastination-to-productivity/index.html#wrapping-this-up",
    "title": "From Procrastination to Productivity",
    "section": "Wrapping this up",
    "text": "Wrapping this up\nThere’s a lot more we could look at. Some further ideas I have:\n\nVisualize how I transition from one website to another using GraphViz.\nVisualize during which time of the day I check social media, and for how long.\nTry to identify what triggers my procrastination.\nIdentify what I do directly after visiting social media.\nThe Chrome mobile browser history syncs with the browser history on my laptop. I could separate this data and see on which device I waste most of my time.\n\nThe more time I spend on this, the more ideas I get. I’m going to leave it at this for now though.\nBased on this analysis, I intend to do the following:\n\nStay away from my phone early in the morning. I’ll charge it in a room I don’t come that often so it’s out of sight and I don’t grab it first thing in the morning.\nCheck my social media only once a day at a fixed time. Have a book nearby so I can read when I want to distract myself instead of doomscrolling.\nBlock news sites and Twitter. If something earth-shattering happens I’m sure people will let me know. Constantly coming back to and checking these sites feels like sprinkling an otherwise perfect day with unnecessary negativity and drama.\nGo to bed on time and get up on time. Limit my screen time.\nTake way more breaks, at least every two hours. I tend to work long stretches of time wanting to finish something, sometimes even forgetting to eat. I think that the constant checking of social media is my brain telling me it needs a proper break."
  },
  {
    "objectID": "posts/from-procrastination-to-productivity/index.html#analyze-your-own-browser-data",
    "href": "posts/from-procrastination-to-productivity/index.html#analyze-your-own-browser-data",
    "title": "From Procrastination to Productivity",
    "section": "Analyze your own browser data",
    "text": "Analyze your own browser data\nCongratulations if you made it this far! Now stop procrastinating and get back to work!\nIf you want to play with an interactive version and analyze your own browser data, you can get the source code as a GitHub gist here."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "",
    "text": "If you’re a programmer then you must be a masochist. After all, what kind of person enjoys staring at a screen for hours on end, squinting at lines of code that seem to blend together like a modern art painting? What kind of person willingly submits themselves to the endless frustration of debugging, only to find that the solution was something as simple as a missing semicolon?\nIf this is you then you’re going to love Brainfuck - the programming language that’s minimalistic to the point of absurdity. With only eight commands, Brainfuck is both challenging and frustrating for even the most experienced programmers.\nIn this post I’ll give a brief overview of the language and then describe how to use the Brainfuck interpreter I wrote."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#how-does-brainfuck-work",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#how-does-brainfuck-work",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "How does Brainfuck work?",
    "text": "How does Brainfuck work?\nBrainfuck programs operate on a memory tape consisting of an array of cells, each containing a single byte. With the tape initially set to zero, Brainfuck programs modify the values in the memory cells, move the pointer left and right along the tape, and perform input and output operations using its eight commands."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#commands",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#commands",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "Commands",
    "text": "Commands\nHere’s a breakdown of the available commands in Brainfuck:\n\n&lt;: Move the pointer one cell to the left.\n&gt;: Move the pointer one cell to the right.\n+: Increment the value of the cell the pointer is pointing to by one.\n-: Decrement the value of the cell the pointer is pointing to by one.\n.: Output the value of the cell the pointer is pointing to.\n,: Input a byte and store its value in the cell the pointer is pointing to.\n[: If the value of the cell the pointer is pointing to is zero, jump forward to the corresponding ] command.\n]: If the value of the cell the pointer is pointing to is non-zero, jump back to the corresponding [ command.\n\nDue to its minimalistic syntax, Brainfuck is used to challenge and amuse programmers. I’ll be honest - programming in Brainfuck is an absolute nightmare. Writing an interpreter for it is easy though."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#using-the-interpreter",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#using-the-interpreter",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "Using the interpreter",
    "text": "Using the interpreter\nYou can download my Brainfuck interpreter here.\nThe Prolog program provided, bf.pl, is the interpreter. It defines a number of Prolog predicates that can be used to interpret Brainfuck programs. The interpreter uses a list to represent the memory tape, and provides predicates for setting and getting the values of cells, as well as for incrementing and decrementing cell values.\nThe main predicate, run(Prog), takes a list of Brainfuck commands as input and interprets the program. It uses a helper predicate, sequence/4, to recursively process each command in the program, updating the memory tape and pointer as necessary.\nMy interpreter isn’t the fastest, but it does have dynamic memory tape length. Most other interpreters have a fixed tape length of (usually) 30,000 cells."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#running-brainfuck-programs",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#running-brainfuck-programs",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "Running Brainfuck programs",
    "text": "Running Brainfuck programs\nI’ve included a couple of example programs taken from The Brainfuck Archive, including a “Hello World!” program. To execute a Brainfuck program using the interpreter, you can use the run_bf_program/1 predicate which in turn uses the run/1 predicate.\nFor example, to run the “Hello World!” program, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the Brainfuck interpreter by typing:\n[bf].\nThis loads the bf.pl file into the interpreter. You can then run a Brainfuck program using the run_bf_program/1 predicate, like so:\nrun_bf_program('hellobf.bf').\nThis will run the hellobf.bf program and output the famous “Hello World!” message to the console.\nAlternatively, you can execute these three steps at once by typing:\nswipl -s bf.pl -g \"run_bf_program('hellobf.bf'), halt.\"\nAdding halt will make the Prolog interpreter exit after the Brainfuck run_bf_program/1 predicate has finished.\nYou can also run Brainfuck code directly like this:\nswipl -s bf.pl -g \"atom_chars('++++[++++&gt;---&lt;]&gt;-.---[-----&gt;+&lt;]&gt;-.+++[-&gt;+++&lt;]&gt;++.++++++++.+++++.--------.---[-&gt;+++&lt;]&gt;+.-[---&gt;+&lt;]&gt;.++++++++.',Chars), run(Chars), halt.\"\nHappy coding and good luck with your sanity!"
  },
  {
    "objectID": "posts/who-owns-the-zebra/index.html",
    "href": "posts/who-owns-the-zebra/index.html",
    "title": "Who Owns the Zebra",
    "section": "",
    "text": "On December 17, 1962, Life International magazine published the following puzzle:\nThis puzzle is said to be invented by Einstein and therefore sometimes referred to as Einstein’s puzzle or Einstein’s riddle. Supposedly, he also claimed that only 2% of the world’s population would be smart enough to solve it. For neither claim is there any evidence."
  },
  {
    "objectID": "posts/who-owns-the-zebra/index.html#solving-the-puzzle-using-prolog",
    "href": "posts/who-owns-the-zebra/index.html#solving-the-puzzle-using-prolog",
    "title": "Who Owns the Zebra",
    "section": "Solving the puzzle using Prolog",
    "text": "Solving the puzzle using Prolog\nAs an example of how to solve these kinds of logic puzzles using Prolog, I wrote this code:\n\n\neinstein.pl\n\n% A Prolog solver for the Zebra puzzle a.k.a. Einstein's riddle.\n% https://en.wikipedia.org/wiki/Zebra_Puzzle\n\neinstein :-\n    einstein(Solution),\n    write_sol(Solution).\n\neinstein(Sol) :-\n    Sol = [ \n        [1,N1,C1,P1,D1,S1],                             % There are five houses.\n        [2,N2,C2,P2,D2,S2],\n        [3,N3,C3,P3,D3,S3],\n        [4,N4,C4,P4,D4,S4],\n        [5,N5,C5,P5,D5,S5]],\n    member([_,englishman,red,_,_,_],Sol),               % The Englishman lives in the red house.\n    member([_,spaniard,_,dog,_,_],Sol),                 % The Spaniard owns the dog.\n    member([_,_,green,_,coffee,_],Sol),                 % Coffee is drunk in the green house.\n    member([_,ukrainian,_,_,tea,_],Sol),                % The Ukrainian drinks tea.\n    member([GH,_,green,_,_,_],Sol),                     % The green house is immediately to the right of the ivory house.\n    member([IH,_,ivory,_,_,_],Sol),\n    GH =:= IH + 1,\n    member([_,_,_,snails,_,old_gold],Sol),              % The Old Gold smoker owns snails.\n    member([_,_,yellow,_,_,kools],Sol),                 % Kools are smoked in the yellow house.\n    member([3,_,_,_,milk,_],Sol),                       % Milk is drunk in the middle house.\n    member([1,norwegian,_,_,_,_],Sol),                  % The Norwegian lives in the first house.\n    member([BH,_,_,_,_,chesterfields],Sol),             % The man who smokes Chesterfields lives in the house next to the man with the fox.\n    member([CH,_,_,fox,_,_],Sol),\n    next_to(BH,CH),\n    member([DH,_,_,_,_,kools],Sol),                     % Kools are smoked in the house next to the house where the horse is kept.\n    member([HH,_,_,horse,_,_],Sol),\n    next_to(DH,HH),\n    member([_,_,_,_,orange_juice,lucky_strike],Sol),    % The Lucky Strike smoker drinks organge juice.\n    member([_,japanese,_,_,_,parliaments],Sol),         % The Japanese smokes Parliaments\n    member([NH,norwegian,_,_,_,_],Sol),                 % The Norwegian lives next to the blue house.\n    member([BlH,_,blue,_,_,_],Sol),\n    next_to(NH,BlH),\n    permutation([englishman,spaniard,ukrainian,japanese,norwegian],[N1,N2,N3,N4,N5]),\n    permutation([green,ivory,yellow,blue,red],[C1,C2,C3,C4,C5]),\n    permutation([dog,snails,fox,horse,zebra],[P1,P2,P3,P4,P5]),\n    permutation([coffee,tea,milk,orange_juice,water],[D1,D2,D3,D4,D5]),\n    permutation([old_gold,kools,chesterfields,lucky_strike,parliaments],[S1,S2,S3,S4,S5]).\n\nnext_to(A,B) :- A =:= B - 1.\nnext_to(A,B) :- A =:= B + 1.\n\nwrite_sol(Solution) :-\n    write('+--+------------+------------+------------+-------------+--------------+'),nl,\n    maplist(writef('|%2L|%12L|%12L|%12L|%13L|%14L|\\n'),Solution),\n    write('+--+------------+------------+------------+-------------+--------------+'),nl.\n\nThe program uses a list of lists to represent the houses and applies a set of constraints to determine the correct answer.\nThe einstein/1 predicate defines the structure of the solution as a list of lists called Sol. Each sublist corresponds to a house and contains five variables representing the house number, nationality, color, pet, drink, and cigarette brand.\nThe predicate then uses a set of member/2 and next_to/2 predicates to apply the given clues and constraints to the list of houses. For example, member([_,englishman,red,_,_,_],Sol) specifies that the Englishman lives in the red house, and the predicates member([BH,_,_,_,_,chesterfields],Sol), member([CH,_,_,fox,_,_],Sol), and next_to(BH,CH) specify that the man who smokes Chesterfields lives in the house next to the man with the fox.\nFinally, write_sol/1 outputs the solutions in a formatted table.\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/who-owns-the-zebra/index.html#running-the-solver",
    "href": "posts/who-owns-the-zebra/index.html#running-the-solver",
    "title": "Who Owns the Zebra",
    "section": "Running the solver",
    "text": "Running the solver\nTo run the solver, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the solver by typing:\n[einstein].\nThis loads the einstein.pl file. You can execute the solver which will output the solution to the console:\neinstein.\n+--+------------+------------+------------+-------------+--------------+\n|1 |norwegian   |yellow      |fox         |water        |kools         |\n|2 |ukrainian   |blue        |horse       |tea          |chesterfields |\n|3 |englishman  |red         |snails      |milk         |old_gold      |\n|4 |spaniard    |ivory       |dog         |orange_juice |lucky_strike  |\n|5 |japanese    |green       |zebra       |coffee       |parliaments   |\n+--+------------+------------+------------+-------------+--------------+"
  },
  {
    "objectID": "posts/word-search-clock/index.html",
    "href": "posts/word-search-clock/index.html",
    "title": "Word Search Clock",
    "section": "",
    "text": "A few weeks ago, my clock stopped working, and I wasn’t inclined to invest in a replacement. After futile attempts to revive it, I decided to get crafty. I had an unused photo frame collecting dust and realized it could be turned into a clock by making it display images that show the time of the day. I’d need one image for every minute of the day and display each of them for 60 seconds before transitioning to the next one.\nUsing pictures that show a digital clock seemed too mundane. Analog faces felt a bit lackluster. Then it hit me—why not combine the charm of word clocks with the visuals of a word search puzzle? The outcome: a word clock that shows words not just horizontally but also vertically and diagonally. Brilliant, if I may say so myself.\nEvery minute, the photo frame displays an image featuring a different set of highlighted words that indicate the current time.\nCurious about how I generated these images? Dive into the details below."
  },
  {
    "objectID": "posts/word-search-clock/index.html#design-decisions",
    "href": "posts/word-search-clock/index.html#design-decisions",
    "title": "Word Search Clock",
    "section": "Design decisions",
    "text": "Design decisions\n\nArranging words in a grid\nMy intention was to position words both horizontally, vertically, and diagonally, similar to word search puzzles, allowing for occasional partial overlaps. To ensure a singular way of reading the time, I established the following criteria:\n\nEach letter can only be the first letter in a word once.\nWords should follow a specific order.\nDue to varying word orientations, the first letter in each word dictates the reading sequence.\n\nIn simpler terms, by scanning the grid left to right and top to bottom and identifying whether each letter marks the beginning of a word, one can deduce the time. Applying this method to the image above reveals the time as “It is twenty-four minutes past four.”\n\n\nTelling time in English\nFor time expression, I adopted the following format:\n\nTop of the hour:\n\n“It is [number] o’clock.”\n\nExample: “It is two o’clock.”\n\n\nTimes after the top of the hour:\n\n“It is [minutes] past [number].”\n\nExample: “It is eleven minutes past three.”\n\n\nTimes before the top of the hour:\n\n“It is [minutes] to [next hour].”\n\nExample: “It is twenty-three minutes to five.”\n\n\n\n(Note: We use “half” for thirty minutes and “a quarter” for fifteen minutes.)\n\n\nLanguage nuances\nAccording to the Cambridge dictionary, for multiplies of five, the word “minutes” can be omitted. This might be a British-English specific convention but I decided to follow it anyways.\nWhile Americans might use “after” instead of “past,” and many English speakers tend to omit the word “minutes” in everyday speech, I opted for “past” and excluded “minutes” only for multiples of five.\n\n\nSimplifications\nI decided against adding phrases like “in the morning” or “in the afternoon”, limiting the generation to only 720 images (12 hours * 60 minutes).\nThe word “fourteen” contains “four,” and likewise, “sixteen” encompasses “six.” By positioning “fourteen,” “sixteen,” “seventeen,” “eighteen,” and “nineteen,” we inherently include “four,” “six,” “seven,” “eight,” and “nine.” This ensures the grid remains compact."
  },
  {
    "objectID": "posts/word-search-clock/index.html#importing-libraries",
    "href": "posts/word-search-clock/index.html#importing-libraries",
    "title": "Word Search Clock",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe’ll start by importing libraries. We use matplotlib to draw the images.\n\nimport matplotlib.pyplot as plt\nimport string\nimport os"
  },
  {
    "objectID": "posts/word-search-clock/index.html#specifying-the-word-order",
    "href": "posts/word-search-clock/index.html#specifying-the-word-order",
    "title": "Word Search Clock",
    "section": "Specifying the word order",
    "text": "Specifying the word order\nThe following graph specifies the order in which words must be placed on the grid.\n\n\n\n\n\n   \n\nn0\n\n   \n\nit\n\n it   \n\nn0-&gt;it\n\n      \n\nis\n\n is   \n\nit-&gt;is\n\n    \n\ntwenty\n\n twenty   \n\nis-&gt;twenty\n\n    \n\nhalf\n\n half   \n\nis-&gt;half\n\n    \n\nten\n\n ten   \n\nis-&gt;ten\n\n    \n\neleven\n\n eleven   \n\nis-&gt;eleven\n\n    \n\ntwelve\n\n twelve   \n\nis-&gt;twelve\n\n    \n\nthirteen\n\n thirteen   \n\nis-&gt;thirteen\n\n    \n\nfourteen\n\n fourteen   \n\nis-&gt;fourteen\n\n    \n\nsixteen\n\n sixteen   \n\nis-&gt;sixteen\n\n    \n\nseventeen\n\n seventeen   \n\nis-&gt;seventeen\n\n    \n\neighteen\n\n eighteen   \n\nis-&gt;eighteen\n\n    \n\nnineteen\n\n nineteen   \n\nis-&gt;nineteen\n\n    \n\na\n\n a   \n\nis-&gt;a\n\n    \n\none\n\n one   \n\ntwenty-&gt;one\n\n    \n\ntwo\n\n two   \n\ntwenty-&gt;two\n\n    \n\nthree\n\n three   \n\ntwenty-&gt;three\n\n    \n\nfive\n\n five   \n\ntwenty-&gt;five\n\n    \n\npast\n\n past   \n\ntwenty-&gt;past\n\n    \n\nto\n\n to   \n\ntwenty-&gt;to\n\n    \n\nhalf-&gt;past\n\n    \n\nten-&gt;past\n\n    \n\nten-&gt;to\n\n    \n\nminutes\n\n minutes   \n\neleven-&gt;minutes\n\n    \n\ntwelve-&gt;minutes\n\n    \n\nthirteen-&gt;minutes\n\n    \n\nfourteen-&gt;minutes\n\n    \n\nsixteen-&gt;minutes\n\n    \n\nseventeen-&gt;minutes\n\n    \n\neighteen-&gt;minutes\n\n    \n\nnineteen-&gt;minutes\n\n    \n\nquarter\n\n quarter   \n\na-&gt;quarter\n\n    \n\nquarter-&gt;past\n\n    \n\nquarter-&gt;to\n\n    \n\none-&gt;minutes\n\n    \n\ntwo-&gt;minutes\n\n    \n\nthree-&gt;minutes\n\n    \n\nfive-&gt;past\n\n    \n\nfive-&gt;to\n\n    \n\nminutes-&gt;past\n\n    \n\nminutes-&gt;to\n\n    \n\nonehour\n\n one   \n\npast-&gt;onehour\n\n    \n\ntwohour\n\n two   \n\npast-&gt;twohour\n\n    \n\nthreehour\n\n three   \n\npast-&gt;threehour\n\n    \n\nfourhour\n\n four   \n\npast-&gt;fourhour\n\n    \n\nfivehour\n\n five   \n\npast-&gt;fivehour\n\n    \n\nsixhour\n\n six   \n\npast-&gt;sixhour\n\n    \n\nsevenhour\n\n seven   \n\npast-&gt;sevenhour\n\n    \n\neighthour\n\n eight   \n\npast-&gt;eighthour\n\n    \n\nninehour\n\n nine   \n\npast-&gt;ninehour\n\n    \n\ntenhour\n\n ten   \n\npast-&gt;tenhour\n\n    \n\nelevenhour\n\n eleven   \n\npast-&gt;elevenhour\n\n    \n\ntwelvehour\n\n twelve   \n\npast-&gt;twelvehour\n\n    \n\nto-&gt;onehour\n\n    \n\nto-&gt;twohour\n\n    \n\nto-&gt;threehour\n\n    \n\nto-&gt;fourhour\n\n    \n\nto-&gt;fivehour\n\n    \n\nto-&gt;sixhour\n\n    \n\nto-&gt;sevenhour\n\n    \n\nto-&gt;eighthour\n\n    \n\nto-&gt;ninehour\n\n    \n\nto-&gt;tenhour\n\n    \n\nto-&gt;elevenhour\n\n    \n\nto-&gt;twelvehour\n\n    \n\noclock\n\n o’clock   \n\nonehour-&gt;oclock\n\n    \n\ntwohour-&gt;oclock\n\n    \n\nthreehour-&gt;oclock\n\n    \n\nfourhour-&gt;oclock\n\n    \n\nfivehour-&gt;oclock\n\n    \n\nsixhour-&gt;oclock\n\n    \n\nsevenhour-&gt;oclock\n\n    \n\neighthour-&gt;oclock\n\n    \n\nninehour-&gt;oclock\n\n    \n\ntenhour-&gt;oclock\n\n    \n\nelevenhour-&gt;oclock\n\n    \n\ntwelvehour-&gt;oclock\n\n   \n\n\n\n\n\nIn code this can be specified as follows:\n\n# Words to fill. Each tuple is (ID, word, preceding)\nwords = [\n    (0, \"it\", []), \n    (1, \"is\", [0]),\n    (2, \"twenty\", [1]),\n    (3, \"half\", [1]),\n    (4, \"ten\", [1]),\n    (5, \"eleven\", [1]),\n    (6, \"twelve\", [1]),\n    (7, \"thirteen\", [1]),\n    (8, \"fourteen\", [2]),\n    (9, \"sixteen\", [2]),\n    (10, \"seventeen\", [2]),\n    (11, \"eighteen\", [2]),\n    (12, \"nineteen\", [2]),\n    (13, \"a\", [1]),\n    (14, \"quarter\", [13]),\n    (15, \"one\", [2]),\n    (16, \"two\", [2]),\n    (17, \"three\", [2]),\n    (18, \"five\", [2]),\n    (19, \"minutes\", [15, 16, 17, 8, 9, 10, 11, 12, 5, 6, 7]),\n    (20, \"past\", [19, 18, 4, 14, 2, 3]),\n    (21, \"to\", [19, 18, 4, 14, 2]),\n    (22, \"one\", [20, 21]),\n    (23, \"two\", [20, 21]),\n    (24, \"three\", [20, 21]),\n    (25, \"four\", [20, 21]),\n    (26, \"five\", [20, 21]),\n    (27, \"six\", [20, 21]),\n    (28, \"seven\", [20, 21]),\n    (29, \"eight\", [20, 21]),\n    (30, \"nine\", [20, 21]),\n    (31, \"ten\", [20, 21]),\n    (32, \"eleven\", [20, 21]),\n    (33, \"twelve\", [20, 21]),\n    (34, \"oclock\", [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])\n]\n\nEach word is specified by a tuple of the form (id, word, preceding). The id is an integer that uniquely identifies the word. The word is the word to be placed. The preceding is a list of integers that specify which words must be placed before this word."
  },
  {
    "objectID": "posts/word-search-clock/index.html#filling-the-grid",
    "href": "posts/word-search-clock/index.html#filling-the-grid",
    "title": "Word Search Clock",
    "section": "Filling the grid",
    "text": "Filling the grid\nWe ensure that each word is readable in either a left-to-right or top-down direction, never in reverse.\n\ndirections = [(1, 0), (0, 1), (1, 1), (1, -1)]\n\nThe following function returns a list of identifiers of words that are ready to be placed in the grid. This is done by checking if all preceding words are placed in the grid. If so, the word is ready to be placed. At first, the only word that can be placed is the word it because its list of preceding words is empty.\n\ndef placeable_word_ids(words):\n    unplaced_word_ids = [id for (id, _, loc, _, _) in words if loc is None]\n    return [id for (id, _, loc, _, prec) in words if not any(prec_id in unplaced_word_ids for prec_id in prec) and loc is None]\n\nThe following function checks is a word can be placed in the grid in a given direction and location.\n\ndef can_place_word(word, grid, dir, r, c):\n    height = len(grid)\n    width = len(grid[0])\n    d_x, d_y = dir\n    if c + len(word) * d_x &gt; width or r + len(word) * d_y &gt; height or c + len(word) * d_x &lt; 0 or r + len(word) * d_y &lt; 0:\n        return False\n    for i, ch in enumerate(word):\n        if grid[r + i * d_y][c + i * d_x] not in ['?', ch]: \n            return False\n    return True\n\nIf a word can be placed, we call the following function to place it. The original content is returned so we can backtrack later.\n\ndef replace_characters(word, grid, dir, r, c):\n    height = len(grid)\n    width = len(grid[0])\n    previous = \"\"\n    d_x, d_y = dir\n    for i, ch in enumerate(word):\n        previous += grid[r + i * d_y][c + i * d_x]\n        grid[r + i * d_y][c + i * d_x] = ch\n    return previous\n\nA recursive generator function attempts to fill a grid with words. It uses backtracking to explore possible word placements in different directions.\n\ndef fill_grid_(grid, words, i=0):\n    height = len(grid)\n    width = len(grid[0])\n    ids = placeable_word_ids(words)\n    \n    if not ids:\n        yield grid, words\n    elif i &lt; height * width:\n        row = i // width\n        col = i % width\n        for id in ids:\n            dir_length = len(directions)\n            for d in range(dir_length):\n                dir = directions[(i + d) % dir_length]\n                if can_place_word(words[id][1], grid, dir, row, col):\n                    previous = replace_characters(words[id][1], grid, dir, row, col)\n                    words[id] = (id, words[id][1], (col, row), dir, words[id][4])\n                    yield from fill_grid_(grid, words, i+1)\n                    words[id] = (id, words[id][1], None, None, words[id][4])\n                    replace_characters(previous, grid, dir, row, col)\n        else:\n            yield from fill_grid_(grid, words, i+1)\n\nThe function fill_grid is a wrapper function that initializes the grid and calls fill_grid_.\n\ndef fill_grid(width, height):\n    loc_dir_words = [(id, word, None, None, prec) for (id, word, prec) in words]\n    grid = [['?' for c in range(width)] for r in range(height)]\n    yield from fill_grid_(grid, loc_dir_words, 0)\n\nWe call this wrapper function as follows:\n\ngen = fill_grid(15, 11)\n(g, w) = next(gen)\n\nThis returns a filled grid with a width of 15 and a height of 11. These dimensions were found experimentally. The digital photo frame that I’m using has an aspect ratio of 4:3. It makes sense to use a grid with a similar aspect ratio. I started with a width of 16 and height of 12, but that yielded grids with too many unoccupied spaces. Using 15 by 11 deviates only slightly from a 4:3 aspect ratio.\nLet’s look at the grid.\n\ng\n\n[['i', 't', 'i', 't', 'w', 'e', 'n', 't', 'y', 'h', 'a', 'o', 'n', 'e', 't'],\n ['t', 'f', 's', 's', '?', 'l', 'q', 'i', 'e', 't', 'a', '?', '?', 'i', 'w'],\n ['h', 'o', 'i', 't', 'e', 'e', 'f', 'u', 'n', 'n', 'w', 'l', '?', 'g', 'e'],\n ['i', 'u', 'x', 'h', 'm', 'v', 'p', 'i', 'a', 'e', 't', 'o', 'f', 'h', 'l'],\n ['r', 'r', 't', 'r', 'i', 'e', 'e', 'a', 'v', 'r', 't', 'n', 'i', 't', 'v'],\n ['t', 't', 'e', 'e', 'n', 'n', 'i', 'n', 's', 'e', 't', 'e', 'v', 'e', 'e'],\n ['e', 'e', 'e', 'e', 'u', 'i', 't', 'g', 't', 't', 'l', 'e', 'e', 'e', 'f'],\n ['e', 'e', 'n', 's', 't', '?', 'n', 'w', 'h', 'e', 'h', 'e', 'r', 'n', 'o'],\n ['n', 'n', '?', 'i', 'e', '?', '?', 'e', 'o', 't', 'e', 'r', 'v', '?', 'u'],\n ['?', '?', '?', 'x', 's', 'e', 'v', 'e', 'n', '?', '?', 'n', 'e', 'e', 'r'],\n ['t', 'w', 'e', 'l', 'v', 'e', 'o', 'c', 'l', 'o', 'c', 'k', '?', 'e', 'n']]\n\n\nAnd how the words are placed.\n\nw\n\n[(0, 'it', (0, 0), (1, 0), []),\n (1, 'is', (2, 0), (1, 1), [0]),\n (2, 'twenty', (3, 0), (1, 0), [1]),\n (3, 'half', (9, 0), (1, 1), [1]),\n (4, 'ten', (7, 0), (1, 1), [1]),\n (5, 'eleven', (5, 0), (0, 1), [1]),\n (6, 'twelve', (14, 0), (0, 1), [1]),\n (7, 'thirteen', (0, 1), (0, 1), [1]),\n (8, 'fourteen', (1, 1), (0, 1), [2]),\n (9, 'sixteen', (2, 1), (0, 1), [2]),\n (10, 'seventeen', (3, 1), (1, 1), [2]),\n (11, 'eighteen', (13, 0), (0, 1), [2]),\n (12, 'nineteen', (6, 0), (1, 1), [2]),\n (13, 'a', (10, 0), (1, 1), [1]),\n (14, 'quarter', (6, 1), (1, 1), [13]),\n (15, 'one', (11, 0), (1, 0), [2]),\n (16, 'two', (9, 1), (1, 1), [2]),\n (17, 'three', (3, 2), (0, 1), [2]),\n (18, 'five', (6, 2), (1, 1), [2]),\n (19, 'minutes', (4, 3), (0, 1), [15, 16, 17, 8, 9, 10, 11, 12, 5, 6, 7]),\n (20, 'past', (6, 3), (1, 1), [19, 18, 4, 14, 2, 3]),\n (21, 'to', (10, 3), (1, 0), [19, 18, 4, 14, 2]),\n (22, 'one', (11, 3), (0, 1), [20, 21]),\n (23, 'two', (6, 6), (1, 1), [20, 21]),\n (24, 'three', (9, 6), (1, 1), [20, 21]),\n (25, 'four', (14, 6), (0, 1), [20, 21]),\n (26, 'five', (12, 3), (0, 1), [20, 21]),\n (27, 'six', (3, 7), (0, 1), [20, 21]),\n (28, 'seven', (4, 9), (1, 0), [20, 21]),\n (29, 'eight', (5, 4), (1, 1), [20, 21]),\n (30, 'nine', (4, 5), (1, 1), [20, 21]),\n (31, 'ten', (0, 5), (1, 1), [20, 21]),\n (32, 'eleven', (9, 5), (1, 1), [20, 21]),\n (33, 'twelve', (0, 10), (1, 0), [20, 21]),\n (34,\n  'oclock',\n  (6, 10),\n  (1, 0),\n  [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])]"
  },
  {
    "objectID": "posts/word-search-clock/index.html#occupying-vacant-spaces-in-the-grid",
    "href": "posts/word-search-clock/index.html#occupying-vacant-spaces-in-the-grid",
    "title": "Word Search Clock",
    "section": "Occupying vacant spaces in the grid",
    "text": "Occupying vacant spaces in the grid\nNot all spaces in the grid are filled as indicated by the question marks. Let’s see how many are empty.\n\nsum(row.count('?') for row in g)\n\n15\n\n\nWe can fill these spaces with some sage words.\n\ndef remove_spaces_and_punctuation(input_string):\n    # Remove spaces\n    no_spaces = input_string.replace(\" \", \"\")\n    \n    # Remove punctuation\n    translator = str.maketrans(\"\", \"\", string.punctuation)\n    no_punctuation = no_spaces.translate(translator)\n    \n    return no_punctuation\n\n\ndef replace_question_marks(grid, phrase):\n    chars = remove_spaces_and_punctuation(phrase)\n    i = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == '?' and i &lt; len(chars):\n                grid[row][col] = chars[i]\n                i += 1\n\n\nreplace_question_marks(g, \"Time keeps moving\")\n\nSpaces and interpunctions are removed before the phrase is placed in the grid."
  },
  {
    "objectID": "posts/word-search-clock/index.html#plotting-the-grid",
    "href": "posts/word-search-clock/index.html#plotting-the-grid",
    "title": "Word Search Clock",
    "section": "Plotting the grid",
    "text": "Plotting the grid\nNow, we’re ready to visualize the grid using matplotlib. To do so, I defined a few helper functions.\nThe following function converts a time to a sentence. The time is given in hours and minutes. The function returns a sentence that describes the time.\n\ndef time_to_sentence(hours, minutes):\n    # Define words for numbers\n    time_words = [\"twelve\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \n             \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"a quarter\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\", \"twenty\",\n             \"twenty-one\", \"twenty-two\", \"twenty-three\", \"twenty-four\", \"twenty-five\", \"twenty-six\", \"twenty-seven\", \"twenty-eight\", \"twenty-nine\", \"half\"]\n\n    # Convert hours and minutes to words\n    if minutes &lt;= 30:\n        hour_word = time_words[hours % 12]\n        minute_word = time_words[minutes]\n    else:\n        hour_word = time_words[(hours+1) % 12]\n        minute_word = time_words[60 - minutes]\n        \n    # Determine whether it's past or to\n    if minutes == 0:\n        time_phrase = f\"it is {hour_word} o'clock\"\n    elif minutes in [5, 10, 15, 20, 25, 30]:\n        time_phrase = f\"it is {minute_word} past {hour_word}\"\n    elif minutes in [35, 40, 45, 50, 55]:\n        time_phrase = f\"it is {minute_word} to {hour_word}\"\n    elif minutes == 1:\n        time_phrase = f\"it is {minute_word} minute past {hour_word}\"\n    elif minutes == 59:\n        time_phrase = f\"it is {minute_word} minute to {hour_word}\"\n    elif minutes &lt; 30:\n        time_phrase = f\"it is {minute_word} minutes past {hour_word}\"\n    else:\n        time_phrase = f\"it is {minute_word} minutes to {hour_word}\"\n\n    return time_phrase\n\nLet’s test this function.\n\nprint(time_to_sentence(10, 23))\nprint(time_to_sentence(0, 8))\n\nit is twenty-three minutes past ten\nit is eight minutes past twelve\n\n\nWe use a helper function that returns the word at a given location.\n\ndef word_at_location(words, r, c):\n    for (id, word, (x, y), dir, prec) in words:\n        if x == c and y == r:\n            return (id, word, (x, y), dir, prec)\n    return None        \n\nThe following function then finally plots the grid using matplotlib. It calls the time_to_sequence function to get a sentence that describes the time. This sentence is then split into words and the words are then highlighted in the grid. It loops through the positions in the grid from top-left to bottom-right and checks, using word_at_location, whether the word that starts at that position matches the next word in the sentence. If so, the word is highlighted.\n\ndef plot_grid(grid, words=None, hours=None, minutes=None, ax=None):\n    if not ax:\n        # Create a figure and axes\n        fig, ax = plt.subplots(figsize=(12,9))\n    else:\n        fig = None\n    \n    # Give all cells the same value/color\n    ax.imshow([[0 for cell in row] for row in grid], cmap='gray')\n\n    ax.patch.set_edgecolor('black')\n    ax.patch.set_linewidth(2)\n    \n    # Display the letters\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            ax.text(j, i, grid[i][j].upper(), ha='center', va='center', fontsize=32, color='white')\n\n    # Highlight the time\n    if not None in [hours, minutes, words]:\n        # Highlight the time\n        time_sentence = time_to_sentence(hours, minutes)\n        time_sentence = time_sentence.replace(\"-\", \" \")\n        time_sentence = time_sentence.replace(\"'\", \"\")\n\n        time_words = time_sentence.split()\n        i = 0\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                word_at_loc = word_at_location(words, r, c)\n                if word_at_loc:\n                    (_, word, (x, y), (d_x, d_y), _) = word_at_loc\n                    if i &lt; len(time_words) and time_words[i] == word[:len(time_words[i])]:\n                        x_values = [x, x + d_x * (len(time_words[i])-1) + 0.01]\n                        y_values = [y - 0.05, y + d_y * (len(time_words[i])-1) - 0.05]\n                        ax.plot(x_values, y_values, linewidth=35, solid_capstyle='round', alpha=0.5)\n                        i += 1\n    \n    # Remove the axes ticks\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    if fig:\n        fig.tight_layout()\n\nLet’s plot the grid with the time fourteen minutes past four.\n\nplot_grid(g, w, 4, 14)\nplt.show()"
  },
  {
    "objectID": "posts/word-search-clock/index.html#saving-images-to-file",
    "href": "posts/word-search-clock/index.html#saving-images-to-file",
    "title": "Word Search Clock",
    "section": "Saving images to file",
    "text": "Saving images to file\nWe can now generate all images and save them to file. We loop through all hours and minutes and call plot_grid to plot the grid and save it to disk.\noutput_directory = 'images'\nos.makedirs(output_directory, exist_ok=True)\n\nfor h in range(12):\n    for m in range(60):\n        plot_grid(g, w, h, m)\n        file_name = f\"time_{h:02d}_{m:02d}.jpg\"\n        file_path = os.path.join(output_directory, file_name)\n        plt.savefig(file_path, bbox_inches='tight')\n        plt.close()\nThe files are saved as JPEG to the images folder.\nFinally, the images need to be transfered to an SD card or USB flash drive for displaying them on the digital photo frame. I own a Braun DigiFrame 88 photo frame, but any photo frame that allows you to set the display interval of the slideshow should work."
  },
  {
    "objectID": "posts/word-search-clock/index.html#reflecting-on-the-outcome",
    "href": "posts/word-search-clock/index.html#reflecting-on-the-outcome",
    "title": "Word Search Clock",
    "section": "Reflecting on the outcome",
    "text": "Reflecting on the outcome\nI’m happy with how it turned out. It works pretty well, and I think it looks nice on my desk.\nThere’s some minor drift as the images don’t switch exactly after 60 seconds. I deal with it by adjusting the image manually once a week or so which is easy enough using the buttons on the back of the device.\nIf you want to play with the code to perhaps make a version for another language, check out one of the following links:\n  \nYou can also download just the images from here."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html",
    "href": "posts/making-sense-of-sorting/index.html",
    "title": "Making Sense of Sorting",
    "section": "",
    "text": "Sorting algorithms are a fundamental concept in computer science, but understanding how they work can be tricky. In this blog post, I’ll demonstrate an easy way to visualize their inner workings. By the end, you’ll not only be able to visualize sorting algorithms, but other list algorithms as well. Let’s dive in!"
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#importing-libraries",
    "href": "posts/making-sense-of-sorting/index.html#importing-libraries",
    "title": "Making Sense of Sorting",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing the necessary libraries.\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation\nimport random\n\nfrom copy import copy\nfrom queue import Queue\nfrom IPython.display import HTML"
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#the-sorting-algorithms",
    "href": "posts/making-sense-of-sorting/index.html#the-sorting-algorithms",
    "title": "Making Sense of Sorting",
    "section": "The sorting algorithms",
    "text": "The sorting algorithms\nI will use the Selection sort and Quicksort algorithms as examples.\n\nSelection sort\nSelection sort iterates through a list, selects the smallest element, and swaps it with the first element. It then repeats this process for the remaining unsorted portion of the list until it is fully sorted.\nHere’s what it looks like in Python:\n\ndef selection_sort(a):\n    n = len(a)\n    for i in range(0, n-1):\n        k = i\n        for j in range(i+1, n):\n            if a[j] &lt; a[k]:\n                k = j\n        a[i], a[k] = a[k], a[i]\n\nIt’s short but, with an \\(\\mathcal{O}(n^2)\\) time complexity, not very efficient.\n\n\nQuicksort\nAs the name suggests, Quicksort is much faster. The algorithm works by selecting a pivot element and partitioning the list into two sub-lists: one with elements less than the pivot and another with elements greater than the pivot. This process is repeated recursively on each sub-list until the entire list is sorted.\n\ndef quick_sort(a, l=0, h=0):\n    if h == 0:\n        h = len(a) - 1\n    m = a[(l + h) // 2]\n    i = l\n    j = h\n    while i &lt;= j:\n        while a[i] &lt; m:\n            i += 1\n        while a[j] &gt; m:\n            j -= 1\n        if i &lt;= j:\n            a[i], a[j] = a[j], a[i]\n            i += 1\n            j -= 1\n    if l &lt; j:\n        quick_sort(a, l, j)\n    if i &lt; h:\n        quick_sort(a, i, h)\n\nQuicksort has a time complexity of \\(\\mathcal{O}(n\\log{}n)\\)."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#subclassing-list",
    "href": "posts/making-sense-of-sorting/index.html#subclassing-list",
    "title": "Making Sense of Sorting",
    "section": "Subclassing list",
    "text": "Subclassing list\nThe approach I take here is to create a special type of list called MonitoredList that keeps track of when its items are being accessed or changed. It does this by recording all these actions into a queue.\n\nclass MonitoredList(list):\n    def __init__(self, q, iterable):\n        super().__init__(iterable)\n        self.queue = q\n    \n    def __getitem__(self, index):\n        self.queue.put({\n            'method': '__getitem__',\n            'object': copy(self),\n            'args': [index]\n        })\n        return super().__getitem__(index)\n    \n    def __setitem__(self, index, value):\n        self.queue.put({\n            'method': '__setitem__',\n            'object': copy(self),\n            'args': [index, value]\n        })\n        super().__setitem__(index, value)\n    \n    def state_to_queue(self):\n        self.queue.put({\n            'method': 'state_to_queue',\n            'object': copy(self),\n            'args': []\n        })\n\nWhenever an item in the list is read or modified, the MonitoredList class logs information about the operation (like what method was used and what the arguments were) into the queue.\nAdditionally, the class has a method called state_to_queue which allows you to log the entire state of the list at any given time.\nTo demonstrate how the MonitoredList class is used, take a look at the following code:\n\nl = [1, 2, 3, 4]\n\nq = Queue(-1)\nml = MonitoredList(q, l)\n\nml[0] = 5 # This calls __setitem__\nml[2] = 4 # This calls __setitem__\n\nv = ml[3] # This calls __getitem__\n\nml.state_to_queue()\n\nWe start by creating a list l with four elements: [1, 2, 3, 4] and a Queue object q.\nNext, we create a MonitoredList object ml by passing q and l as parameters.\nThe next two lines of code modify ml by setting its first and third elements to 5 and 4 respectively. These modifications call the __setitem__ method of the MonitoredList object which logs information about the operation into the q queue.\nThe next line accesses the fourth element of ml and assigns its value to v. This access operation calls the __getitem__ method of the MonitoredList object which also logs information about the operation into the q queue.\nFinally, the state_to_queue method of the MonitoredList object is called which logs the current state of the list into the q queue.\nWe can get a record of all the operations that have been performed on the MonitoredList by reading the contents of the q queue.\n\nwhile not q.empty():\n    print(q.get())\n\n{'method': '__setitem__', 'object': [1, 2, 3, 4], 'args': [0, 5]}\n{'method': '__setitem__', 'object': [5, 2, 3, 4], 'args': [2, 4]}\n{'method': '__getitem__', 'object': [5, 2, 4, 4], 'args': [3]}\n{'method': 'state_to_queue', 'object': [5, 2, 4, 4], 'args': []}\n\n\nIf we apply a sorting algorithm on a MonitoredList, any direct access and modification operations performed on individual elements by the sorting algorithm will be logged into the queue. We can then use the contents of this queue to create an animation."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#animating-list-algorithms",
    "href": "posts/making-sense-of-sorting/index.html#animating-list-algorithms",
    "title": "Making Sense of Sorting",
    "section": "Animating list algorithms",
    "text": "Animating list algorithms\nThe animate_algorithm function below takes a sorting function and a list as input, and visualizes the sorting process by creating a Matplotlib animation that highlights the list elements being accessed and modified during the sorting process. It achieves this by creating a MonitoredList object to track all changes made to the list into a queue. The function then defines an animation function that extracts the elements from the queue and creates the visualization.\n\ndef animate_algorithm(fun, inp):\n    global bars\n    \n    q = Queue(-1)\n    values = MonitoredList(q, inp)\n    \n    fun(values)\n    values.state_to_queue()\n    \n    def gen_func():\n        while not q.empty():\n            item = q.get()\n            if item['method'] in ['__getitem__', '__setitem__', 'state_to_queue']:\n                yield item\n    \n    def animate(elem):\n        global bars\n        bars.remove()\n        ax.clear()\n        ax.axis('off')\n        bars = ax.bar(x_pos, elem['object'], color='steelblue', width=1.0)\n        if elem['method'] == '__getitem__':\n            x = elem['args'][0]\n            ax.plot([x,x],[0,max(elem['object'])], color='green')\n        elif elem['method'] == '__setitem__':\n            x = elem['args'][0]\n            ax.plot([x,x],[0,max(elem['object'])], color='red')\n    \n    x_pos = list(range(len(values)))\n    plt.style.use('default')\n    fig, ax = plt.subplots()\n    ax.axis('off')\n    bars = ax.bar(x_pos, values, width=1.0)\n    plt.close()\n    \n    anim = matplotlib.animation.FuncAnimation(fig, animate, frames=gen_func, save_count=999999999999)\n    \n    return anim\n\nThe visualization was inspired by this video. A bar chart is used to display the contents of the list. The visualization highlights the accessed and modified elements by adding a green line and a red line respectively to the chart."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#creating-the-animations",
    "href": "posts/making-sense-of-sorting/index.html#creating-the-animations",
    "title": "Making Sense of Sorting",
    "section": "Creating the animations",
    "text": "Creating the animations\nAlright, let’s generate some animations. We first have to create a randomized list that we can sort, so let’s begin by doing that.\n\nvalues = list(range(30))\nrandom.shuffle(values)\n\n\nSelection sort\nNow, we’re going to create an animation for the selection sort algorithm. To do so, we pass the function and the list of random values to the animate_algorithm function.\n\nanim = animate_algorithm(selection_sort, values)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n\n\nQuicksort\nWe can do the same for quicksort.\n\nanim = animate_algorithm(quick_sort, values)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\n\n\nRandom shuffle\nIn addition to sorting algorithms, we can animate other list manipulation algorithms as well. For example, let’s animate the random.shuffle function.\n\nanim = animate_algorithm(random.shuffle, list(range(30)))\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nIt appears that random.shuffle implements the Fisher-Yates shuffle."
  },
  {
    "objectID": "posts/making-sense-of-sorting/index.html#conclusion",
    "href": "posts/making-sense-of-sorting/index.html#conclusion",
    "title": "Making Sense of Sorting",
    "section": "Conclusion",
    "text": "Conclusion\nSo there you have it! By following the steps laid out in this post, you can easily visualize sorting and other list algorithms. The provided code hopefully allows you to gain a deeper understanding of how these algorithms work.\nIf you want to animate other (sorting) algorithms, check out one of the following links:"
  },
  {
    "objectID": "posts/supercharging-the-nabaztag/index.html",
    "href": "posts/supercharging-the-nabaztag/index.html",
    "title": "Supercharging the Nabaztag",
    "section": "",
    "text": "The Nabaztag is a WiFi enabled ambient device shaped like a bunny. It has moveable ears, a speaker, several LEDs, and a button on its head. The second generation (the one I have) also has a microphone, an RFID sensor, and supports MP3 audio streams.\nThese Nabaztag bunnies rely on a server to function. Originally the company that produced these things provided for one but after they went bankrupt in 2009, thousands of these devices were rendered useless.\nLuckily, various alternative servers were developed. These servers often make use of plugins to give the connected bunnies certain abilities. Extending your bunny with new capabilities requires some programming skills if there is no existing plugin that already does what you want.\nI developed my own Nabaztag server in Prolog that you can download from this repository. Instead of making use of plugins to extend a Nabaztag’s capabilities, my server simply forwards all events to an IFTTT webhook. The server also exposes an API to do things like play audio, flash LEDs, move the ears, do TTS, etc. This API can be called from the IFTTT platform."
  },
  {
    "objectID": "posts/supercharging-the-nabaztag/index.html#about-the-ifttt-plaform",
    "href": "posts/supercharging-the-nabaztag/index.html#about-the-ifttt-plaform",
    "title": "Supercharging the Nabaztag",
    "section": "About the IFTTT plaform",
    "text": "About the IFTTT plaform\nIn case you don’t know, IFTTT (which stands for IF This Then That) is a platform that allows you to connect certain actions to certain triggers. You can for instance setup a ‘recipe’ to turn on your Philips Hue lights (the action) when you phone connects to your home WiFi network (the trigger). Another example would be a recipe that sends you a Telegram message (the action) when the weather forecast predicts it’s going to rain (the trigger). By making use of IFTTT webhooks we can integrate triggers and actions of the Nabaztag into our recipes."
  },
  {
    "objectID": "posts/supercharging-the-nabaztag/index.html#example-recipes",
    "href": "posts/supercharging-the-nabaztag/index.html#example-recipes",
    "title": "Supercharging the Nabaztag",
    "section": "Example recipes",
    "text": "Example recipes\nI’ll describe a few recipes that I setup to give you an idea of the possibilities. In the recipes below I assume the Nabaztag server is running and reachable at IP address 123.123.123.123.\n\nText to speech\nOne recipe makes the Nabaztag greet me when I get home. For this you need to have the IFTTT app installed on your phone.\n\nTrigger: Android device, Connects to a specific WiFi Network\n\nNetwork name: SSID_of_your_home_WiFi\n\nAction: Webhooks, make a web request\n\nURL: http://123.123.123.123/vl/api/tts.jsp\nMethod: POST\nContent Type: application/x-www-form-urlencoded\nBody: sn=0013d3123456&text=Welcome%20home\n\n\nReplace the parts in italics (the network name, IP address in the URL, and bunny’s serial number in the body) with your specifics.\n\n\nPlay sounds\nI also wanted the bunny to strike the hour like a cuckoo clock. For this I added 24 recipes, one for each hour. This is the one for 5PM.\n\nTrigger: Date & Time, Every day at\n\nTime: 05 PM, 00 minutes\n\nAction: Webhooks, make a web request\n\nURL: http://123.123.123.123/vl/api/play.jsp\nMethod: POST\nContent Type: application/x-www-form-urlencoded\nBody: sn=0013d3123456&url=http://123.123.123.123/vl/sounds/cuckoo5.mp3\n\n\nAgain, change the options in italics to your specifics.\n\n\nShow ambient patterns\nThe Nabaztag has various built-in ambient LED patterns that it can show when not doing anything else. There are built-in patterns that show the state of the weather, the market, traffic, messages, and air quality. We can set these ambient patterns on receiving certain triggers. For instance, we can set the ambient weather pattern to rain when the forecast for a certain location is rain:\n\nTrigger: Weather Underground, Current condition changes to\n\nCurrent Condition: Rain\nLocation: Your location\n\nAction: Webhooks, make a web request\n\nURL: http://123.123.123.123/vl/api/ambient.jsp?sn=0013d3123456&weather=rain\nMethod: POST\nContent Type: text/plain\nBody:\n\n\nAdd similar recipes for other weather conditions. Similarly one can make the bunny show ambient patterns that indicate what’s going on in the financial market if you’re keen on keeping track of that.\n\n\nRecord a message\nOne can also record a message on the Nabaztag by keeping the button on its head pressed. After the bunny beeps, you can speak into its microphone. On release, the recorded message is sent to the server. The server saves the message to a WAV file and sends the location of that file to the IFTTT platform where it can be caught using a webhook. The following recipe shows how this can be used to send an email every time a message is recorded.\n\nTrigger: Webhooks, Receive a web request\n\n0013d3123456_record_click\n\nAction: Email, Send me an email\n\nSubject: New message from your Nabaztag\nBody: Dear owner,&lt;br&gt;&lt;br&gt;On {{OccurredAt}} a message was recorded on your Nabaztag. Click &lt;a href=”{{Value1}}”&gt;here to download&lt;/a&gt;.&lt;br&gt;&lt;br&gt;Sincerely,&lt;br&gt;&lt;br&gt;Your favourite bunny"
  },
  {
    "objectID": "posts/supercharging-the-nabaztag/index.html#conclusion",
    "href": "posts/supercharging-the-nabaztag/index.html#conclusion",
    "title": "Supercharging the Nabaztag",
    "section": "Conclusion",
    "text": "Conclusion\nThese examples should be enough to get you started.\nRead the README.md file in the repository for details on how to configure the server and how to use the API. Take note that before running the server you’ll need to enter the Nabaztag’s serial number, your IFTTT Webhook key, and server details into the config.pl file.\nShare your recipe ideas in the comments below!"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html",
    "href": "posts/mathematicians-birthdays-calendar/index.html",
    "title": "Mathematicians’ Birthdays Calendar",
    "section": "",
    "text": "I teach several courses in the Applied Mathematics program at NHL Stenden University of Applied Sciences. My favorite days are the ones when there’s something to celebrate (like a birthday) and someone brings cake.\nIn an effort to convince my department that we should have cake more often, I’ve created a birthday calendar featuring the birthdates of mathematicians, both living and deceased. I scraped these birthdays from Wikipedia and converted them into an ICS file that can be imported into a calendar application like Google Calendar or Microsoft Outlook Calendar.\nRead on to learn how I did this."
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#importing-libraries",
    "href": "posts/mathematicians-birthdays-calendar/index.html#importing-libraries",
    "title": "Mathematicians’ Birthdays Calendar",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing some libraries. I’m using Selenium for webscraping. The icalendar package is used to create the birthday calendar.\n\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.common.by import By\nfrom selenium.common.exceptions import NoSuchElementException\nfrom webdriver_manager.chrome import ChromeDriverManager\n\nfrom icalendar import Calendar, Event, vRecur\nfrom datetime import date\n\nfrom abc import ABC, abstractmethod\n\nimport pandas as pd\n\nimport re\nimport calendar\nimport pickle\nimport json"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#scraping-wikipedia",
    "href": "posts/mathematicians-birthdays-calendar/index.html#scraping-wikipedia",
    "title": "Mathematicians’ Birthdays Calendar",
    "section": "Scraping Wikipedia",
    "text": "Scraping Wikipedia\nWikipedia has, for each day of the year, an entry listing historical events, births, and deaths. We will scrape, for each day in a year, from this list, the births of mathematicians and place them in a dictionary.\nTo see what I mean, let’s look at the entry for December, the 7th.\n\nEach wikipedia page has a title which is shown here with a red border. If we scroll down we see a list of people who were born on this day. The first mathematician we find is Leopold Kronecker.\n\nScrolling further down, we find three more mathematicians.\nThe idea is to open for each day in the year its corresponding Wikipedia page. Using XPATH expressions, we’ll extract the title of the page and each row in the list of births that contains the word mathematician. Each row, contains the year the mathematician was born (1823), their name (Leopold Kronecker), a one-line bio (Polish-German mathematician and academic (d. 1891)), and a URL pointing to a Wikipedia page about the mathematician in question (https://en.wikipedia.org/wiki/Leopold_Kronecker)."
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#building-the-scraper",
    "href": "posts/mathematicians-birthdays-calendar/index.html#building-the-scraper",
    "title": "Mathematicians’ Birthdays Calendar",
    "section": "Building the scraper",
    "text": "Building the scraper\nThere are various ways to scrape using Python. Popular scraping libraries include Scrapy and Beautiful Soup. I usually use Selenium because it allows me to scrape from websites that render HTML from JavaScript. Selenium can be a bit slow, but we’re only scraping 366 pages so it won’t take that long.\nIn previous projects I have created some helper classes that allow me to quickly set up a scraping task. These classes can be easily chained together to define a new scraper. I got inspired by scraper tools such as Web scraper and ParseHub that let you compose a tree that specifies how to parse data from a website. Using the classes I defined, we can do something similar in Python.\nAll these helper classes inherit from an abstract base class called BaseSelector.\n\nclass BaseSelector(ABC):\n    @abstractmethod\n    def scrape(self, scraper, parent, **kwargs):\n        pass\n\nClasses that inherit from BaseSelector need to provide an implementation of the scrape method. This method generally scrapes some content from a webpage and returns this wrapped up in a Python dictionary. It may scrape a single DOM element, and return a single dictionary object, or it may scrape multiple elements and return these as a list of dictionaries.\n\nScraping attributes\nThe following class is one of these classes that inherit from BaseSelector. It locates an element(s) and returns a specific attribute of that element, such as the href (in case it matches an anchor link).\n\nclass AttributeSelector(BaseSelector):\n    def __init__(self, id, by, path, attribute, multiple=False, default=None):\n        self.id = id\n        self.by = by\n        self.path = path\n        self.attribute = attribute\n        self.multiple = multiple\n        self.default = default\n\n    def scrape(self, scraper, parent, **kwargs):    \n        if not self.multiple:\n            try:\n                elem = parent.find_element(self.by, self.path.format(**kwargs))\n                return {self.id: elem.get_attribute(self.attribute)}\n            except NoSuchElementException:\n                return self.default\n        else:\n            elems = parent.find_elements(self.by, self.path.format(**kwargs))\n            return [{self.id: elem.get_attribute(self.attribute)} for elem in elems]\n\nLet’s see how we can use it to scrape the URLs for each mathematicians found on a page (e.g. https://en.m.wikipedia.org/wiki/Leopold_Kronecker).\nWe create a new AttributeSelector as follows.\n\nurls_selector = AttributeSelector(\n    'url', \n    By.XPATH, \n    \"//*[@id='mw-content-text']/div/ul[preceding::h2/span[.='Births'] and following::h2/span[.='Deaths']]/li[contains(., 'mathematician')]/a[string-length(.)&gt;4][1]\", \n    'href', \n    multiple=True\n)\n\nWe provide a key (‘url’) for the dictionary object.\nWe also tell it to search for an element addressed by an XPATH expression. In this case we look for list items that contain the string mathematician and find within each list item the first link with a content length of greater than four. We check for length because sometimes it may find multiple links on a single line but the first link always refers to a year (and is therefor at most 4 digits long). Note how we’re only looking for li elements after a span that contains the text Births, but before a span that contains the word Deaths. XPATH expressions can get a bit unwieldly but they’re very powerful.\nLinks (a or anchor tags) have an href attribute that we are interested in. We can expect multiple results as there may be multiple mathematicians born on the same day.\nBefore we can call this urls_selector object, we first need to initilize a Selenium webdriver.\ndriver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))\nThis will open a new instance of Google Chrome. Now we can open the webpage we want to scrape from.\ndriver.get(\"https://en.wikipedia.org/wiki/December_7\")\nAnd we get the URLs we’re interested in.\nurls = urls_selector.scrape(driver, driver)\n\nurls\n\n[{'url': 'https://en.wikipedia.org/wiki/Leopold_Kronecker'},\n {'url': 'https://en.wikipedia.org/wiki/Danilo_BlanuC5%A1a'},\n {'url': 'https://en.wikipedia.org/wiki/Mary_Ellen_Rudin'},\n {'url': 'https://en.wikipedia.org/wiki/Nick_Katz'}]\n\n\n\n\nScraping text\nMost often we are interested in the text that is contained in an element. To scrape simple text we can use the TextSelector class.\n\nclass TextSelector(AttributeSelector):\n    def __init__(self, id, by, path, multiple=False, default=None):\n        super().__init__(id, by, path, 'innerText', multiple, default)\n\nIt extends the AttributeSelector class we defined before. We can use it as follows to get all text of lines that contain the word mathematician.\n\nmathematician_selector = TextSelector(\n    'mathematician', \n    By.XPATH, \n    \"//*[@id='mw-content-text']/div/ul[preceding::h2/span[.='Births'] and following::h2/span[.='Deaths']]/li[contains(., 'mathematician')]\", \n    multiple=True\n)\n\nAgain we use XPATH to address the elements we’re interested in. This time we don’t have to check for URL length, so the expression is a bit simpler. Let’s use it to get each line corresponding to the birth of a mathematician.\nmathematicians = mathematician_selector.scrape(driver, driver)\n\nmathematicians\n\n[{'mathematician': '1823 – Leopold Kronecker, Polish-German mathematician and academic (d. 1891)'},\n {'mathematician': '1903 – Danilo Blanuša, Croatian mathematician, physicist, and academic (d. 1987)'},\n {'mathematician': '1924 – Mary Ellen Rudin, American mathematician (d. 2013)[16]'},\n {'mathematician': '1943 – Nick Katz, American mathematician and academic'}]\n\n\nSimilarly we can scrape the month and day from the top of the page.\n\nmonth_day_selector = TextSelector('month_day', By.XPATH, '//*[@id=\"firstHeading\"]/span')\n\nmonth_day = month_day_selector.scrape(driver, driver)\n\nmonth_day\n\n{'month_day': 'December 7'}\n\n\n\n\nCleaning and transforming data\nWe see that the third item in the mathematicians list, contains a reference as indicated by [16]. We want to get rid of this. Furthermore, we also want to split the values for the key mathematician into several keys, such as, year, name, bio.\nThe value month_day contains both the month and day. This is another thing we will want to split up into two seperate keys.\nWe could leave it as is, and do some data cleaning after having scraped all pages. With the approach I’m taking here, it’s however quite easy to immediately clean and transform the data while scraping.\nI defined a MapSelector class that let’s me map a function over scraped data.\n\nclass MapSelector(BaseSelector):\n    def __init__(self, fun, child):\n        self.fun = fun\n        self.child = child\n\n    def scrape(self, scraper, parent, **kwargs):\n        data = self.child.scrape(scraper, parent, **kwargs)\n        if type(data) == dict:\n            return self.fun(data)\n        return list(map(self.fun, data))\n\nThis class doesn’t do any actual scraping, but is meant to be chained with other selector classes. Let’s see how it can be used to split up month_day values. We’ll also convert the month name to its number.\n\nsplit_month_day_selector = MapSelector(\n    lambda m: { \n        \"day\": int(m['month_day'].split()[1]), \n        \"month\": list(calendar.month_name).index(m['month_day'].split()[0]) \n    },\n    month_day_selector\n)\n\nNote how I’m specifying a lambda function to split up month_day into two seperate keys. I’m passing the month_day_selector we defined above to the constructor as well so the MapSelector knows where to get data from before applying the function.\nsplit_month_day = split_month_day_selector.scrape(driver, driver)\nCalling scrape on the split_month_day_selector object will cause it to call the scrape function on the month_day_selector which does the actual scraping.\n\nsplit_month_day\n\n{'day': 7, 'month': 12}\n\n\nInstead of providing a lambda function, we can use a regular function. Let’s create a function that cleans and splits up the mathematician key in the mathematicians list.\n\ndef unpack_mathematician_data(m):\n    data = re.sub(r'\\[[^\\]]*\\]', '', m['mathematician']) # remove any references\n    match = re.match(r'^(\\d+)\\s.*–\\s*(.*?),\\s*(.*?)$', data)\n\n    return {\n        \"year\": int(match.group(1)),\n        \"name\": match.group(2),\n        \"bio\": match.group(3)\n    }\n\n\nsplit_mathematicians_selector = MapSelector(unpack_mathematician_data, mathematician_selector)\n\nsplit_mathematicians = split_mathematicians_selector.scrape(driver, driver)\nNow we have our data in seperate keys.\n\nsplit_mathematicians\n\n[{'year': 1823,\n  'name': 'Leopold Kronecker',\n  'bio': 'Polish-German mathematician and academic (d. 1891)'},\n {'year': 1903,\n  'name': 'Danilo Blanuša',\n  'bio': 'Croatian mathematician, physicist, and academic (d. 1987)'},\n {'year': 1924,\n  'name': 'Mary Ellen Rudin',\n  'bio': 'American mathematician (d. 2013)'},\n {'year': 1943,\n  'name': 'Nick Katz',\n  'bio': 'American mathematician and academic'}]\n\n\n\n\nMerging data\nWe now have selectors that we can call to scrape a list of dictionaries with the year, name, and biography of each mathematician, and a dictionary with the month and day these mathematicians were born. We also defined a selector that scrapes a list of dictionaries of URLs.\nIn order to merge data from different selectors I defined a ZipSelector. If it merges two lists, the dicts in the first list will be extended with the keys and values of the dicts in the second list. It will only return as many items as are contained in the shortest list (similar to Python zip). If a list is merged with a dictionary, the dictionary keys are added to each dictionary in the list. If it merges two dictionaries, it returns a single dictionary containing the keys and values of both dictionaries.\n\nclass ZipSelector(BaseSelector):\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n        \n    def scrape(self, scraper, parent, **kwargs):\n        data_left = self.left.scrape(scraper, parent, **kwargs)\n        data_right = self.right.scrape(scraper, parent, **kwargs)\n        \n        if type(data_left) == dict and type(data_right) == dict:\n            return data_left | data_right\n        elif type(data_left) == dict and type(data_right) == list:\n            return [data_left | m for m in data_right]\n        elif type(data_left) == list and type(data_right) == dict:\n            return [m | data_right for m in data_left]\n        return [data_left[i] | data_right[i] for i in range(min(len(data_left),len(data_right)))]\n\nLet’s see how it works.\n\nzip_month_day_mathematicians_selector = ZipSelector(split_month_day_selector, split_mathematicians_selector)\nzip_month_day_mathematicians_urls_selector = ZipSelector(zip_month_day_mathematicians_selector, urls_selector)\n\nWe first merge the month and day with the year, name, and bio. Then using a second ZipSelector we combine this with url.\nzip_month_day_mathematicians_urls = zip_month_day_mathematicians_urls_selector.scrape(driver, driver)\nIf it wasn’t clear already: we don’t need to call the scrape method on each selector object seperately. We are combining selector objects into a tree and just call scrape on the root node and this causes a cascade of calls throughout the tree.\n\nzip_month_day_mathematicians_urls\n\n[{'day': 7,\n  'month': 12,\n  'year': 1823,\n  'name': 'Leopold Kronecker',\n  'bio': 'Polish-German mathematician and academic (d. 1891)',\n  'url': 'https://en.wikipedia.org/wiki/Leopold_Kronecker'},\n {'day': 7,\n  'month': 12,\n  'year': 1903,\n  'name': 'Danilo Blanuša',\n  'bio': 'Croatian mathematician, physicist, and academic (d. 1987)',\n  'url': 'https://en.wikipedia.org/wiki/Danilo_Blanu%C5%A1a'},\n {'day': 7,\n  'month': 12,\n  'year': 1924,\n  'name': 'Mary Ellen Rudin',\n  'bio': 'American mathematician (d. 2013)',\n  'url': 'https://en.wikipedia.org/wiki/Mary_Ellen_Rudin'},\n {'day': 7,\n  'month': 12,\n  'year': 1943,\n  'name': 'Nick Katz',\n  'bio': 'American mathematician and academic',\n  'url': 'https://en.wikipedia.org/wiki/Nick_Katz'}]\n\n\n\n\nNavigating pages\nWe can now call the zip_month_day_mathematicians_urls_selector for each page we want to scrape. This means calling the get method on the driver object to navigate to each page and then repeatedly call the scrape method on the zip_month_day_mathematicians_urls_selector object and concatenate all the results. To do that automatically I’ve created, you guessed it, another class. The URLSelector class takes a list of URLs and opens them one by one each time calling a selector instance to scrape the data. All the data that is scraped is concatenated and eventually returned.\n\nclass URLSelector(BaseSelector):\n    def __init__(self, urls, child):\n        self.urls = urls\n        self.child = child\n        \n    def scrape(self, scraper, parent, **kwargs):\n        result = []\n        \n        for url in self.urls:\n            scraper.get(url.format(**kwargs))\n            data = self.child.scrape(scraper, scraper, **kwargs)\n            \n            if type(data) == dict:\n                result.append(data)\n            elif type(data) == list:\n                result.extend(data)\n            \n        return result\n\nThe constructor takes a list of URLs and a selector class to call for each page.\nWe start by creating a list of all URLs we will scrape from.\n\nmonth_names = calendar.month_name[1:]\ndays_in_month = [calendar.monthrange(2020, month)[1] for month in range(1, 13)]\nmonths_and_days = list(zip(month_names, days_in_month))\n\nwikipedia_urls = [f\"https://en.wikipedia.org/wiki/{month}_{day+1}\" for (month, days) in months_and_days for day in range(days)]\n\nNote how I selected a leap year (2020) to make sure I get 366 URLs. Let’s show the first five.\n\nwikipedia_urls[:5]\n\n['https://en.wikipedia.org/wiki/January_1',\n 'https://en.wikipedia.org/wiki/January_2',\n 'https://en.wikipedia.org/wiki/January_3',\n 'https://en.wikipedia.org/wiki/January_4',\n 'https://en.wikipedia.org/wiki/January_5']\n\n\nNow we create an instance of URLSelector and pass it this list of URLs and the selector object to call for each page, in this case zip_month_day_mathematicians_urls_selector.\n\nscraper = URLSelector(wikipedia_urls, zip_month_day_mathematicians_urls_selector)\n\nWe build the scraper step by step. Here’s an overview of how we combined the various classes.\n\n\n\n\n\n\n\nscraper\n\n  \n\nus\n\n URLSelector   \n\nzs1\n\n ZipSelector   \n\nus-&gt;zs1\n\n    \n\nzs2\n\n ZipSelector   \n\nzs1-&gt;zs2\n\n    \n\nas\n\n AttributeSelector   \n\nzs1-&gt;as\n\n    \n\nms1\n\n MapSelector   \n\nzs2-&gt;ms1\n\n    \n\nms2\n\n MapSelector   \n\nzs2-&gt;ms2\n\n    \n\nts1\n\n TextSelector   \n\nms1-&gt;ts1\n\n    \n\nts2\n\n TextSelector   \n\nms2-&gt;ts2\n\n   \n\n\n\n\n\nThe direction of the arrows indicate the direction of the cascade of calls. The data flows in the opposite direction.\nOnly TextSelector and AttributeSelector do any actual scraping. URLSelector navigates to each URL. The other selector classes merge or transform the data. In other scraping projects I might use custom selector classes that take care of pagination or filling forms and pressing buttons."
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#running-the-scraper",
    "href": "posts/mathematicians-birthdays-calendar/index.html#running-the-scraper",
    "title": "Mathematicians’ Birthdays Calendar",
    "section": "Running the scraper",
    "text": "Running the scraper\nCalling the scrape method will scrape all mathematicians’ birthdays.\ndata = scraper.scrape(driver, driver)\nLet’s looks at the first five results.\n\ndata[:5]\n\n[{'day': 1,\n  'month': 1,\n  'year': 1878,\n  'name': 'Agner Krarup Erlang',\n  'bio': 'Danish mathematician, statistician, and engineer (d. 1929)',\n  'url': 'https://en.wikipedia.org/wiki/Agner_Krarup_Erlang'},\n {'day': 1,\n  'month': 1,\n  'year': 1894,\n  'name': 'Satyendra Nath Bose',\n  'bio': 'Indian physicist and mathematician (d. 1974)',\n  'url': 'https://en.wikipedia.org/wiki/Satyendra_Nath_Bose'},\n {'day': 1,\n  'month': 1,\n  'year': 1905,\n  'name': 'Stanisław Mazur',\n  'bio': 'Ukrainian-Polish mathematician and theorist (d. 1981)',\n  'url': 'https://en.wikipedia.org/wiki/Stanis%C5%82aw_Mazur'},\n {'day': 1,\n  'month': 1,\n  'year': 1912,\n  'name': 'Boris Vladimirovich Gnedenko',\n  'bio': 'Russian mathematician and historian (d. 1995)',\n  'url': 'https://en.wikipedia.org/wiki/Boris_Vladimirovich_Gnedenko'},\n {'day': 2,\n  'month': 1,\n  'year': 1803,\n  'name': 'Guglielmo Libri Carucci dalla Sommaja',\n  'bio': 'Italian mathematician and academic (d. 1869)',\n  'url': 'https://en.wikipedia.org/wiki/Guglielmo_Libri_Carucci_dalla_Sommaja'}]\n\n\nWe can save the result as a JSON file.\n# Save to a JSON file\nwith open('data.json', 'w') as json_file:\n    json.dump(data, json_file)\nOr convert it to a dataframe and save it as CSV.\n\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nday\nmonth\nyear\nname\nbio\nurl\n\n\n\n\n0\n1\n1\n1878\nAgner Krarup Erlang\nDanish mathematician, statistician, and engine...\nhttps://en.wikipedia.org/wiki/Agner_Krarup_Erlang\n\n\n1\n1\n1\n1894\nSatyendra Nath Bose\nIndian physicist and mathematician (d. 1974)\nhttps://en.wikipedia.org/wiki/Satyendra_Nath_Bose\n\n\n2\n1\n1\n1905\nStanisław Mazur\nUkrainian-Polish mathematician and theorist (d...\nhttps://en.wikipedia.org/wiki/Stanis%C5%82aw_M...\n\n\n3\n1\n1\n1912\nBoris Vladimirovich Gnedenko\nRussian mathematician and historian (d. 1995)\nhttps://en.wikipedia.org/wiki/Boris_Vladimirov...\n\n\n4\n2\n1\n1803\nGuglielmo Libri Carucci dalla Sommaja\nItalian mathematician and academic (d. 1869)\nhttps://en.wikipedia.org/wiki/Guglielmo_Libri_...\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n833\n28\n12\n1950\nClifford Cocks\nEnglish mathematician and cryptographer\nhttps://en.wikipedia.org/wiki/Clifford_Cocks\n\n\n834\n29\n12\n1856\nThomas Joannes Stieltjes\nDutch-French mathematician and academic (d. 1894)\nhttps://en.wikipedia.org/wiki/Thomas_Joannes_S...\n\n\n835\n30\n12\n1944\nJoseph Hilbe\nAmerican mathematician and philosopher (d. 2017)\nhttps://en.wikipedia.org/wiki/Joseph_Hilbe\n\n\n836\n31\n12\n1714\nArima Yoriyuki\nJapanese mathematician and educator (d. 1783)\nhttps://en.wikipedia.org/wiki/Arima_Yoriyuki\n\n\n837\n31\n12\n1952\nVaughan Jones\nNew Zealand mathematician and academic (d. 2020)\nhttps://en.wikipedia.org/wiki/Vaughan_Jones\n\n\n\n\n838 rows × 6 columns\n\n\n\n\ndf.to_csv('data.csv', index=False)"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#creating-the-calendar",
    "href": "posts/mathematicians-birthdays-calendar/index.html#creating-the-calendar",
    "title": "Mathematicians’ Birthdays Calendar",
    "section": "Creating the calendar",
    "text": "Creating the calendar\nWe’re now ready to convert this data into an ICS calendar file so it can be imported into a calendar application, like Google Calendar or Microsoft Outlook.\n\n# Create the calendar\ncal = Calendar()\n\n# Iterate through the birthday data and add recurring events to the calendar\nfor person in data:\n    name = person['name']\n    birthdate = date(person['year'], person['month'], person['day'])\n    bio = person['bio']\n    url = person['url']\n\n    # Create an event for the birthday with recurrence rule\n    event = Event()\n    event.add('summary', f\"{name}'s birthday\")\n    event.add('description', f\"{name} - {bio}\\n\\n{url}\")\n    event.add('dtstart', birthdate)\n    event.add('rrule', {'freq': 'yearly'})\n    event.add('url', url)\n    event.add('transp', 'TRANSPARENT') # Make events not show up as 'busy'\n\n    cal.add_component(event)\n\n# Save the calendar to a file\nwith open('mathematicians_birthdays_calendar.ics', 'wb') as ics_file:\n    ics_file.write(cal.to_ical())\n\nThe file is saved as mathematicians_birthdays_calendar.ics and ready to be imported into your calendar."
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#importing-the-calendar",
    "href": "posts/mathematicians-birthdays-calendar/index.html#importing-the-calendar",
    "title": "Mathematicians’ Birthdays Calendar",
    "section": "Importing the calendar",
    "text": "Importing the calendar\nHere’s how to add the ICS calendar to Google Calendar:\n\nOpen Google Calendar: Open your Google Calendar in a web browser. Ensure that you are logged in with the Google account you want to associate with the birthday calendar.\nNavigate to “Settings”: In the top-right corner, click on the gear icon to access the settings menu. From the dropdown, select “Settings.”\nChoose “Add Calendar”: In the settings menu, navigate to the “Add calendar” section.\nSelect “From URL”: Within the “Add calendar” section, choose the “From URL” option.\nEnter ICS Calendar URL: Copy and paste the following URL: https://www.aswinvanwoudenberg.com/posts/mathematicians-birthdays-calendar/mathematicians_birthdays_calendar.ics\nClick “Add Calendar”: After entering the URL, click the “Add Calendar” button. Google Calendar will validate the URL and add the calendar to your account.\nView Your New Calendar: Once added, you should see the new calendar in the left sidebar under “Other calendars.” The birthdays will be displayed on your Google Calendar.\n\n\nClicking on an event will show some details including a link to a Wikipedia page to learn more about the mathematician.\n\nEnjoy all the cake!"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#isaac-newtons-two-birthdays",
    "href": "posts/mathematicians-birthdays-calendar/index.html#isaac-newtons-two-birthdays",
    "title": "Mathematicians’ Birthdays Calendar",
    "section": "Isaac Newton’s two birthdays",
    "text": "Isaac Newton’s two birthdays\nYou may have noticed, after viewing this calendar, that Isaac Newton seemingly has two birthdays, ten days apart. Initially recognized as born on December 25, 1642, his birthday is now more commonly acknowledged as January 4, 1643. This is due to the calendar difference between England and the rest of Europe during his birth. While England stuck to the Julian calendar, lagging ten days behind, the continent had already adopted the Gregorian calendar.\nWhile January 4 is now widely acknowledged as Isaac Newton’s birthday, December 25 continues to be celebrated as Grav-Mass day. This unofficial holiday annually honors Newton’s contributions to the understanding of gravity and mass in physics.\nI left both days in the calendar because it means I get to eat even more cake!"
  },
  {
    "objectID": "posts/mathematicians-birthdays-calendar/index.html#download-the-code",
    "href": "posts/mathematicians-birthdays-calendar/index.html#download-the-code",
    "title": "Mathematicians’ Birthdays Calendar",
    "section": "Download the code",
    "text": "Download the code\nYou can find the code here."
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html",
    "href": "posts/musikalisches-wuerfelspiel/index.html",
    "title": "Musikalisches Würfelspiel",
    "section": "",
    "text": "In generative AI, music composition is one of the areas in which there has been remarkable progress. Models like Magenta’s Music Transformer, MuseNet, AIVA, and Riffusion are able to create musical pieces, further blurring the line between human and machine creativity.\nPerhaps surprisingly, the idea of using algorithms for composing music can be traced back to as early as the second half of the 18th century. During this period, the musical dice game, or “Musikalisches Würfelspiel”, gained popularity in Western Europe. This game allowed anyone, regardless of musical expertise, to compose by rolling dice and consulting charts to pick musical elements and craft original compositions.\nWhile various musical dice games were published during this period, one of the most famous instances is attributed to Wolfgang Amadeus Mozart. It is unclear whether it was Mozart whom actually created this particular version, as it was released by his publisher posthumously. It’s for the sake of convenience that I’ll refer to this version as Mozart’s musical dice game, even though it’s uncertain whether he was the actual creator.\nIn this blog post, we’ll explore Mozart’s musical dice game and I’ll present a Python implementation. Using this implementation, we’ll be able to generate MIDI messages for playback in digital audio workstations or with MIDI instruments."
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#from-rolling-dice-to-a-musical-composition",
    "href": "posts/musikalisches-wuerfelspiel/index.html#from-rolling-dice-to-a-musical-composition",
    "title": "Musikalisches Würfelspiel",
    "section": "From rolling dice to a musical composition",
    "text": "From rolling dice to a musical composition\nTo play Mozart’s musical dice game, we’d need the following:\n\ntwo six-sided dice\na two-part reference chart (Zahlentafel / Table de Chiffres)\n176 music fragments (Table de Musique of which only the first page is shown below)\n\n\n\n\n\n\n\n\n\n\n\nThe numbers in the reference chart (the first image) refer to the music fragments (in the second image). Only the first page containing the first 48 music fragments is shown. You can find the full document containing both the reference chart and all 176 music fragments here.\nThe steps involved in creating a composition are as follows:\nStep 1: Roll a pair of dice 16 times\nFor each roll, note the sum (ranging from 2 to 12) obtained from the two six-sided dice.\nStep 2: Select the corresponding measures from the reference chart and assemble the musical composition.\nUsing the reference chart and the 176 musical fragments, look up the pre-composed music fragment associated with each of your 16 rolls. Each of these fragments becomes a measure in your composition.\nThe first 8 measures will need to be played twice. For this reason you can add the repeat sign 𝄇 to the 8th measure. The music fragments under column H (30, 81, 24, 100, 107, 91, 127, 94, 123, 33, and 5) all contain a second variation that needs to be played the second time. For instance, music fragment 30 looks like this:\n\n\n\n\n\nYou can see that the left hand staff for this fragment contains two variations. Variation 1 is played the first time, variation 2 the second time. A cleaner way to represent this is by using volta brackets.\n\n\n\n\n\nThe last 8 measures aren’t repeated so you can add the final barline symbol 𝄂 to the last measure.\nCongratulations! You are now a composer.\nThrowing dice and looking up fragments repeatedly is boring. However, before automating this with Python, there’s one more thing left to explain."
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#whats-midi",
    "href": "posts/musikalisches-wuerfelspiel/index.html#whats-midi",
    "title": "Musikalisches Würfelspiel",
    "section": "What’s MIDI?",
    "text": "What’s MIDI?\nMIDI stands for “Musical Instrument Digital Interface”. It’s both a file format and a protocol used to communicate with and control various musical instruments, computers, and other electronic devices. MIDI data does not contain actual audio; instead, it consists of instructions that tell devices what sound to produce.\nMIDI messages include information such as note-on and note-off commands, which indicate when a musical note should start and stop playing, as well as data for controlling parameters like pitch, velocity, tempo, and volume.\nWe’ll use MIDI to play back Mozart’s musical dice game compositions on a digital piano and a digital audio workstation (DAW). The mido library is used to work with MIDI data in Python.\nFun fact: The first version of the MIDI specification was published in August, 1983, which means the standard will be 40 years old next month!"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#importing-libraries",
    "href": "posts/musikalisches-wuerfelspiel/index.html#importing-libraries",
    "title": "Musikalisches Würfelspiel",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe’re now ready to implement Mozart’s musical dice game using Python. Let’s start by importing the necessary modules:\n\nfrom matplotlib.colors import ListedColormap\nfrom IPython.display import display\n\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nimport numpy as np\nimport mido\nimport time\n\nNote how we import the aforementioned mido module."
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#reference-chart-and-dice-rolls",
    "href": "posts/musikalisches-wuerfelspiel/index.html#reference-chart-and-dice-rolls",
    "title": "Musikalisches Würfelspiel",
    "section": "Reference chart and dice rolls",
    "text": "Reference chart and dice rolls\nThe two part reference chart is represented by a 11x16 numpy array. The numbers in the array indicate the music fragment to be played for each combination of dice rolls.\n\nnumber_table = np.array([\n    [ 96,  22, 141,  41, 105, 122,  11,  30,  70, 121,  26,   9, 112,  49, 109,  14],\n    [ 32,   6, 128,  63, 146,  46, 134,  81, 117,  39, 126,  56, 174,  18, 116,  83],\n    [ 69,  95, 158,  13, 153,  55, 110,  24,  66, 139,  15, 132,  73,  58, 145,  79],\n    [ 40,  17, 113,  85, 161,   2, 159, 100,  90, 176,   7,  34,  67, 160,  52, 170],\n    [148,  74, 163,  45,  80,  97,  36, 107,  25, 143,  64, 125,  76, 136,   1,  93],\n    [104, 157,  27, 167, 154,  68, 118,  91, 138,  71, 150,  29, 101, 162,  23, 151],\n    [152,  60, 171,  53,  99, 133,  21, 127,  16, 155,  57, 175,  43, 168,  89, 172],\n    [119,  84, 114,  50, 140,  86, 169,  94, 120,  88,  48, 166,  51, 115,  72, 111],\n    [ 98, 142,  42, 156,  75, 129,  62, 123,  65,  77,  19,  82, 137,  38, 149,   8],\n    [  3,  87, 165,  61, 135,  47, 147,  33, 102,   4,  31, 164, 144,  59, 173,  78],\n    [ 54, 130,  10, 103,  28,  37, 106,   5,  35,  20, 108,  92,  12, 124,  44, 131]\n])\n\nLet’s now define a function that displays the reference chart and dice rolls.\n\ndef plot_number_table(number_table, dice_rolls=None):\n    highlight = np.zeros((11, 16))\n    if dice_rolls is not None:\n        row_indices = dice_rolls - 2\n        column_indices = np.arange(16)\n        highlight[row_indices, column_indices] = 1\n\n    plt.figure(\"Musikalisches Würfelspiel\", figsize=(9.6, 7.2))\n    plt.imshow(highlight, cmap=ListedColormap([\"white\", \"lightseagreen\"]))\n    for y in range(number_table.shape[0]):\n        for x in range(number_table.shape[1]):\n            plt.text(x, y, '%d' % number_table[y, x], fontsize=14, \n                horizontalalignment='center', verticalalignment='center')\n\n    plt.xticks(list(range(0,16)), list(range(1, 17)))\n    plt.yticks(list(range(0,11)), list(range(2, 13)))\n    plt.xlabel(\"Measure\")\n    plt.ylabel(\"Dice roll\")\n    plt.show()\n\nThis function takes two parameters: the reference chart and the dice rolls. If the dice rolls are not provided, the reference chart is displayed without highlighting any cells.\nBefore calling this function, let’s simulate rolling two dice 16 times. We do that using the following code:\n\n# Throw two dice 16 times\ndice_rolls = np.sum(np.random.randint(1, 7, size=(2, 16)), axis=0)\n\nYou might be wondering why we don’t simply write:\ndice_rolls = np.random.randint(2, 13, size=(1, 16))\nThe reason is that this would result in values being drawn from a discrete uniform distribution. The sum of a roll of two dice however isn’t uniformly distributed. The probability distribution of the sum of two dice is instead given by:\n\\[p(x) = \\begin{cases}\n  \\frac{x - 1}{36} & \\text{if $x \\in \\{2, 3, 4, 5, 6, 7\\}$}\\\\\n  \\frac{13 - x}{36} & \\text{if $x \\in \\{7, 8, 9, 10, 11, 12\\}$}\\\\\n  0 & \\text{otherwise}\n  \\end{cases}\n\\]\nThis may be called a discrete triangular distribution. It’s perfectly fine to draw from either distribution, but the triangular distribution is more akin to rolling actual dice.\nLet’s now display the reference chart and the dice rolls.\n\nplot_number_table(number_table, dice_rolls)"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#music-fragments",
    "href": "posts/musikalisches-wuerfelspiel/index.html#music-fragments",
    "title": "Musikalisches Würfelspiel",
    "section": "Music fragments",
    "text": "Music fragments\nI used MuseScore to digitize all music fragments into one MIDI file. Each fragment consists of one measure, except fragments 30, 81, 24, 100, 107, 91, 127, 94, 123, 33, and 5. They contain a second variation which has been put into a separate measure immediately following the measure that contain the first variation. This gives us a total of 187 measures. Let’s now read in this MIDI file.\n\nmidi_file = mido.MidiFile('musikalisches_wuerfelspiel.mid')\n\nAs described above, a MIDI file consists of MIDI messages. The following function extracts the MIDI messages between two time stamps. It is used to extract the MIDI messages corresponding to a single measure. There are different kinds of messages, but we are only interested in the note_on and note_off messages.\n\ndef get_fragment(midi_file, time_start, time_end):\n    proc_time = 0.0\n    \n    for msg in midi_file:\n        if not isinstance(msg, mido.MetaMessage) and msg.type != 'control_change':\n            proc_time += msg.time\n            if proc_time &gt;= time_start and proc_time &lt;= time_end:\n                yield msg                \n\nWe use MIDI control change messages to initialize the receiving instrument or DAW. The following function extracts them from our MIDI file.\n\ndef get_control_change_messages(midi_file):\n    for msg in midi_file:\n        if not isinstance(msg, mido.MetaMessage) and msg.type == 'control_change':\n            yield msg\n\nThe following helper function returns the index of the measure that contains a given fragment. Because some fragments are split into two measures (the ones with a variation, the 8th dice roll), the fragments that come after these all shift one up.\n\ndef get_measure_index(number_table, number):\n    eighth_column = number_table[:, 7]  # 7 represents the 8th column\n    count = np.sum(eighth_column &lt; number)\n    return number + count\n\nThe following function first generates the control change messages, and then the MIDI messages for the fragments corresponding to each dice roll.\nIt starts by calculating the duration of one measure and uses this to determine the time stamps for the start and end of each measure. It then extracts the MIDI messages for each fragment and yields them.\n\ndef get_dice_roll_fragments(midi_file, number_table, dice_rolls):\n    measure_duration = sum([msg.time for msg in midi_file if not isinstance(msg, mido.MetaMessage)]) / (number_table.shape[0] * (number_table.shape[1]+1))\n    measures = number_table[dice_rolls - 2, np.arange(16)]\n\n    yield from get_control_change_messages(midi_file)\n    \n    for i in range(2): # repeat measures 1 to 8\n        for j in range(0, 8):\n            index = get_measure_index(number_table, measures[j]) + (i if j == 7 else 0)\n            yield from get_fragment(midi_file, measure_duration * (index-1), measure_duration * index)\n    for j in range(8, 16):\n        index = get_measure_index(number_table, measures[j])\n        yield from get_fragment(midi_file, measure_duration * (index-1), measure_duration * index)\n\nThe next function calculates the time stamps for the start of each MIDI message. It then waits until the current time is equal to or greater than the time stamp for the next MIDI message before yielding it. We use this function to play the MIDI messages at the correct speed to a MIDI output port.\n\ndef play_dice_roll_fragments(midi_file, number_table, dice_rolls):\n    # generate all MIDI messages in advance\n    messages = list(get_dice_roll_fragments(midi_file, number_table, dice_rolls))\n    \n    start_time = time.time()\n    input_time = 0.0\n\n    for msg in messages:\n        input_time += msg.time\n    \n        playback_time = time.time() - start_time\n        duration_to_next_event = input_time - playback_time\n    \n        if duration_to_next_event &gt; 0.0:\n            time.sleep(duration_to_next_event)\n    \n        yield msg"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#building-a-gui",
    "href": "posts/musikalisches-wuerfelspiel/index.html#building-a-gui",
    "title": "Musikalisches Würfelspiel",
    "section": "Building a GUI",
    "text": "Building a GUI\nFinally, we can create a simple GUI that allows us to generate compositions and send the MIDI messages to a DAW or MIDI instrument.\noutput_dropdown = widgets.Dropdown(\n    options=np.unique(mido.get_output_names()),\n    description='MIDI output:',\n    disabled=False,\n)\n\nrandomize_button = widgets.Button(icon='dice', description='Throw dice')\nplay_button = widgets.Button(icon='play', description='Play')\n\noutput = widgets.Output()\n\nhbox = widgets.HBox([randomize_button, play_button])\nvbox = widgets.VBox([output_dropdown, hbox, output])\nOne button is to roll the dice and the other is to play the composition. The output is a plot of the dice rolls. We use a dropdown to select which MIDI output port to use.\n\ndef randomize_button_clicked(b=None):\n    global dice_rolls\n    dice_rolls = np.sum(np.random.randint(1, 7, size=(2, 16)), axis=0)\n    with output:\n        output.clear_output(wait=True)\n        plot_number_table(number_table, dice_rolls)\n\nrandomize_button.on_click(randomize_button_clicked)\n\ndef play_button_clicked(b):    \n    midi_output = mido.open_output(output_dropdown.value)\n    \n    for msg in play_dice_roll_fragments(midi_file, number_table, dice_rolls):\n        midi_output.send(msg)\n    \nplay_button.on_click(play_button_clicked)\n\nFinally we display the GUI.\nrandomize_button_clicked()\n\ndisplay(vbox)"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#sending-midi-messages-to-a-daw",
    "href": "posts/musikalisches-wuerfelspiel/index.html#sending-midi-messages-to-a-daw",
    "title": "Musikalisches Würfelspiel",
    "section": "Sending MIDI messages to a DAW",
    "text": "Sending MIDI messages to a DAW\nNow we can send the MIDI messages to a DAW to play (and optionally record) our masterpieces. I’m using the free DAW LMMS here but any DAW should work.\n\n\n\nIf you record the MIDI messages, make sure you set the tempo to 80 BPM and the time signature to 3/8 so the notes get quantized correctly.\nJust listen to this gem!\n\n\nBeautiful, wouldn’t you agree?!"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#a-piano-performance",
    "href": "posts/musikalisches-wuerfelspiel/index.html#a-piano-performance",
    "title": "Musikalisches Würfelspiel",
    "section": "A piano performance",
    "text": "A piano performance\nLet me perform a composition for you on my piano.\n\nNot only am I a composer, I’m a performer too. Carnegie Hall, here I come! (Don’t mind the MIDI cable running from my laptop to the piano.)"
  },
  {
    "objectID": "posts/musikalisches-wuerfelspiel/index.html#conclusion",
    "href": "posts/musikalisches-wuerfelspiel/index.html#conclusion",
    "title": "Musikalisches Würfelspiel",
    "section": "Conclusion",
    "text": "Conclusion\nWhether or not the pieces created using this method can be called original is a matter of perspective.\nDespite the random assembly, the musical dice game was designed in such a way that the chord progressions and harmonic structure would remain consistent throughout the pieces. This ensures that the musical phrases fit together harmoniously, creating a sense of coherence and musical flow. Furthermore, Mozart (or the actual composer) likely incorporated musical rules and guidelines while creating the precomposed measures. These rules would ensure that the resulting compositions maintain a certain level of musical quality and avoid dissonance or jarring transitions.\nThe resulting compositions may sound pretty good, but after a while they start to become repetitive. Nonetheless, Mozart’s Musikalisches Würfelspiel and similar musical dice games remain a fascinating historical example of how composers experimented with generative techniques long before the advent of computers and sophisticated software.\nIf you want to create your own pieces, you can find the code in the following GitHub repository:\n\nHappy “composing”!"
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html",
    "href": "posts/thinking-inside-the-matchbox/index.html",
    "title": "Thinking Inside the Matchbox",
    "section": "",
    "text": "Reinforcement Learning (RL) has emerged as a powerful paradigm, enabling machines to learn and make decisions through trial and error. Recent successes in RL, such as agents that play Atari games, hold conversations, control nuclear fusion plasma and discover new algorithms, have demonstrated its potential for solving complex problems. However, the roots of RL can be traced back to an earlier era, where Donald Michie and his creation MENACE, helped pave the way for machines that could learn.\nThis blog post explores the design and functioning of MENACE, showcasing it as one of the earliest examples of RL. I’ll also provide a Python implementation of MENACE so you can experiment with it yourself."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#menaces-genesis",
    "href": "posts/thinking-inside-the-matchbox/index.html#menaces-genesis",
    "title": "Thinking Inside the Matchbox",
    "section": "MENACE’s genesis",
    "text": "MENACE’s genesis\nDuring World War II, even before attending college, Donald Michie worked as a code breaker at Bletchley Park where he collaborated with Alan Turing. During their free time, the two men would play chess and theorize how game playing machines could be built.\nAfter the war, both Turing and Michie, in collaboration with others, came up with algorithms that could play chess. In 1948, Alan Turing and David Champernowne developed Turochamp. Somewhat earlier, Donald Michie, together with Shaun Wylie, had thought up a chess program called Machiavelli. These programs were primarily conceptual and required manual execution of instructions. Turochamp and Machiavelli relied on various heuristics to determine the most advantageous moves, with these heuristics being hard-coded without any learning capability.\nIn 1960, Michie wanted to show how a program could actually improve itself by playing many games and learn from its wins and losses. Chess was too complicated because of its many possible game states, so he shifted from chess to the much simpler game of tic-tac-toe (or noughts and crosses as they call it in the UK). Because Michie didn’t have access to a digital computer, he implemented his learning algorithm using matchboxes and colored beads. He called his machine Matchbox Educable Noughts and Crosses Engine, or MENACE."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#how-menace-plays-and-learns",
    "href": "posts/thinking-inside-the-matchbox/index.html#how-menace-plays-and-learns",
    "title": "Thinking Inside the Matchbox",
    "section": "How MENACE plays and learns",
    "text": "How MENACE plays and learns\n\nHow it’s setup\nEach matchbox in MENACE corresponds to a specific configuration of X’s, O’s, and empty squares on the tic-tac-toe game grid. Duplicate arrangements, such as rotations or mirror images of other configurations, are left out. Configurations representing concluded games or positions with only one empty square are also omitted. Furthermore, MENACE always goes first and only its own turns need to be represented. All this results in exactly 304 distinct configurations that MENACE can encounter, so only this many matchboxes are used.\n\n\n\nDonald Michie’s original MENACE\n\n\nInside each matchbox, there is a collection of colored beads. Each color represents a move that can be made on a specific square of the game grid.\n\n\n\n\n\nIn the original MENACE, these were the colors of beads used to indicate positions on the game grid\n\n\n\n\nMatchboxes with arrangements where positions on the grid are already taken don’t contain beads for those occupied positions. Bead colors that represent duplicate moves, resulting from rotating or mirroring the configuration, are also left out.\nA matchbox can contain multiple beads of the same color. Initially, the matchbox representing the first move, which corresponds to the empty grid, contains four beads for each color representing a possible move. In this initial move, MENACE has three options: moving in the center, a corner, or a side, resulting in a total of 12 beads. As for its second move, there are at most seven possibilities, and each vacant square has three of the same colored beads associated with it. In the case of MENACE’s third move, there are two beads for each of the at most five possibilities. Similarly, for its fourth move, there is one bead for each of the at most three possibilities.\n\n\nHow it plays\nWhen it’s MENACE’s turn to make a move, one must locate the matchbox that corresponds to the current grid configuration and randomly select a bead from within that matchbox. The chosen bead’s color indicates the square where MENACE makes its move. After each move, the selected matchbox and bead are put aside for later processing. This procedure is repeated for each of MENACE’s turns until a victor emerges or the game ends in a draw.\n\n\nHow it learns\nUpon completing a game, MENACE will need to be either ‘punished’ or ‘rewarded’ for its choices based on the outcome. When MENACE loses, the beads representing its moves are simply removed. In the case of a draw, an additional bead of the corresponding color is added to each relevant matchbox. Conversely, if MENACE wins, three extra beads are added for each move it played.\nThese adjustments in bead quantities directly influence MENACE’s future gameplay. Poor performance reduces the likelihood of MENACE repeating the same gameplay, as the corresponding beads are removed. On the other hand, successful gameplay increases the probability of MENACE following a similar strategy in subsequent games due to the presence of additional beads.\nThrough this reward-based system, MENACE progressively refines its gameplay strategy. By reinforcing successful moves and discouraging less effective ones, MENACE becomes more adept at the game, increasing its chances of achieving victory or at least tie in future rounds.\nUsing modern-day reinforcement learning lingo, we would say that MENACE learns a policy. A policy refers to a mapping from the current environment observation to a probability distribution of the actions to be taken. In case of MENACE, the policy is determined by the number of beads of each color in a matchbox. We would calculate the probability of each action (each move) by taking the fraction of beads of a specific color in a matchbox over the total count of beads in that matchbox."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#a-python-implementation",
    "href": "posts/thinking-inside-the-matchbox/index.html#a-python-implementation",
    "title": "Thinking Inside the Matchbox",
    "section": "A Python implementation",
    "text": "A Python implementation\nIn the remainder of this post, I’ll go over how I coded my own version of MENACE in Python. My implementation stays as close as possible to the original version as described by Donald Michie[1] but has the following additional features:\n\nMy implementation doesn’t just model the game grids of the first player, but of the second player as well. This allows MENACE to play against itself.\nThe number of beads to start out with in each turn is configurable.\nThe number of beads that are used to punish and reward are configurable as well.\nYou can visualize the state of all matchboxes before and after training.\nSome matchboxes may end up with 0 beads. In that case a random move is selected.\n\nI’ll also show how to use my implementation for your own experiments."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#importing-modules",
    "href": "posts/thinking-inside-the-matchbox/index.html#importing-modules",
    "title": "Thinking Inside the Matchbox",
    "section": "Importing modules",
    "text": "Importing modules\nLet’s start by importing the necessary modules.\n\nfrom kaggle_environments import make, evaluate\nfrom math import ceil\nfrom IPython.display import HTML\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nimport random\nimport matplotlib\nmatplotlib.rcParams['animation.embed_limit'] = 2**128\n\nLoading environment lux_ai_s2 failed: No module named 'vec_noise'\n\n\nThe matplotlib library is used to display the state of each matchbox. I import kaggle_environments so we can animate matches. Importing this last module outputs a warning but this can safely be ignored."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#helper-functions",
    "href": "posts/thinking-inside-the-matchbox/index.html#helper-functions",
    "title": "Thinking Inside the Matchbox",
    "section": "Helper functions",
    "text": "Helper functions\nGame grids are represented using a simple string. Each string is 9 characters long and contains only X’s, O’s and .’s for empty squares. Donald Michie used O for the first player. I think most people start with X as does the kaggle_environment I imported. Maybe it’s a British thing as they call it noughts and crosses. It doesn’t matter much. I just decided to use X for the first player. I went with strings because this would allow me to use them as keys in a Python dictionary to look up the state of it’s corresponding matchbox.\nFor each game grid we need to be able to get a list of possible moves. The following function takes a string and returns a list of moves. It makes sure to remove any duplicate moves by rotating and mirroring the game grid and checking for equivalent moves.\n\ndef get_unique_moves(state):\n    moves = list(range(9))\n    unique_moves = [i for i, v in enumerate(state) if v == '.']\n\n    state_array = np.array(list(state)).reshape((3, 3)) # convert state to a 3x3 array\n    moves_array = np.array(moves).reshape((3, 3)) # convert moves to a 3x3 array\n\n    transformed_state_array = np.copy(state_array)\n    transformed_moves_array = np.copy(moves_array)\n\n    for _ in range(4):\n        transformed_state_array = np.rot90(transformed_state_array)\n        transformed_moves_array = np.rot90(transformed_moves_array)\n        transformed_moves = transformed_moves_array.flatten().tolist()\n        if np.array_equal(transformed_state_array, state_array):\n            for a, b in zip(moves, transformed_moves):\n                if a != b and a in unique_moves and b in unique_moves:\n                    unique_moves.remove(b)\n\n        flipped_state_array = np.flipud(transformed_state_array)\n        flipped_moves_array = np.flipud(transformed_moves_array)\n        flipped_moves = flipped_moves_array.flatten().tolist()\n        if np.array_equal(flipped_state_array, state_array):\n            for a, b in zip(moves, flipped_moves):\n                if a != b and a in unique_moves and b in unique_moves:\n                    unique_moves.remove(b)\n\n    return unique_moves\n\nCalling this function with an empty grid returns three moves: the center, a corner and a side.\n\nprint(get_unique_moves('.........'))\n\n[4, 7, 8]\n\n\nI’m just using index values to represent moves. Using color names would only complicate things.\nTurn numbers start from 0.\n\ndef get_turn(state):\n    return 9 - state.count('.')\n\nThe check_winner function returns X if the first player has won, O if the second player has won, or None if the game hasn’t finished yet, or has ended in a draw.\n\ndef check_winner(state):\n    winning_combinations = [\n        [0, 1, 2], [3, 4, 5], [6, 7, 8], # rows\n        [0, 3, 6], [1, 4, 7], [2, 5, 8], # columns\n        [0, 4, 8], [2, 4, 6] # diagonals\n    ]\n\n    for combination in winning_combinations:\n        if state[combination[0]] == state[combination[1]] == state[combination[2]] != '.':\n            return state[combination[0]] # return the winning symbol (X or O)\n\n    return None # no winner\n\nTo check if a game is actually over, we can call game_over.\n\ndef game_over(state):\n    return check_winner(state) or get_turn(state) == 9\n\nThe get_current_player function returns who’s turn it is. If it returns None, then the game has already ended.\n\ndef get_current_player(state):\n    if game_over(state):\n        return None\n    if state.count('X') &gt; state.count('O'):\n        return 'O'\n    return 'X'\n\nTo make a move and get the next game grid we call update_game_state and pass the current game grid and a move.\n\ndef update_game_state(state, move):\n    return state[:move] + get_current_player(state) + state[move+1:]"
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#menace-class",
    "href": "posts/thinking-inside-the-matchbox/index.html#menace-class",
    "title": "Thinking Inside the Matchbox",
    "section": "MENACE class",
    "text": "MENACE class\nThe MENACE class encapsulates the logic and functionality of MENACE, including initializing matchboxes, selecting moves, updating matchboxes based on game outcomes, and providing visualizations of the matchboxes.\n\nclass MENACE:\n    def __init__(self, initial_beads = [4,4,3,3,2,2,1,1,1], win_beads=3, lose_beads=-1, tie_beads=1):\n        self.matchboxes = {} # dictionary to store matchboxes and their beads\n        self.initial_beads = initial_beads\n        self.win_beads = win_beads\n        self.lose_beads = lose_beads\n        self.tie_beads = tie_beads\n        self.initialize_matchboxes()\n    \n    def reset(self):\n        self.matchboxes = {}\n        self.initialize_matchboxes()\n    \n    def initialize_matchboxes(self, state='.........'):\n        if game_over(state) or isinstance(self.get_move(state),int):\n            return\n        \n        moves = get_unique_moves(state)\n        \n        beads = [-1] * 9\n        for move in moves:\n            beads[move] = self.initial_beads[get_turn(state)]\n        self.matchboxes[state] = beads\n        \n        for move in moves:\n            next_state = update_game_state(state, move)\n            self.initialize_matchboxes(next_state)\n    \n    def _get_transformed_move(self, transformed_state_array, transformed_moves_array):\n        transformed_state = ''.join(transformed_state_array.flatten().tolist())\n        transformed_moves = transformed_moves_array.flatten().tolist()\n        if transformed_state in self.matchboxes:\n            beads = [0 if v &lt; 0 else v for v in self.matchboxes[transformed_state]]\n            if sum(beads) == 0:\n                beads = [0 if v &lt; 0 else 1 for v in self.matchboxes[transformed_state]]\n            return random.choices(transformed_moves, beads)[0]\n        return None\n    \n    def get_move(self, state):\n        moves = list(range(9))\n        \n        state_array = np.array(list(state)).reshape((3, 3)) # convert state to a 3x3 array\n        moves_array = np.array(moves).reshape((3, 3)) # convert moves to a 3x3 array\n        \n        transformed_state_array = np.copy(state_array)\n        transformed_moves_array = np.copy(moves_array)\n        \n        if isinstance(ret := self._get_transformed_move(transformed_state_array, transformed_moves_array), int):\n            return ret\n        \n        for _ in range(4):\n            transformed_state_array = np.rot90(transformed_state_array)\n            transformed_moves_array = np.rot90(transformed_moves_array)\n            if isinstance(ret := self._get_transformed_move(transformed_state_array, transformed_moves_array), int):\n                return ret\n            \n            flipped_state_array = np.flipud(transformed_state_array)\n            flipped_moves_array = np.flipud(transformed_moves_array)\n            if isinstance(ret := self._get_transformed_move(flipped_state_array, flipped_moves_array), int):\n                return ret\n        \n        return None\n    \n    def _update_transformed_move(self, transformed_state_array, transformed_moves_array, move, winner):\n        transformed_state = ''.join(transformed_state_array.flatten().tolist())\n        transformed_moves = transformed_moves_array.flatten().tolist()\n        if transformed_state in self.matchboxes:\n            beads = self.matchboxes[transformed_state]\n            if beads[transformed_moves.index(move)] &gt; -1:\n                # update beads\n                if get_current_player(transformed_state) == winner:\n                    beads[transformed_moves.index(move)] += self.win_beads\n                elif winner is None:\n                    beads[transformed_moves.index(move)] += self.tie_beads\n                else:\n                    beads[transformed_moves.index(move)] += self.lose_beads\n                if beads[transformed_moves.index(move)] &lt; 0:\n                    beads[transformed_moves.index(move)] = 0\n                return True\n        return False\n    \n    def update_matchbox(self, state, move, winner):\n        moves = list(range(9))\n        \n        state_array = np.array(list(state)).reshape((3, 3)) # convert state to a 3x3 array\n        moves_array = np.array(moves).reshape((3, 3)) # convert moves to a 3x3 array\n        \n        transformed_state_array = np.copy(state_array)\n        transformed_moves_array = np.copy(moves_array)\n        \n        if self._update_transformed_move(transformed_state_array, transformed_moves_array, move, winner):\n            return\n        \n        for _ in range(4):\n            transformed_state_array = np.rot90(transformed_state_array)\n            transformed_moves_array = np.rot90(transformed_moves_array)\n            if self._update_transformed_move(transformed_state_array, transformed_moves_array, move, winner):\n                return\n            \n            flipped_state_array = np.flipud(transformed_state_array)\n            flipped_moves_array = np.flipud(transformed_moves_array)\n            if self._update_transformed_move(flipped_state_array, flipped_moves_array, move, winner):\n                return\n    \n    def plot_matchbox(self, state, ax):\n        beads = np.array(self.matchboxes[state]).reshape((3,3))\n        board = np.array(list(state)).reshape((3, 3))\n\n        ax.imshow(beads, cmap='Oranges', vmin=0)\n        ax.set_xticks([-0.5,0.5,1.5,2.5], labels='')\n        ax.set_yticks([-0.5,0.5,1.5,2.5], labels='')\n        ax.xaxis.set_ticks_position('none')\n        ax.yaxis.set_ticks_position('none')\n        ax.grid(True, color='black', linewidth=1)\n\n        for i in range(3):\n            for j in range(3):\n                if board[i, j] == 'X':\n                    ax.plot([j-0.4,j+0.4],[i-0.4,i+0.4], color='black')\n                    ax.plot([j+0.4,j-0.4],[i-0.4,i+0.4], color='black')\n                elif board[i, j] == 'O':\n                    ax.add_artist(plt.Circle((j, i), 0.4, fill=False, color='black'))\n                elif beads[i, j] &gt; -1:\n                    ax.text(j, i, str(beads[i, j]), ha='center', va='center', color='white')\n\n    def plot_matchboxes(self, player='X'):\n        if player=='X':\n            cols = 16\n            states = sorted([k for k in self.matchboxes.keys() if get_turn(k) % 2 == 0 and get_turn(k) &lt; 7], key=lambda v: get_turn(v))\n            rows = ceil(len(states) / cols)\n            fig, axs = plt.subplots(rows, cols, figsize=(cols,rows), gridspec_kw = {'wspace':0.1, 'hspace':0.1})\n        else:\n            cols = 17\n            states = sorted([k for k in self.matchboxes.keys() if get_turn(k) % 2 != 0], key=lambda v: get_turn(v))\n            rows = ceil(len(states) / cols)\n            fig, axs = plt.subplots(rows, cols, figsize=(cols,rows), gridspec_kw = {'wspace':0.1, 'hspace':0.1})\n        \n        fig.subplots_adjust(top=0.96)\n        fig.suptitle(f\"The {len(states)} matchboxes that make up player {player}\", fontsize=16)\n        for r in range(rows):\n            for c in range(cols):\n                self.plot_matchbox(states[r*cols+c], axs[r, c])\n\nThe class has an initialization method that takes in parameters such as the initial number of beads for each matchbox per turn, and the change in beads for a win, a loss, and a draw. It also sets up the matchboxes dictionary that is used to store the state for each matchbox as a list.\nIt calls the initialize_matchboxes method recursively creates and initializes matchboxes for all possible (but unique) grid configurations. It considers valid moves and assigns the corresponding number of beads based on the initial configuration parameters.\nIt might be interesting to experiment with the number of beads to add and remove after each win, loss, or draw. For now, we’ll just go with the defaults that were also used in the original MENACE and instantiate the class.\n\nmenace = MENACE()\n\nAfter all matchboxes are initialized we can visualize their state.\n\nmenace.plot_matchboxes('X')\nplt.show()\n\n\n\n\nNote how each game grid shows the number of beads corresponding to each move. Each game grid is actually a little heatmap where a darker orange means the move corresponding to that square is more likely to be selected. For now all grids have the same intensity. This will change once we start training MENACE.\nAs mentioned above, this Python implementation also includes all the matchboxes for the second player. You can visualize those by replacing the X by an O in the call to plot_matchboxes."
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#training-menace",
    "href": "posts/thinking-inside-the-matchbox/index.html#training-menace",
    "title": "Thinking Inside the Matchbox",
    "section": "Training MENACE",
    "text": "Training MENACE\nWe can train MENACE against itself or other agents. It makes sense to implement an agent as a function that takes in a game grid and returns a move.\nWe can easily define an agent that makes random moves.\n\n# makes a random move\ndef random_agent(state):\n    return random.choice([i for i, v in enumerate(state) if v == '.'])\n\nOr we define an agent that moves in the first available empty square.\n\n# move in the first available position\ndef first_agent(state):\n    return [i for i, v in enumerate(state) if v == '.'][0]\n\nWe can use the following function that returns an agent that uses the menace object we instantiated above.\n\n# returns an agent that get's a move from MENACE\ndef get_menace_agent(m):\n    def menace_agent(state):\n        return m.get_move(state)    \n    return menace_agent\n\nThe following function takes in a MENACE object, and two agents and lets them play a game against each other. The function keeps track of which moves were made and after the game ends it calls the update_matchbox method in the MENACE object to update the number of beads.\n\ndef play_game(menace, agent1, agent2):\n    state = \".........\" # initial game state\n    moves = [] # list to store moves\n    players = [agent1, agent2]\n    \n    for i in range(9):\n        move = players[i%2](state) # get move\n        moves.append((state, move)) # record the move\n\n        # update game state and check for a winner or draw\n        state = update_game_state(state, move)\n        if game_over(state):\n            break\n\n    winner = check_winner(state)\n    \n    # update matchboxes based on the game outcome\n    for state, move in moves:\n        menace.update_matchbox(state, move, winner)\n    \n    return winner\n\nNote how this function calls update_matchbox for moves made by either agent. This gives us a lot of flexibility. For instance, we could invoke play_game with a MENACE instance and two random agents. The two random agents would play against each other and MENACE would be able to learn from their moves.\n\nTraining MENACE against a random player\nFor now, let’s have MENACE go first (agent1) and have it play against a random player (agent2). We let it play for 10000 rounds.\n\n# Train MENACE\nnum_games = 10000 # number of games to play for training\ngame_results = []\n\nagent1 = get_menace_agent(menace)\nagent2 = random_agent\n\nfor i in range(num_games):\n    winner = play_game(menace, agent1, agent2)\n    game_results.append((i, winner))\n\nThe outcome of each game is appended to the game_results list that we can use later to visualize how well it’s learning.\nLet’s look at the state of each matchbox after these 10000 rounds.\n\nmenace.plot_matchboxes('X')\nplt.show()\n\n\n\n\nThe following function creates an animation that shows the cumulative count for each outcome after each round.\n\ndef wins_and_ties_animation(game_results):\n    frames = 1000 if len(game_results) &gt; 1000 else len(game_results)\n    step_size = 1 if len(game_results) &lt;= 1000 else int(len(game_results) / 1000)\n    \n    fig, ax = plt.subplots()\n\n    max_y = max(\n        sum(1 for _, winner in game_results if winner == 'X'),\n        sum(1 for _, winner in game_results if winner == 'O'),\n        sum(1 for _, winner in game_results if winner is None)\n    )\n\n    def update(frame):\n        data = game_results[:(frame+1)*step_size]\n        cumulative_wins_X = sum(1 for _, winner in data if winner == 'X')\n        cumulative_wins_O = sum(1 for _, winner in data if winner == 'O')\n        cumulative_ties = sum(1 for _, winner in data if winner is None)\n        ax.clear()\n        ax.set_ylim(0, max_y)\n        ax.bar(['X', 'O', 'Ties'], [cumulative_wins_X, cumulative_wins_O, cumulative_ties])\n        ax.set_ylabel('Cumulative Wins')\n        ax.set_title('Cumulative Wins and Ties')\n\n    plt.close()\n\n    anim = animation.FuncAnimation(fig, update, frames=frames, interval=10)\n    \n    return anim\n\nLet’s see what it looks like for 10000 games of MENACE going first against a random player.\n\nanim = wins_and_ties_animation(game_results)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nAlmost instantly the number of wins for X shoots up. The animation mostly illustrates the advantage of going first. The first player has an extra move and more opportunities to achieve a winning combination of three in a row.\n\n\nTraining MENACE against itself\nLet’s see what happens if we let MENACE play against itself.\n\n# Train MENACE against MENACE\nmenace.reset()\n\nnum_games = 10000 # number of games to play for training\ngame_results = []\n\nagent1 = get_menace_agent(menace)\nagent2 = get_menace_agent(menace)\n\nfor i in range(num_games):\n    winner = play_game(menace, agent1, agent2)\n    game_results.append((i, winner))\n\nWe reset the state of all matchboxes and play another 10000 games.\n\nanim = wins_and_ties_animation(game_results)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nThis time, initially, the first player wins more often, but after a few hundred rounds the majority of games end in a draw.\nLet’s inspect what the matchboxes for the second player looks like.\n\nmenace.plot_matchboxes('O')\nplt.show()\n\n\n\n\n\n\nFurther training MENACE against itself\nWe can let MENACE train for a while longer so it hopefully improves even more.\n\nnum_games = 50000 # number of additional games to play for training\n\nfor _ in range(num_games):\n    play_game(menace, agent1, agent2)"
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#animating-a-game",
    "href": "posts/thinking-inside-the-matchbox/index.html#animating-a-game",
    "title": "Thinking Inside the Matchbox",
    "section": "Animating a game",
    "text": "Animating a game\nThe kaggle_environments module that we imported earlier allows us to let two agents play against each other and animate the game. We start by initializing the tic-tac-toe environment.\n\n# setup a Tic-Tac-Toe environment.\nenv = make(\"tictactoe\")\n\nThis environment calls agents with a custom observation object that represents the game grid. Because MENACE expects a game grid to be represented as a string we need to convert this.\n\ndef menace_agent(obs):\n    state = ''.join([['.','X','O'][v] for v in obs.board])\n    return menace.get_move(state)\n\nLet’s have MENACE play against a random agent.\n\n# run the MENACE agent against a default agent which chooses a \"random\" move.\nenv.run([menace_agent, \"random\"])\n\n# render an html ipython replay of the tictactoe game.\nenv.render(mode=\"ipython\")"
  },
  {
    "objectID": "posts/thinking-inside-the-matchbox/index.html#some-final-thoughts",
    "href": "posts/thinking-inside-the-matchbox/index.html#some-final-thoughts",
    "title": "Thinking Inside the Matchbox",
    "section": "Some final thoughts",
    "text": "Some final thoughts\nThe agent that MENACE trains against will influence how well it learns to master tic-tac-toe. If it plays against an agent that always makes random moves, it will take a while longer before it learns how to block the opponent from reaching three in a row. These configurations are simply less likely to occur. It will encounter more diverse grid configurations though, which should help it pick up how to take advantage of weaker opponents. On the other hand, training against an agent that plays tic-tac-toe perfectly will make MENACE learn how to force a draw more quickly. However, it won’t learn how to take advantage of configurations that might arise when dealing with a weaker player. A strategy one could try is to make it first play against a perfect player, and then train it some more against a random player.\nBesides experimenting with the opponent, you could also try experimenting with the number of beads that are used for punishing and rewarding a certain outcome. How should a tie be rewarded if at all? And a win?\nAnother issue to consider is how MENACE deals with the credit assignment problem. The credit assignment problem in reinforcement learning refers to the challenge of assigning credit to the actions that led to a particular outcome. In MENACE, every punishment and reward are uniformly applied to all moves. While it is reasonable to assign reinforcement to the last move since it directly contributed to the outcome, the same may not hold true for earlier moves. MENACE deals at least partly with this problem by starting out with four beads in its first turn, three beads in its second, and so on. This way, removing a bead after a loss has a bigger impact on later turns than it has on earlier ones. It might be worthwhile to experiment with different numbers of starting beads.\nIf you want to experiment with some of these ideas, check out one of the following links:\n  \nHappy reinforcing!"
  },
  {
    "objectID": "index.html#work-with-me",
    "href": "index.html#work-with-me",
    "title": "Aswin van Woudenberg",
    "section": "💼 Work with Me",
    "text": "💼 Work with Me\nI am open to consulting and advisory work.\nPlease contact me at reachme@aswinvanwoudenberg.com or connect with me on LinkedIn for potential projects that align with my expertise."
  },
  {
    "objectID": "index.html#recent-posts",
    "href": "index.html#recent-posts",
    "title": "Aswin van Woudenberg",
    "section": "📮 Recent Posts",
    "text": "📮 Recent Posts\n\n\n\n\n\n\nMathematicians’ Birthdays Calendar\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\n\n\nWeb scraping Wikipedia to create a mathematicians’ birthdays calendar.\n\n\n\n\n\n\nDec 25, 2023\n\n\n17 min\n\n\n\n\n\n\n\n\nWord Search Clock\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nmatplotlib\n\n\nalgorithms\n\n\n\n\nHow I created a clock using an old digital photo frame and some Python code.\n\n\n\n\n\n\nNov 26, 2023\n\n\n19 min\n\n\n\n\n\n\n\n\nSoma Cube\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nmatplotlib\n\n\npuzzles\n\n\n\n\nSolving Piet Hein’s Soma cube with Python.\n\n\n\n\n\n\nOct 20, 2023\n\n\n24 min\n\n\n\n\n\n\n\n\nFrom Procrastination to Productivity\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\npandas\n\n\nmatplotlib\n\n\n\n\nHow I analyzed my browser history using Python.\n\n\n\n\n\n\nSep 2, 2023\n\n\n15 min\n\n\n\n\n\n\n\n\nMusikalisches Würfelspiel\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nmusic\n\n\nart\n\n\ngames\n\n\n\n\nA Python implementation of Mozart’s musical dice game to automatically generate compositions and play them over MIDI.\n\n\n\n\n\n\nJul 26, 2023\n\n\n14 min\n\n\n\n\n\n\n\n\nSolving Word Ladders with Prolog\n\n\n\n\n\n\n\nprogramming\n\n\npuzzles\n\n\nprolog\n\n\nalgorithms\n\n\n\n\nHow to solve word ladders using the A* algorithm and Prolog.\n\n\n\n\n\n\nJun 3, 2023\n\n\n11 min\n\n\n\n\n\n\n\n\nThinking Inside the Matchbox\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nmachine learning\n\n\nreinforcement learning\n\n\nmatplotlib\n\n\ngames\n\n\n\n\nAn implementation of Donald Michie’s MENACE in Python.\n\n\n\n\n\n\nMay 27, 2023\n\n\n28 min\n\n\n\n\n\n\n\n\nCall Me Maybe?\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\n\n\nA Python decorator to log function calls and a custom logging handler for creating call graphs.\n\n\n\n\n\n\nMay 16, 2023\n\n\n14 min\n\n\n\n\n\n\n\n\nBLOCBIRDS\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nsklearn\n\n\nart\n\n\n\n\nHow Mondrian would have produced his art had he been into birds and machine learning.\n\n\n\n\n\n\nJan 13, 2023\n\n\n6 min\n\n\n\n\n\n\n\n\nDancing Queen(s)\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nmatplotlib\n\n\npuzzles\n\n\n\n\nSolving the classic n-queens problem with Python and visualizing solutions using Matplotlib.\n\n\n\n\n\n\nSep 26, 2022\n\n\n10 min\n\n\n\n\n\n\n\n\nMaking Sense of Sorting\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nmatplotlib\n\n\nalgorithms\n\n\n\n\nEasy algorithm visualization in Python.\n\n\n\n\n\n\nSep 18, 2022\n\n\n9 min\n\n\n\n\n\n\n\n\nFrom Baby Face to Neanderthal\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nmediapipe\n\n\nopencv\n\n\n\n\nHow to turn a series of selfies into a time-lapse video using MediaPipe.\n\n\n\n\n\n\nJul 28, 2022\n\n\n9 min\n\n\n\n\n\n\n\n\nDraining the Fun Out of Wordle\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nsklearn\n\n\npuzzles\n\n\ndecision trees\n\n\n\n\nHow to generate a decision tree for solving Wordle games and save our civilization.\n\n\n\n\n\n\nFeb 21, 2022\n\n\n18 min\n\n\n\n\n\n\n\n\nTraversing a Decision Tree to Win at Guess Who?\n\n\n\n\n\n\n\nmachine learning\n\n\ndecision trees\n\n\ngames\n\n\npython\n\n\nsklearn\n\n\nprogramming\n\n\n\n\nHow to construct and traverse a decision tree and use it for playing Guess Who?\n\n\n\n\n\n\nJan 4, 2022\n\n\n17 min\n\n\n\n\n\n\n\n\nA Custom Sudoku Widget\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\npuzzles\n\n\n\n\nCreating a custom Jupyter widget for editing and displaying Sudoku puzzles.\n\n\n\n\n\n\nFeb 26, 2021\n\n\n37 min\n\n\n\n\n\n\n\n\nPictionary Air Mouse\n\n\n\n\n\n\n\nprogramming\n\n\npython\n\n\nopencv\n\n\n\n\nUse the Pictionary Air pen as an alternative input device.\n\n\n\n\n\n\nDec 13, 2020\n\n\n5 min\n\n\n\n\n\n\n\n\nIcosian Game\n\n\n\n\n\n\n\nprogramming\n\n\nprolog\n\n\npuzzles\n\n\n\n\nA Prolog solver for the Icosian game.\n\n\n\n\n\n\nApr 24, 2020\n\n\n5 min\n\n\n\n\n\n\n\n\nSupercharging the Nabaztag\n\n\n\n\n\n\n\nprogramming\n\n\nprolog\n\n\niot\n\n\n\n\nA Nabaztag server that interfaces with ifttt.com.\n\n\n\n\n\n\nJul 15, 2019\n\n\n5 min\n\n\n\n\n\n\n\n\nSkyline Puzzle\n\n\n\n\n\n\n\nprogramming\n\n\nprolog\n\n\npuzzles\n\n\n\n\nA Prolog solver for the ‘Skyline’ puzzle.\n\n\n\n\n\n\nOct 4, 2015\n\n\n3 min\n\n\n\n\n\n\n\n\nVBA IBAN Validator\n\n\n\n\n\n\n\nprogramming\n\n\nvba\n\n\n\n\nA function in VBA that checks the validity of an IBAN (International Bank Account Number).\n\n\n\n\n\n\nJul 18, 2013\n\n\n4 min\n\n\n\n\n\n\n\n\nBridge and Torch Puzzle\n\n\n\n\n\n\n\nprogramming\n\n\nprolog\n\n\npuzzles\n\n\n\n\nA Prolog solver for the ‘Bridge and torch’ puzzle.\n\n\n\n\n\n\nJul 3, 2009\n\n\n5 min\n\n\n\n\n\n\n\n\nWho Owns the Zebra\n\n\n\n\n\n\n\nprogramming\n\n\nprolog\n\n\npuzzles\n\n\n\n\nA Prolog solver for the ‘Zebra puzzle’ a.k.a. ‘Einstein’s puzzle’.\n\n\n\n\n\n\nOct 26, 2007\n\n\n6 min\n\n\n\n\n\n\n\n\nA Brainf*ck Interpreter in Prolog\n\n\n\n\n\n\n\nprogramming\n\n\nesoteric\n\n\nprolog\n\n\n\n\nAn esoteric programming language interpreter written in a slightly less esoteric programming language.\n\n\n\n\n\n\nJan 5, 2007\n\n\n4 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html",
    "href": "posts/bridge-and-torch-puzzle/index.html",
    "title": "Bridge and Torch Puzzle",
    "section": "",
    "text": "The Bridge and torch puzzle goes like this:\nIn this blog post I give a solution and some code for finding all solutions in Prolog."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html#solving-the-puzzle",
    "href": "posts/bridge-and-torch-puzzle/index.html#solving-the-puzzle",
    "title": "Bridge and Torch Puzzle",
    "section": "Solving the puzzle",
    "text": "Solving the puzzle\nOne might guess that an obvious solution would be to let the fastest person (A) shuttle each other person over the bridge and return alone with the torch. This would give the following schedule:\n\n\n\nA, B\n\\(\\rightarrow\\)\n2 minutes\n\n\nA\n\\(\\leftarrow\\)\n1 minutes\n\n\nA, C\n\\(\\rightarrow\\)\n5 minutes\n\n\nA\n\\(\\leftarrow\\)\n1 minutes\n\n\nA, D\n\\(\\rightarrow\\)\n10 minutes\n\n\n\nThe total duration of this schedule would be 19 minutes, so the torch would run out of battery while person A and D are still on the bridge.\nThe optimal solution consists of letting the two slowest people (C and D) cross the bridge together, giving the following schedule:\n\n\n\nA, B\n\\(\\rightarrow\\)\n2 minutes\n\n\nB\n\\(\\leftarrow\\)\n2 minutes\n\n\nC, D\n\\(\\rightarrow\\)\n10 minutes\n\n\nA\n\\(\\leftarrow\\)\n1 minutes\n\n\nA, B\n\\(\\rightarrow\\)\n2 minutes\n\n\n\nWhich gives a total crossing time of exactly 17 minutes."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html#prolog-to-the-rescue",
    "href": "posts/bridge-and-torch-puzzle/index.html#prolog-to-the-rescue",
    "title": "Bridge and Torch Puzzle",
    "section": "Prolog to the rescue",
    "text": "Prolog to the rescue\nProlog is quite suitable for solving these kinds of search problems.\n\n\nbridge.pl\n\n% A Prolog solver for the bridge and torch puzzle\n% https://en.wikipedia.org/wiki/Bridge_and_torch_problem\n\nprint_all_solutions :-\n    findall(_,print_solution,_).\n\nprint_solution :-\n    init(State),\n    solve(State,Solution,EndState),\n    writeln('Start state:'),\n    writeln(State),\n    writeln('Solution:'),\n    writeln(Solution),\n    writeln('Final state:'),\n    writeln(EndState), nl.\n\nsolve(State,[],State) :- goal(State).\nsolve(State,[Move|Tail],EndState) :- s(State,Move,NewState), solve(NewState,Tail,EndState).\n\ngoal(state([],right,[_,_,_,_],T)) :- T =&lt; 17.\n\ninit(state([a,b,c,d],left,[],0)).\n\ns(state(L1,left,L2,T),cross(L3),state(L4,right,L6,T2)) :-       \n    select_one_or_two(L1,L3,L4),\n    ord_union(L2,L3,L6),\n    min_time_needed(L3,Tn),\n    T2 is T + Tn, \n    T2 =&lt; 17.\ns(state(L1,right,L2,T),cross(L3),state(L4,left,L5,T2)) :-       \n    select_one_or_two(L2,L3,L5),\n    ord_union(L1,L3,L4),\n    min_time_needed(L3,Tn),\n    T2 is T + Tn, \n    T2 =&lt; 17.\n\nselect_one_or_two(L,[Sel],L2) :- select(Sel,L,L2).\nselect_one_or_two(L,[Sel1,Sel2],L2) :- select(Sel1,L,NewL), select(Sel2,NewL,L2), Sel1@&lt;Sel2.\n\nmin_time_needed([A],T) :- time_needed(A,T).\nmin_time_needed([A,B],T) :- time_needed(A,T1), time_needed(B,T2), max_list([T1,T2],T).\n\ntime_needed(a,1).\ntime_needed(b,2).\ntime_needed(c,5).\ntime_needed(d,10).\n\nThe init predicate defines the initial state of the puzzle, which includes the positions of the four people and the torch, and the time taken so far. The goal predicate defines the goal state, which is when all four people are on the other side of the bridge in at most 17 minutes.\nThe program finds a sequence of moves that will get all four people across the bridge in the shortest time. The solve predicate recursively searches for a sequence of moves that will lead to the goal state. The s predicate defines the possible moves that can be made from a given state. The select_one_or_two predicate selects one or two people from the group to cross the bridge. The min_time_needed predicate calculates the time needed for the selected people to cross the bridge.\nI chose to represent a state by keeping track of two lists, one for each side of the bridge. An alternative representation might be to use one list with the times it takes each person and a positive/negative sign that indicates on which side of the brige the person is. This list could look like this: [1,2,-5,-10] and would indicate that the persons with times 1 and 2 are on one side of the bridge and the others would be on the other side. We could add another number, say 1 (or -1), to indicate on which side the flashlight is. Finding a suitable representation is often half the battle and multiple alternatives might work equally well.\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html#running-the-solver",
    "href": "posts/bridge-and-torch-puzzle/index.html#running-the-solver",
    "title": "Bridge and Torch Puzzle",
    "section": "Running the solver",
    "text": "Running the solver\nTo run the solver, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the solver by typing:\n[bridge].\nThis loads the bridge.pl file. You can execute the solver which will output all solutions to the console:\nprint_all_solutions.\nStart state:\nstate([a,b,c,d],left,[],0)\nSolution:\n[cross([a,b]),cross([a]),cross([c,d]),cross([b]),cross([a,b])]\nFinal state:\nstate([],right,[a,b,c,d],17)\n\nStart state:\nstate([a,b,c,d],left,[],0)\nSolution:\n[cross([a,b]),cross([b]),cross([c,d]),cross([a]),cross([a,b])]\nFinal state:\nstate([],right,[a,b,c,d],17)"
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html",
    "href": "posts/solving-word-ladders-with-prolog/index.html",
    "title": "Solving Word Ladders with Prolog",
    "section": "",
    "text": "A few weeks ago, a friend saw that I had created a Wordle solver and he thought I might enjoy another word puzzle called Weaver. However, he couldn’t have been more wrong! I actually hate puzzles, especially the ones involving words.\nWhen I can’t solve them quickly enough, frustration sets in. It’s followed by self-doubt, anger towards myself, and eventually, resentment towards the creators of these puzzles, the universe, and life itself. For me, the only way to escape this mental turmoil is to create a solver and be done with them once and for all.\nRead on to discover how I once again managed to avoid spiraling into an existential crisis."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#so-what-is-weaver",
    "href": "posts/solving-word-ladders-with-prolog/index.html#so-what-is-weaver",
    "title": "Solving Word Ladders with Prolog",
    "section": "So what is Weaver?",
    "text": "So what is Weaver?\nWeaver is an online game where players are presented with word ladder puzzles. In these puzzles, players must transform a starting word into a target word by changing one letter at a time, while forming valid English words in each step.\n\n\n\n\n\n\n\n\n\n\nThe objective is to make the chain as short as possible. If you complete a puzzle you’ll get feedback on how close you were on getting a shortest solution. Weaver uses a dictionary to check if the words you enter are valid English words. The example above shows the puzzle on the left, and a (shortest) solution on the right.\nWord ladders are nothing new. Their origin can be traced back to Lewis Carroll, who introduced them in the 19th century. He called them Doublets.\nWeaver uses four-letter words only, so that’s what I’ll do as well."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#getting-the-word-list",
    "href": "posts/solving-word-ladders-with-prolog/index.html#getting-the-word-list",
    "title": "Solving Word Ladders with Prolog",
    "section": "Getting the word list",
    "text": "Getting the word list\nI started by getting the word list from Weaver’s JavaScript source code. It currently consists of 4029 four-letter words. I put this word list in my Prolog source code as follows:\nwords([aahs, aals, abas, abba, abbe, abed, abet, able, ably|...]).\nIn Weaver’s source code I also found a five-letter word list, but it doesn’t seem to be used. If you want to include five-letter words as well, you can just extend the list. Of course you can’t weave from a four to a five-letter word or vice versa."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#specifying-a-graph-structure",
    "href": "posts/solving-word-ladders-with-prolog/index.html#specifying-a-graph-structure",
    "title": "Solving Word Ladders with Prolog",
    "section": "Specifying a graph structure",
    "text": "Specifying a graph structure\nTo solve word ladders, we can start by representing the word list as a graph where each node represents a word, and there is an edge between two nodes if and only if the corresponding words differ by exactly one letter. A small subset of this graph would look like this:\n\n\n\n\n\n   \n\nPORT\n\n PORT   \n\nSORT\n\n SORT   \n\nPORT–SORT\n\n   \n\nMORT\n\n MORT   \n\nPORT–MORT\n\n   \n\nBORT\n\n BORT   \n\nPORT–BORT\n\n   \n\nFORT\n\n FORT   \n\nPORT–FORT\n\n   \n\nSORT–MORT\n\n   \n\nSORT–BORT\n\n   \n\nSORT–FORT\n\n   \n\nSORD\n\n SORD   \n\nSORT–SORD\n\n   \n\nMORT–BORT\n\n   \n\nBORT–FORT\n\n   \n\nCORD\n\n CORD   \n\nSORD–CORD\n\n   \n\nFORD\n\n FORD   \n\nSORD–FORD\n\n   \n\nLORD\n\n LORD   \n\nSORD–LORD\n\n   \n\nCORD–FORD\n\n   \n\nCORD–LORD\n\n   \n\nFORD–FORT\n\n   \n\nFORD–LORD\n\n   \n\nFOLD\n\n FOLD   \n\nFORD–FOLD\n\n   \n\nFARD\n\n FARD   \n\nFORD–FARD\n\n   \n\nFOND\n\n FOND   \n\nFORD–FOND\n\n   \n\nFOLD–FOND\n\n   \n\nBOND\n\n BOND   \n\nFOND–BOND\n\n   \n\nFIND\n\n FIND   \n\nFOND–FIND\n\n   \n\nFEND\n\n FEND   \n\nFOND–FEND\n\n   \n\nBIND\n\n BIND   \n\nBOND–BIND\n\n   \n\nFIND–BIND\n\n   \n\nKIND\n\n KIND   \n\nFIND–KIND\n\n   \n\nFINE\n\n FINE   \n\nFIND–FINE\n\n   \n\nHIND\n\n HIND   \n\nFIND–HIND\n\n   \n\nFEND–FIND\n\n   \n\nBIND–KIND\n\n   \n\nBIND–HIND\n\n   \n\nKIND–HIND\n\n   \n\nKINE\n\n KINE   \n\nKIND–KINE\n\n   \n\nKINA\n\n KINA   \n\nKIND–KINA\n\n   \n\nFINE–KINE\n\n   \n\nKINE–KINA\n\n  \n\n\n\n\n\nSolving a word ladder would be the equivalent of finding the shortest path between two nodes in a graph.\n\n\n\n\n\n   \n\nPORT\n\n PORT   \n\nSORT\n\n SORT   \n\nPORT–SORT\n\n   \n\nMORT\n\n MORT   \n\nPORT–MORT\n\n   \n\nBORT\n\n BORT   \n\nPORT–BORT\n\n   \n\nFORT\n\n FORT   \n\nPORT–FORT\n\n   \n\nSORT–MORT\n\n   \n\nSORT–BORT\n\n   \n\nSORT–FORT\n\n   \n\nSORD\n\n SORD   \n\nSORT–SORD\n\n   \n\nMORT–BORT\n\n   \n\nBORT–FORT\n\n   \n\nCORD\n\n CORD   \n\nSORD–CORD\n\n   \n\nFORD\n\n FORD   \n\nSORD–FORD\n\n   \n\nLORD\n\n LORD   \n\nSORD–LORD\n\n   \n\nCORD–FORD\n\n   \n\nCORD–LORD\n\n   \n\nFORD–FORT\n\n   \n\nFORD–LORD\n\n   \n\nFOLD\n\n FOLD   \n\nFORD–FOLD\n\n   \n\nFARD\n\n FARD   \n\nFORD–FARD\n\n   \n\nFOND\n\n FOND   \n\nFORD–FOND\n\n   \n\nFOLD–FOND\n\n   \n\nBOND\n\n BOND   \n\nFOND–BOND\n\n   \n\nFIND\n\n FIND   \n\nFOND–FIND\n\n   \n\nFEND\n\n FEND   \n\nFOND–FEND\n\n   \n\nBIND\n\n BIND   \n\nBOND–BIND\n\n   \n\nFIND–BIND\n\n   \n\nKIND\n\n KIND   \n\nFIND–KIND\n\n   \n\nFINE\n\n FINE   \n\nFIND–FINE\n\n   \n\nHIND\n\n HIND   \n\nFIND–HIND\n\n   \n\nFEND–FIND\n\n   \n\nBIND–KIND\n\n   \n\nBIND–HIND\n\n   \n\nKIND–HIND\n\n   \n\nKINE\n\n KINE   \n\nKIND–KINE\n\n   \n\nKINA\n\n KINA   \n\nKIND–KINA\n\n   \n\nFINE–KINE\n\n   \n\nKINE–KINA\n\n  \n\n\n\n\n\nHere we marked the shortest path between the words sort and kind, which is the answer to the puzzle we saw above.\nI defined the following predicates that specify the connectivity of the graph.\n% Helper predicates\ncount_different_elements([], [], 0).\ncount_different_elements([X|Xs], [Y|Ys], N) :-\n    X \\= Y,\n    count_different_elements(Xs, Ys, M),\n    N is M + 1.\ncount_different_elements([X|Xs], [X|Ys], N) :-\n    count_different_elements(Xs, Ys, N).\n\ncount_different_characters(A, B, N) :-\n    atom_chars(A, L1),\n    atom_chars(B, L2),\n    count_different_elements(L1, L2, N).\n\n% The successor predicate\ns(N, M, 1) :-\n    words(Words),\n    member(M,Words),\n    count_different_characters(N, M, 1).\nThe predicates count_different_elements/3 and count_different_characters/3 are helper predicates that handle the counting of different characters between two words. They are used to determine the cost or distance between two words in terms of the number of character differences.\nThe s/3 predicate defines a successor relation between words. It establishes that a successor word M is connected to an initial word N if they have exactly one different character. We assume all transitions have a cost of 1.\nOne question that might arise is whether the full graph that contains all words is a connected graph. In other words, if there is always a path between two arbitrary nodes.\nLet’s find out how many (if any) words are not connected to any other word by entering the following query:\nwords(W), bagof(M,(member(M,W), not(s(M,_,_))),Bag), length(Bag,L).\nW = [aahs, aals, abas, abba, abbe, abed, abet, able, ably|...],\nBag = [abri, adze, ahoy, amok, ankh, aqua, arak, asci, auld|...],\nL = 62.\nWe find that for 62 words there was no successor found. This alone tells us that the graph is disconnected which means that for some pairs of words you can’t make a word ladder. There are also smaller groups of word clusters that form their own little subgraph. For instance the words ordo, orzo, and ouzo form their own little graph disconnected from any other words.\n\n\n\n\n\n   \n\nORDO\n\n ORDO   \n\nORZO\n\n ORZO   \n\nORDO–ORZO\n\n   \n\nOUZO\n\n OUZO   \n\nORZO–OUZO\n\n  \n\n\n\n\n\nSuch a cute little graph. Imagine the psychological torment you’d cause by asking the biggest Weaver afficionado to create a word ladder going from beer to ouzo. Just kidding, don’t be evil."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#the-a-search-algorithm",
    "href": "posts/solving-word-ladders-with-prolog/index.html#the-a-search-algorithm",
    "title": "Solving Word Ladders with Prolog",
    "section": "The A* search algorithm",
    "text": "The A* search algorithm\nThe A* algorithm is a popular pathfinding algorithm used for finding the shortest path between a start node and a goal node in a weighted graph. It uses a combination of the actual cost (path cost from the start node) and the heuristic cost (estimated cost from the current node to the goal) to guide the search towards the goal while exploring the graph efficiently.\nBecause this algorithm works on weighted graphs only, we set the weight of all edges equal to 1. You can find many implementations of A* for a variety of programming languages online. I adapted one from here for use in the solver.\n% A* with cycle checking\na_star(Start, Answer) :-\n    h(Start, H), !,\n    a_star([[(0, H), Start]], [], Answer, 0).\n\na_star([ [_, FinalState | Path ] | _], _, Answer, _) :-\n    goal(FinalState), !,\n    reverse([FinalState | Path], Answer).\na_star([ [(Gval,_),  FinalState | Path ]| OtherPaths], OldStates, Answer, NumExpanded) :-\n    cycle_check(FinalState, Gval, OldStates),\n    bagof((C, N), s(FinalState, N, C), Neighbours),\n    expand(Gval, FinalState , Path, Neighbours,  NewPaths),\n    prune(NewPaths,PrunedPaths, OldStates), \n    combine(PrunedPaths, OtherPaths, NewFrontier),\n    N is NumExpanded + 1, !,\n    (N =&lt; 9999 -&gt; a_star(NewFrontier, [(FinalState, Gval)|OldStates], Answer,N) ; !, fail).\na_star([ _ | OtherPaths], OldStates, Answer,NumExpanded) :-\n    !, a_star(OtherPaths, OldStates, Answer,NumExpanded).\n\nexpand(_, _, _, [], []).\nexpand(Gval, State, Path,\n    [(Cost,NewState) | RestNeigh], [[(NGval, NHval), NewState, State | Path] | RestNewPaths]) :-\n    NGval is Gval + Cost,\n    h(NewState, NHval),\n    expand(Gval, State, Path, RestNeigh, RestNewPaths).\n\ncycle_check(_, _, []).\ncycle_check(State, Gval, [(State, OldGval) | Rest]) :-\n    Gval &lt; OldGval, !,\n    cycle_check(State, Gval, Rest).\ncycle_check(State, Gval, [(OldState, _) | Rest]) :-\n    State \\== OldState, !,\n    cycle_check(State, Gval, Rest).\n\nprune([ NewPath | RestNPaths], PrunedPaths, OldStates) :-\n    NewPath = [(Gval, _), FinalState | _],\n    cycle_check(FinalState, Gval, OldStates), !,\n    prune(RestNPaths, RestPruned, OldStates),\n    PrunedPaths = [NewPath | RestPruned].\nprune([ _ | RestNPaths], PrunedPaths, OldStates) :-\n    prune(RestNPaths, PrunedPaths, OldStates).\nprune([], [], _).\n\ncombine([NewState|RestNewStates], OldStates, NewFrontier) :-\n    insert(NewState, OldStates, New),\n    combine(RestNewStates, New, NewFrontier).\ncombine([], AllAdded, AllAdded) :- !.\n\ninsert_list([NewState|RestNewStates], OldStates, NewFrontier) :-\n    insert(NewState, OldStates, New),\n    insert_list(RestNewStates, New, NewFrontier).\ninsert_list([], AllAdded, AllAdded) :- !.\n\ninsert(NewState, [OldState|RestOld], \n    [NewState, OldState|RestOld]) :-\n    lower_or_equal_f_value(NewState, OldState), !.\ninsert(NewState, [OldState|RestOld], \n    [OldState|InsertedIntoRest]) :-\n    greater_f_value(NewState, OldState),\n    insert(NewState, RestOld, InsertedIntoRest), !.\ninsert(NewState, [], [NewState]).\n\nlower_or_equal_f_value([(G1,H1) | _], [(G2, H2) | _]) :-\n    X is G1 + H1, Y is G2 + H2, X =&lt; Y, !.\n\ngreater_f_value([(G1,H1) | _], [(G2, H2) | _]) :-\n    X is G1 + H1, Y is G2 + H2, X &gt; Y, !.\nIt assumes a successor predicate s/3 that we’ve defined above. Furthermore, it expects a predicate h/2 that defines a heuristic to guide the search and a goal/1 predicate that gets satisfied once the search has reached the final node.\nThe heuristic I used is the number of letters that are different from the target word. The closer we are to the final node, the more letters are expected to be correct.\n% The heuristic\nh(N, H) :-\n    goal(M),\n    count_different_characters(N, M, H).\nThe A* search algorithm is guarenteed to find the shortest path if the heuristic we choose is admissible. A heuristic is said to be admissible if it never overestimates the cost of reaching the goal. In our case we know it never overestimates the cost, because if n letters are different from the target word, we need at least n more steps.\nThe goal/1 predicate is dynamically added to the Prolog database before we commence our search. The weaver/3 predicate is the top-level predicate that you call when you want to solve a puzzle.\n:- dynamic goal/1.\n\nweaver(Start, Goal, Solution) :-\n    retractall(goal(_)),\n    assert(goal(Goal)),\n    a_star(Start, Solution).\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/solving-word-ladders-with-prolog/index.html#running-the-solver",
    "href": "posts/solving-word-ladders-with-prolog/index.html#running-the-solver",
    "title": "Solving Word Ladders with Prolog",
    "section": "Running the solver",
    "text": "Running the solver\nTo run the solver, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the solver by typing:\n[weaver].\nThis loads the weaver.pl file. To solve a word ladder going from sort to kind, you’d enter:\nweaver(sort, kind, Solution).\nSolution = [sort, sord, ford, fond, find, kind].\nThere you have it! No more emotional distress over not being able to solve word ladders."
  },
  {
    "objectID": "posts/call-me-maybe/index.html",
    "href": "posts/call-me-maybe/index.html",
    "title": "Call Me Maybe?",
    "section": "",
    "text": "Understanding program structure and concepts like recursion can be challenging, especially for students just starting their coding journey.\nTo facilitate the understanding of program execution, I created a Python decorator that can log function calls, including the function name, input parameters, and return values.\nIn addition to a decorator for logging function calls, I also wrote a custom logging handler. This logging handler generates call graphs, providing a visualization of the function call hierarchy.\nFinally, to further enhance comprehension of program flow, I’ll show how to animate these call graphs. By animating the call graphs, we can visualize the order in which functions are called.\nLet’s dive in!"
  },
  {
    "objectID": "posts/call-me-maybe/index.html#importing-libraries",
    "href": "posts/call-me-maybe/index.html#importing-libraries",
    "title": "Call Me Maybe?",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing the necessary modules.\n\nimport logging\nimport graphviz\nimport re\nimport ipywidgets as widgets\n\nfrom logging import StreamHandler\nfrom functools import wraps, partial\n\nThe standard way of doing logging in Python is by using the logging module, which is part of the Python standard library. This module is quite flexible and allows us to control the log levels, log formatting, log destinations, and more.\nThe decorator uses the wraps and partial functions from the functools module. The graphviz module is used to create the call graphs."
  },
  {
    "objectID": "posts/call-me-maybe/index.html#the-logging-decorator",
    "href": "posts/call-me-maybe/index.html#the-logging-decorator",
    "title": "Call Me Maybe?",
    "section": "The logging decorator",
    "text": "The logging decorator\nIn Python, decorators provide a powerful way of enhancing the behavior of functions or classes without having to make direct modifications to their source code. Decorators are indicated by the @ symbol followed by the name of the decorator function, and they are commonly placed immediately before the target function or class declaration.\nA decorator is essentially a higher-order function that takes a function or class as input and returns a modified version of that function or class.\nThe function decorator I created is named fun_logger. Besides the calls and exits of a function, is also logs any exceptions that might occur. In addition, it logs the arguments and return value. It also keeps track of the indentation level for log messages which is incremented and decremented based on the nesting depth of function calls within the decorated functions.\n\ndef fun_logger(func=None, *, logging=logging, indent='  ', exit=False):\n    if func is None:\n        return partial(fun_logger,logging=logging, indent=indent, exit=exit)\n    \n    global indent_level\n    indent_level = 0\n    \n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        global indent_level\n        \n        args_repr = [repr(a) for a in args]\n        kwargs_repr = [f\"{k}={v!r}\" for k, v in kwargs.items()]\n        signature = \", \".join(args_repr + kwargs_repr)\n        logging.debug(f\"function {func.__qualname__} called with args {signature}\", extra={\n            'func': func.__qualname__, \n            'args_': args, \n            'kwargs': kwargs, \n            'indent': indent_level * indent,\n            'indent_level': indent_level\n        })\n        try:\n            indent_level += 1\n            result = func(*args, **kwargs)\n        except Exception as e:\n            logging.exception(f\"function {func.__qualname__} raised exception {str(e)}\", extra={\n                'func': func.__qualname__, \n                'exception': e,\n                'indent': indent_level * indent,\n                'indent_level': indent_level\n            })\n            if indent_level &gt; 0:\n                indent_level -= 1\n            raise e\n        if indent_level &gt; 0:\n            indent_level -= 1\n        if exit:\n            logging.debug(f\"function {func.__qualname__} exited with result {result}\", extra={\n                'func': func.__qualname__,\n                'result': result,\n                'indent': indent_level * indent,\n                'indent_level': indent_level\n            })        \n        return result\n    return wrapper\n\nThe decorator can be used with or without arguments.\nLike most function decorators it returns a wrapper function that calls the original function while adding additional functionality. In this case the wrapper function does the following:\n\nThe function’s arguments and keyword arguments are converted into string representations.\nA debug log message is logged, including the function’s name and arguments.\nThe wrapped function is executed within a try-except block.\n\nIf an exception occurs, an exception log message is logged. After this, the exception is re-raised to maintain the original behavior.\nIf no exception occurs, a debug log message may be logged to indicate the function’s exit and result. Finally, the result of the wrapped function is returned."
  },
  {
    "objectID": "posts/call-me-maybe/index.html#the-logging-handler",
    "href": "posts/call-me-maybe/index.html#the-logging-handler",
    "title": "Call Me Maybe?",
    "section": "The logging handler",
    "text": "The logging handler\nA logging handler in the Python logging framework processes log records generated by the application and sends them to the desired output destination. It captures, filters, formats, and routes log records, enabling control over where and how logs are stored or displayed.\nThe fun_logger decorator introduced above generates log records for every decorated function call. We can print those log records. What we want however, is to turn these log records into a call graph. For this we can create a custom logging handler that processes the log records and produces the graph.\n\nclass CallGraphHandler(StreamHandler):\n    \"\"\"\n    A handler class which allows the drawing of call graphs\n    \"\"\"    \n    def __init__(self, name=None, comment=None):\n        StreamHandler.__init__(self)\n        self.name = name\n        self.comment = comment\n        \n        self.gv = graphviz.Digraph(name, comment)\n        self.clear()\n    \n    @property\n    def source(self):\n        return self.gv.source\n    \n    def clear(self):\n        self.gv.clear()        \n        self.nodes = []\n        self.edges = []\n        self.stack = []\n        \n        # insert empty node\n        self.gv.node('start', label='', shape='none')\n    \n    def emit(self, record):\n        if hasattr(record, 'indent_level'):\n            current = None\n            while len(self.stack) &gt; record.indent_level:\n                current = self.stack.pop()\n        if hasattr(record, 'args_'): # A function was called\n            args_repr = [repr(a) for a in record.args_]\n            kwargs_repr = [f\"{k}={v!r}\" for k, v in record.kwargs.items()]\n            signature = \", \".join(args_repr + kwargs_repr)\n            node_id = str(len(self.nodes))\n            self.gv.node(node_id, f\"{record.func}({signature})\", fontcolor='black', color='black')\n            self.nodes.append(node_id)\n            self.stack.append(node_id)\n            if len(self.stack) == 1:\n                self.gv.edge('start', node_id, fontcolor='black', color='black:black')\n            else:\n                self.gv.edge(self.stack[-2], node_id, fontcolor='black', color='black')\n        if hasattr(record, 'result'): # A function returned\n            if len(self.stack) == 0:\n                self.gv.edge(current, 'start', fontcolor='blue', pencolor='blue', labelfontcolor='blue', color='blue', label=str(record.result))\n            else:\n                self.gv.edge(current, self.stack[-1], fontcolor='blue', pencolor='blue', labelfontcolor='blue', color='blue', label=str(record.result))\n        if hasattr(record, 'exception'): # An exception occurred\n            if not current:\n                current = record.exception.__class__.__name__\n                self.gv.node(current, shape='diamond', fontcolor='red', pencolor='red', labelfontcolor='red', color='red')\n                self.gv.edge(self.stack[-1], current, fontcolor='red', pencolor='red', labelfontcolor='red', color='red')\n\nThis custom logging handler class does the following:\n\nThe CallGraphHandler class inherits from StreamHandler, which is a built-in logging handler that sends log records to a specified output stream (e.g., stdout). Instead of sending log records to an output stream, we will build a Graphviz DOT string that can be displayed or saved to file.\nThe __init__ method initializes the CallGraphHandler object. It takes optional arguments for a name and comment for the resulting Graphviz plot and sets them as attributes. It also initializes an ampty graphviz.Digraph object.\nIt has an emit() method that is called when a log record is emitted to the handler. It processes the log record and updates the call graph accordingly. Depending on the contents of the log records it will add nodes and/or arrows to the call graph indicating a call, a function return, or an exception.\nThe clear() method clears the call graph."
  },
  {
    "objectID": "posts/call-me-maybe/index.html#using-the-decorator-and-logging-handler",
    "href": "posts/call-me-maybe/index.html#using-the-decorator-and-logging-handler",
    "title": "Call Me Maybe?",
    "section": "Using the decorator and logging handler",
    "text": "Using the decorator and logging handler\nWe firstly create a new object based on the Logger class that we’ll write our log messages to.\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\nThe log level is set to DEBUG.\nWe’ll write logging records to both a StreamHandler and a CallGraphHandler. We’ll initialize the StreamHandler first. This will output the log records to stdout.\n\nstream_handler = logging.StreamHandler()\nformatter = logging.Formatter('%(indent)s%(message)s')\nstream_handler.setFormatter(formatter)\n\nlogger.addHandler(stream_handler)\n\nWe define a custom log format so that an indentation (%(indent)) is added to show the call depth. If we don’t do this all log messages will be left-aligned. The stream_handler is added to the logger object.\nNext we initialize a CallGraphHandler object and add it to logger object as well.\n\ncall_graph_handler = CallGraphHandler(\"Call graph\", \"An example call trace of a recursive function\")\nlogger.addHandler(call_graph_handler)\n\n\nTower of Hanoi\nThe Tower of Hanoi problem has an elegant recursive solution that breaks down the problem into subproblems and using recursion to solve them. Let’s see what its logging output looks like.\n\n@fun_logger(logging=logger)\ndef hanoi(n, source, destination, helper):\n    if n==1:\n        print(\"Move disk 1 from peg\", source, \"to peg\", destination)\n        return\n    hanoi(n-1, source, helper, destination)\n    print(\"Move disk\", n, \"from peg\", source, \"to peg\", destination)\n    hanoi(n-1, helper, destination, source)\n\nNote how we have added the decorator and given it our logger object.\nNow we’re ready to call the function. In this case we tell it to produce a solution for four disks.\n\nn = 4 # number of disks\nhanoi(n, 'A', 'B', 'C')\n\nfunction hanoi called with args 4, 'A', 'B', 'C'\n\n\n  function hanoi called with args 3, 'A', 'C', 'B'\n\n\n    function hanoi called with args 2, 'A', 'B', 'C'\n\n\n      function hanoi called with args 1, 'A', 'C', 'B'\n\n\n      function hanoi called with args 1, 'C', 'B', 'A'\n\n\n    function hanoi called with args 2, 'B', 'C', 'A'\n\n\n      function hanoi called with args 1, 'B', 'A', 'C'\n\n\n      function hanoi called with args 1, 'A', 'C', 'B'\n\n\n  function hanoi called with args 3, 'C', 'B', 'A'\n\n\n    function hanoi called with args 2, 'C', 'A', 'B'\n\n\n      function hanoi called with args 1, 'C', 'B', 'A'\n\n\n      function hanoi called with args 1, 'B', 'A', 'C'\n\n\n    function hanoi called with args 2, 'A', 'B', 'C'\n\n\n      function hanoi called with args 1, 'A', 'C', 'B'\n\n\n      function hanoi called with args 1, 'C', 'B', 'A'\n\n\nMove disk 1 from peg A to peg C\nMove disk 2 from peg A to peg B\nMove disk 1 from peg C to peg B\nMove disk 3 from peg A to peg C\nMove disk 1 from peg B to peg A\nMove disk 2 from peg B to peg C\nMove disk 1 from peg A to peg C\nMove disk 4 from peg A to peg B\nMove disk 1 from peg C to peg B\nMove disk 2 from peg C to peg A\nMove disk 1 from peg B to peg A\nMove disk 3 from peg C to peg B\nMove disk 1 from peg A to peg C\nMove disk 2 from peg A to peg B\nMove disk 1 from peg C to peg B\n\n\nBesides the output caused by the print statements in the function itself, the stream_handler object also writes to the stdout.\n\nShowing the call graph\nThe stream_handler writes directly to stdout. To visualize the call graph we need to get the Graphviz DOT string from the call_graph_handler object, create a Graphviz object and display it.\n\ngraph = graphviz.Source(call_graph_handler.source)\ngraph\n\n\n\n\n\n\nClearing the call graph\nOnce we’ve created our Graphviz object we can clear the Graphviz string in the call_graph_handler object.\n\ncall_graph_handler.clear()\n\nIf we skip this step subsequent function calls will be drawn in the same Graphviz image.\n\n\n\nFibonacci sequence\nOur next example will be the famous Fibonacci sequence. The following function will return the nth Fibonacci number.\n\n@fun_logger(logging=logger, exit=True)\ndef fib(n):\n    if n in [0, 1]:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nAgain we add the decorator. Because we’re also interested in the return values of the function we set exit=True. This will cause the decorator to also output logging records when the function exits.\n\nfib(5)\n\nfunction fib called with args 5\n\n\n  function fib called with args 4\n\n\n    function fib called with args 3\n\n\n      function fib called with args 2\n\n\n        function fib called with args 1\n\n\n        function fib exited with result 1\n\n\n        function fib called with args 0\n\n\n        function fib exited with result 0\n\n\n      function fib exited with result 1\n\n\n      function fib called with args 1\n\n\n      function fib exited with result 1\n\n\n    function fib exited with result 2\n\n\n    function fib called with args 2\n\n\n      function fib called with args 1\n\n\n      function fib exited with result 1\n\n\n      function fib called with args 0\n\n\n      function fib exited with result 0\n\n\n    function fib exited with result 1\n\n\n  function fib exited with result 3\n\n\n  function fib called with args 3\n\n\n    function fib called with args 2\n\n\n      function fib called with args 1\n\n\n      function fib exited with result 1\n\n\n      function fib called with args 0\n\n\n      function fib exited with result 0\n\n\n    function fib exited with result 1\n\n\n    function fib called with args 1\n\n\n    function fib exited with result 1\n\n\n  function fib exited with result 2\n\n\nfunction fib exited with result 5\n\n\n5\n\n\nAgain we see the log messages.\n\nShowing the call graph\nLet’s show the call graph.\n\ngraph = graphviz.Source(call_graph_handler.source)\ngraph\n\n\n\n\nBecause we also logged the function exits, the call graph includes blue edges that show the return values.\n\n\nAnimating the call graph\nBy tracing the arrows, first traversing the left subtree and then the right subtree of each node starting with the root node, we can figure out the call sequence. A somewhat hacky way of animating this call order is taking the Graphviz DOT string and update the colors of the nodes and edges. The nodes and edges in the DOT string we get from the call_graph_handler all have the color black, blue, or red (in case of an exception). We can create ‘frames’ by setting a certain number of colors to lightgray starting from the end of this DOT string. How many colors we set to lightgray depends on the ‘frame’ we’re in.\n\ndot = call_graph_handler.source\n\n\nframes = dot.count(\"color=\")\n\nslider = widgets.IntSlider(\n    value=0,\n    min=0,\n    max=frames,\n    step=4,\n    orientation='horizontal',\n    readout=False\n)\noutput = widgets.Output()\n\ndef on_value_change(change):\n    with output:\n        output.clear_output(wait=True)\n        grey_dot = re.sub(\"([ \\]]).*?=roloc\", \"\\\\1yergthgil=roloc\",dot[::-1], frames-slider.value)[::-1] if frames-slider.value &gt; 0 else dot\n        graph = graphviz.Source(grey_dot)\n        display(graph)\n\nslider.observe(on_value_change)\non_value_change(None)\n\nThe [::-1] part reverses the DOT string so the regular expression can substitute from the back to the front of the string. Note how in the regular expression yergthgil=roloc is color=lightgrey spelled backwards. We use a slider to set the frame number. We set the stepsize in the slider to 4 because that’s how many colors are updated in each frame.\nI told you it was hacky.\n\ndisplay(slider, output)\n\n\n\n\n\n\n\n\n\nClearing the call graph\nFor good practice we clear the call graph again.\n\ncall_graph_handler.clear()\n\nIf you actually want multiple calls to appear in the same call graph you can skip this step.\nIt’s important to note that only functions that are decorated will appear in the graph. Say you have a function foo that calls function bar that calls function baz and you only decorate foo. Only calls to foo will be drawn in the call graph. To include bar and baz you’ll have to decorate them as well."
  },
  {
    "objectID": "posts/call-me-maybe/index.html#logging-your-own-functions",
    "href": "posts/call-me-maybe/index.html#logging-your-own-functions",
    "title": "Call Me Maybe?",
    "section": "Logging your own functions",
    "text": "Logging your own functions\nIf you want to try this on your own functions you can grab the source code from here.\nHappy coding!"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html",
    "href": "posts/draining-the-fun-out-of-wordle/index.html",
    "title": "Draining the Fun Out of Wordle",
    "section": "",
    "text": "Wordle’s addictive nature has caused it to spread like wildfire, captivating players around the world who find themselves entangled in the pursuit of streaks. It has become a quest for daily victories, a battle against time to maintain unbroken chains of triumphant solves. The desire to conquer the next puzzle and extend those streaks has become an obsession that consumes countless hours of human capital.\nWe’re witnessing a peculiar phenomenon: a society on the brink of crumbling under the weight of unsolved Wordle puzzles. Productivity is plummeting, deadlines are missed, pets and children are neglected while people fret endlessly over deciphering those elusive five-letter words.\nIn the face of this crisis, I took it upon myself, to save our civilization from its Wordle-induced downfall. The solution was simple: I developed a Wordle solver. Yes, a program designed to expedite the solving process and allow people to return to more important tasks without sacrificing their streaks or sanity.\nI am certain that in a few years from now, I’ll be recognized as the hero of productivity, wielding the power of math and Python to restore balance in the world. Please don’t make my statue too big, I’m quite modest.\nRead on if you want to learn about the inner workings of my Wordle solver."
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#how-to-play-wordle",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#how-to-play-wordle",
    "title": "Draining the Fun Out of Wordle",
    "section": "How to play Wordle",
    "text": "How to play Wordle\nIn case you’re one of the lucky few who hasn’t been caught by the grip of Wordle’s addictive tendrils, let’s go over the rules.\nThe objective is to guess a five-letter mystery word within six attempts. After each guess, you receive feedback in the form of colored boxes. Green boxes indicate correct letters in the right position, while yellow boxes indicate correct letters in the wrong position. Gray boxes mean the word doesn’t contain this letter.\n\nAfter trying SPOON we know the position of S. We also know that the word must contain an A and a N. The secret word doesn’t contain any of the letters E, R, I, O, or P.\nThere are four more tries left. Feeling anxious already?"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#the-approach",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#the-approach",
    "title": "Draining the Fun Out of Wordle",
    "section": "The approach",
    "text": "The approach\nI started by writing Python code to produce a decision tree to tackle Wordle games. Each node within the tree suggests a word to try. The branches represent the possible color patterns that Wordle provides as feedback. By navigating this tree, players can solve the daily Wordle puzzles.\nIn this post I’ll first focus on the code for generating the decision tree. Then I’ll presents a user interface built from widgets that enables interactive traversal of this tree."
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#importing-libraries",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#importing-libraries",
    "title": "Draining the Fun Out of Wordle",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing the necessary libraries. Note how we don’t import any tree models from sklearn as we’ll roll our own.\n\nimport json\n\nimport numpy as np\nimport pandas as pd\nimport ipywidgets as widgets\n\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.feature_selection import mutual_info_classif\nfrom warnings import simplefilter\nfrom collections import deque"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#getting-the-list-of-possible-answers",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#getting-the-list-of-possible-answers",
    "title": "Draining the Fun Out of Wordle",
    "section": "Getting the list of possible answers",
    "text": "Getting the list of possible answers\nThe following list was taken directly from the Wordle JavaScript source code. The source code actually contains two lists. One is the list of possible answers. The second is a list of valid 5-letter words.\nWe’ll only use the first list. This will still allow the decision tree to solve every possible puzzle reasonably efficiently. Tree induction will be much faster this way.\nWe might need to update this list in the future if the New York Times decides to update the possible set of answers. You might also want to update this list if you want to create a decision tree for one of the many Wordle clones.\n\nanswers_list = [\"cigar\",\"rebut\",\"sissy\",\"humph\",\"awake\",\"blush\",\"focal\",\"evade\",\"naval\",\"serve\",\"heath\",\"dwarf\",\"model\",\"karma\",\"stink\",\"grade\",\"quiet\",\"bench\",\"abate\",\"feign\",\"major\",\"death\",\"fresh\",\"crust\",\"stool\",\"colon\",\"abase\",\"marry\",\"react\",\"batty\",\"pride\",\"floss\",\"helix\",\"croak\",\"staff\",\"paper\",\"unfed\",\"whelp\",\"trawl\",\"outdo\",\"adobe\",\"crazy\",\"sower\",\"repay\",\"digit\",\"crate\",\"cluck\",\"spike\",\"mimic\",\"pound\",\"maxim\",\"linen\",\"unmet\",\"flesh\",\"booby\",\"forth\",\"first\",\"stand\",\"belly\",\"ivory\",\"seedy\",\"print\",\"yearn\",\"drain\",\"bribe\",\"stout\",\"panel\",\"crass\",\"flume\",\"offal\",\"agree\",\"error\",\"swirl\",\"argue\",\"bleed\",\"delta\",\"flick\",\"totem\",\"wooer\",\"front\",\"shrub\",\"parry\",\"biome\",\"lapel\",\"start\",\"greet\",\"goner\",\"golem\",\"lusty\",\"loopy\",\"round\",\"audit\",\"lying\",\"gamma\",\"labor\",\"islet\",\"civic\",\"forge\",\"corny\",\"moult\",\"basic\",\"salad\",\"agate\",\"spicy\",\"spray\",\"essay\",\"fjord\",\"spend\",\"kebab\",\"guild\",\"aback\",\"motor\",\"alone\",\"hatch\",\"hyper\",\"thumb\",\"dowry\",\"ought\",\"belch\",\"dutch\",\"pilot\",\"tweed\",\"comet\",\"jaunt\",\"enema\",\"steed\",\"abyss\",\"growl\",\"fling\",\"dozen\",\"boozy\",\"erode\",\"world\",\"gouge\",\"click\",\"briar\",\"great\",\"altar\",\"pulpy\",\"blurt\",\"coast\",\"duchy\",\"groin\",\"fixer\",\"group\",\"rogue\",\"badly\",\"smart\",\"pithy\",\"gaudy\",\"chill\",\"heron\",\"vodka\",\"finer\",\"surer\",\"radio\",\"rouge\",\"perch\",\"retch\",\"wrote\",\"clock\",\"tilde\",\"store\",\"prove\",\"bring\",\"solve\",\"cheat\",\"grime\",\"exult\",\"usher\",\"epoch\",\"triad\",\"break\",\"rhino\",\"viral\",\"conic\",\"masse\",\"sonic\",\"vital\",\"trace\",\"using\",\"peach\",\"champ\",\"baton\",\"brake\",\"pluck\",\"craze\",\"gripe\",\"weary\",\"picky\",\"acute\",\"ferry\",\"aside\",\"tapir\",\"troll\",\"unify\",\"rebus\",\"boost\",\"truss\",\"siege\",\"tiger\",\"banal\",\"slump\",\"crank\",\"gorge\",\"query\",\"drink\",\"favor\",\"abbey\",\"tangy\",\"panic\",\"solar\",\"shire\",\"proxy\",\"point\",\"robot\",\"prick\",\"wince\",\"crimp\",\"knoll\",\"sugar\",\"whack\",\"mount\",\"perky\",\"could\",\"wrung\",\"light\",\"those\",\"moist\",\"shard\",\"pleat\",\"aloft\",\"skill\",\"elder\",\"frame\",\"humor\",\"pause\",\"ulcer\",\"ultra\",\"robin\",\"cynic\",\"aroma\",\"caulk\",\"shake\",\"dodge\",\"swill\",\"tacit\",\"other\",\"thorn\",\"trove\",\"bloke\",\"vivid\",\"spill\",\"chant\",\"choke\",\"rupee\",\"nasty\",\"mourn\",\"ahead\",\"brine\",\"cloth\",\"hoard\",\"sweet\",\"month\",\"lapse\",\"watch\",\"today\",\"focus\",\"smelt\",\"tease\",\"cater\",\"movie\",\"saute\",\"allow\",\"renew\",\"their\",\"slosh\",\"purge\",\"chest\",\"depot\",\"epoxy\",\"nymph\",\"found\",\"shall\",\"harry\",\"stove\",\"lowly\",\"snout\",\"trope\",\"fewer\",\"shawl\",\"natal\",\"comma\",\"foray\",\"scare\",\"stair\",\"black\",\"squad\",\"royal\",\"chunk\",\"mince\",\"shame\",\"cheek\",\"ample\",\"flair\",\"foyer\",\"cargo\",\"oxide\",\"plant\",\"olive\",\"inert\",\"askew\",\"heist\",\"shown\",\"zesty\",\"hasty\",\"trash\",\"fella\",\"larva\",\"forgo\",\"story\",\"hairy\",\"train\",\"homer\",\"badge\",\"midst\",\"canny\",\"fetus\",\"butch\",\"farce\",\"slung\",\"tipsy\",\"metal\",\"yield\",\"delve\",\"being\",\"scour\",\"glass\",\"gamer\",\"scrap\",\"money\",\"hinge\",\"album\",\"vouch\",\"asset\",\"tiara\",\"crept\",\"bayou\",\"atoll\",\"manor\",\"creak\",\"showy\",\"phase\",\"froth\",\"depth\",\"gloom\",\"flood\",\"trait\",\"girth\",\"piety\",\"payer\",\"goose\",\"float\",\"donor\",\"atone\",\"primo\",\"apron\",\"blown\",\"cacao\",\"loser\",\"input\",\"gloat\",\"awful\",\"brink\",\"smite\",\"beady\",\"rusty\",\"retro\",\"droll\",\"gawky\",\"hutch\",\"pinto\",\"gaily\",\"egret\",\"lilac\",\"sever\",\"field\",\"fluff\",\"hydro\",\"flack\",\"agape\",\"voice\",\"stead\",\"stalk\",\"berth\",\"madam\",\"night\",\"bland\",\"liver\",\"wedge\",\"augur\",\"roomy\",\"wacky\",\"flock\",\"angry\",\"bobby\",\"trite\",\"aphid\",\"tryst\",\"midge\",\"power\",\"elope\",\"cinch\",\"motto\",\"stomp\",\"upset\",\"bluff\",\"cramp\",\"quart\",\"coyly\",\"youth\",\"rhyme\",\"buggy\",\"alien\",\"smear\",\"unfit\",\"patty\",\"cling\",\"glean\",\"label\",\"hunky\",\"khaki\",\"poker\",\"gruel\",\"twice\",\"twang\",\"shrug\",\"treat\",\"unlit\",\"waste\",\"merit\",\"woven\",\"octal\",\"needy\",\"clown\",\"widow\",\"irony\",\"ruder\",\"gauze\",\"chief\",\"onset\",\"prize\",\"fungi\",\"charm\",\"gully\",\"inter\",\"whoop\",\"taunt\",\"leery\",\"class\",\"theme\",\"lofty\",\"tibia\",\"booze\",\"alpha\",\"thyme\",\"eclat\",\"doubt\",\"parer\",\"chute\",\"stick\",\"trice\",\"alike\",\"sooth\",\"recap\",\"saint\",\"liege\",\"glory\",\"grate\",\"admit\",\"brisk\",\"soggy\",\"usurp\",\"scald\",\"scorn\",\"leave\",\"twine\",\"sting\",\"bough\",\"marsh\",\"sloth\",\"dandy\",\"vigor\",\"howdy\",\"enjoy\",\"valid\",\"ionic\",\"equal\",\"unset\",\"floor\",\"catch\",\"spade\",\"stein\",\"exist\",\"quirk\",\"denim\",\"grove\",\"spiel\",\"mummy\",\"fault\",\"foggy\",\"flout\",\"carry\",\"sneak\",\"libel\",\"waltz\",\"aptly\",\"piney\",\"inept\",\"aloud\",\"photo\",\"dream\",\"stale\",\"vomit\",\"ombre\",\"fanny\",\"unite\",\"snarl\",\"baker\",\"there\",\"glyph\",\"pooch\",\"hippy\",\"spell\",\"folly\",\"louse\",\"gulch\",\"vault\",\"godly\",\"threw\",\"fleet\",\"grave\",\"inane\",\"shock\",\"crave\",\"spite\",\"valve\",\"skimp\",\"claim\",\"rainy\",\"musty\",\"pique\",\"daddy\",\"quasi\",\"arise\",\"aging\",\"valet\",\"opium\",\"avert\",\"stuck\",\"recut\",\"mulch\",\"genre\",\"plume\",\"rifle\",\"count\",\"incur\",\"total\",\"wrest\",\"mocha\",\"deter\",\"study\",\"lover\",\"safer\",\"rivet\",\"funny\",\"smoke\",\"mound\",\"undue\",\"sedan\",\"pagan\",\"swine\",\"guile\",\"gusty\",\"equip\",\"tough\",\"canoe\",\"chaos\",\"covet\",\"human\",\"udder\",\"lunch\",\"blast\",\"stray\",\"manga\",\"melee\",\"lefty\",\"quick\",\"paste\",\"given\",\"octet\",\"risen\",\"groan\",\"leaky\",\"grind\",\"carve\",\"loose\",\"sadly\",\"spilt\",\"apple\",\"slack\",\"honey\",\"final\",\"sheen\",\"eerie\",\"minty\",\"slick\",\"derby\",\"wharf\",\"spelt\",\"coach\",\"erupt\",\"singe\",\"price\",\"spawn\",\"fairy\",\"jiffy\",\"filmy\",\"stack\",\"chose\",\"sleep\",\"ardor\",\"nanny\",\"niece\",\"woozy\",\"handy\",\"grace\",\"ditto\",\"stank\",\"cream\",\"usual\",\"diode\",\"valor\",\"angle\",\"ninja\",\"muddy\",\"chase\",\"reply\",\"prone\",\"spoil\",\"heart\",\"shade\",\"diner\",\"arson\",\"onion\",\"sleet\",\"dowel\",\"couch\",\"palsy\",\"bowel\",\"smile\",\"evoke\",\"creek\",\"lance\",\"eagle\",\"idiot\",\"siren\",\"built\",\"embed\",\"award\",\"dross\",\"annul\",\"goody\",\"frown\",\"patio\",\"laden\",\"humid\",\"elite\",\"lymph\",\"edify\",\"might\",\"reset\",\"visit\",\"gusto\",\"purse\",\"vapor\",\"crock\",\"write\",\"sunny\",\"loath\",\"chaff\",\"slide\",\"queer\",\"venom\",\"stamp\",\"sorry\",\"still\",\"acorn\",\"aping\",\"pushy\",\"tamer\",\"hater\",\"mania\",\"awoke\",\"brawn\",\"swift\",\"exile\",\"birch\",\"lucky\",\"freer\",\"risky\",\"ghost\",\"plier\",\"lunar\",\"winch\",\"snare\",\"nurse\",\"house\",\"borax\",\"nicer\",\"lurch\",\"exalt\",\"about\",\"savvy\",\"toxin\",\"tunic\",\"pried\",\"inlay\",\"chump\",\"lanky\",\"cress\",\"eater\",\"elude\",\"cycle\",\"kitty\",\"boule\",\"moron\",\"tenet\",\"place\",\"lobby\",\"plush\",\"vigil\",\"index\",\"blink\",\"clung\",\"qualm\",\"croup\",\"clink\",\"juicy\",\"stage\",\"decay\",\"nerve\",\"flier\",\"shaft\",\"crook\",\"clean\",\"china\",\"ridge\",\"vowel\",\"gnome\",\"snuck\",\"icing\",\"spiny\",\"rigor\",\"snail\",\"flown\",\"rabid\",\"prose\",\"thank\",\"poppy\",\"budge\",\"fiber\",\"moldy\",\"dowdy\",\"kneel\",\"track\",\"caddy\",\"quell\",\"dumpy\",\"paler\",\"swore\",\"rebar\",\"scuba\",\"splat\",\"flyer\",\"horny\",\"mason\",\"doing\",\"ozone\",\"amply\",\"molar\",\"ovary\",\"beset\",\"queue\",\"cliff\",\"magic\",\"truce\",\"sport\",\"fritz\",\"edict\",\"twirl\",\"verse\",\"llama\",\"eaten\",\"range\",\"whisk\",\"hovel\",\"rehab\",\"macaw\",\"sigma\",\"spout\",\"verve\",\"sushi\",\"dying\",\"fetid\",\"brain\",\"buddy\",\"thump\",\"scion\",\"candy\",\"chord\",\"basin\",\"march\",\"crowd\",\"arbor\",\"gayly\",\"musky\",\"stain\",\"dally\",\"bless\",\"bravo\",\"stung\",\"title\",\"ruler\",\"kiosk\",\"blond\",\"ennui\",\"layer\",\"fluid\",\"tatty\",\"score\",\"cutie\",\"zebra\",\"barge\",\"matey\",\"bluer\",\"aider\",\"shook\",\"river\",\"privy\",\"betel\",\"frisk\",\"bongo\",\"begun\",\"azure\",\"weave\",\"genie\",\"sound\",\"glove\",\"braid\",\"scope\",\"wryly\",\"rover\",\"assay\",\"ocean\",\"bloom\",\"irate\",\"later\",\"woken\",\"silky\",\"wreck\",\"dwelt\",\"slate\",\"smack\",\"solid\",\"amaze\",\"hazel\",\"wrist\",\"jolly\",\"globe\",\"flint\",\"rouse\",\"civil\",\"vista\",\"relax\",\"cover\",\"alive\",\"beech\",\"jetty\",\"bliss\",\"vocal\",\"often\",\"dolly\",\"eight\",\"joker\",\"since\",\"event\",\"ensue\",\"shunt\",\"diver\",\"poser\",\"worst\",\"sweep\",\"alley\",\"creed\",\"anime\",\"leafy\",\"bosom\",\"dunce\",\"stare\",\"pudgy\",\"waive\",\"choir\",\"stood\",\"spoke\",\"outgo\",\"delay\",\"bilge\",\"ideal\",\"clasp\",\"seize\",\"hotly\",\"laugh\",\"sieve\",\"block\",\"meant\",\"grape\",\"noose\",\"hardy\",\"shied\",\"drawl\",\"daisy\",\"putty\",\"strut\",\"burnt\",\"tulip\",\"crick\",\"idyll\",\"vixen\",\"furor\",\"geeky\",\"cough\",\"naive\",\"shoal\",\"stork\",\"bathe\",\"aunty\",\"check\",\"prime\",\"brass\",\"outer\",\"furry\",\"razor\",\"elect\",\"evict\",\"imply\",\"demur\",\"quota\",\"haven\",\"cavil\",\"swear\",\"crump\",\"dough\",\"gavel\",\"wagon\",\"salon\",\"nudge\",\"harem\",\"pitch\",\"sworn\",\"pupil\",\"excel\",\"stony\",\"cabin\",\"unzip\",\"queen\",\"trout\",\"polyp\",\"earth\",\"storm\",\"until\",\"taper\",\"enter\",\"child\",\"adopt\",\"minor\",\"fatty\",\"husky\",\"brave\",\"filet\",\"slime\",\"glint\",\"tread\",\"steal\",\"regal\",\"guest\",\"every\",\"murky\",\"share\",\"spore\",\"hoist\",\"buxom\",\"inner\",\"otter\",\"dimly\",\"level\",\"sumac\",\"donut\",\"stilt\",\"arena\",\"sheet\",\"scrub\",\"fancy\",\"slimy\",\"pearl\",\"silly\",\"porch\",\"dingo\",\"sepia\",\"amble\",\"shady\",\"bread\",\"friar\",\"reign\",\"dairy\",\"quill\",\"cross\",\"brood\",\"tuber\",\"shear\",\"posit\",\"blank\",\"villa\",\"shank\",\"piggy\",\"freak\",\"which\",\"among\",\"fecal\",\"shell\",\"would\",\"algae\",\"large\",\"rabbi\",\"agony\",\"amuse\",\"bushy\",\"copse\",\"swoon\",\"knife\",\"pouch\",\"ascot\",\"plane\",\"crown\",\"urban\",\"snide\",\"relay\",\"abide\",\"viola\",\"rajah\",\"straw\",\"dilly\",\"crash\",\"amass\",\"third\",\"trick\",\"tutor\",\"woody\",\"blurb\",\"grief\",\"disco\",\"where\",\"sassy\",\"beach\",\"sauna\",\"comic\",\"clued\",\"creep\",\"caste\",\"graze\",\"snuff\",\"frock\",\"gonad\",\"drunk\",\"prong\",\"lurid\",\"steel\",\"halve\",\"buyer\",\"vinyl\",\"utile\",\"smell\",\"adage\",\"worry\",\"tasty\",\"local\",\"trade\",\"finch\",\"ashen\",\"modal\",\"gaunt\",\"clove\",\"enact\",\"adorn\",\"roast\",\"speck\",\"sheik\",\"missy\",\"grunt\",\"snoop\",\"party\",\"touch\",\"mafia\",\"emcee\",\"array\",\"south\",\"vapid\",\"jelly\",\"skulk\",\"angst\",\"tubal\",\"lower\",\"crest\",\"sweat\",\"cyber\",\"adore\",\"tardy\",\"swami\",\"notch\",\"groom\",\"roach\",\"hitch\",\"young\",\"align\",\"ready\",\"frond\",\"strap\",\"puree\",\"realm\",\"venue\",\"swarm\",\"offer\",\"seven\",\"dryer\",\"diary\",\"dryly\",\"drank\",\"acrid\",\"heady\",\"theta\",\"junto\",\"pixie\",\"quoth\",\"bonus\",\"shalt\",\"penne\",\"amend\",\"datum\",\"build\",\"piano\",\"shelf\",\"lodge\",\"suing\",\"rearm\",\"coral\",\"ramen\",\"worth\",\"psalm\",\"infer\",\"overt\",\"mayor\",\"ovoid\",\"glide\",\"usage\",\"poise\",\"randy\",\"chuck\",\"prank\",\"fishy\",\"tooth\",\"ether\",\"drove\",\"idler\",\"swath\",\"stint\",\"while\",\"begat\",\"apply\",\"slang\",\"tarot\",\"radar\",\"credo\",\"aware\",\"canon\",\"shift\",\"timer\",\"bylaw\",\"serum\",\"three\",\"steak\",\"iliac\",\"shirk\",\"blunt\",\"puppy\",\"penal\",\"joist\",\"bunny\",\"shape\",\"beget\",\"wheel\",\"adept\",\"stunt\",\"stole\",\"topaz\",\"chore\",\"fluke\",\"afoot\",\"bloat\",\"bully\",\"dense\",\"caper\",\"sneer\",\"boxer\",\"jumbo\",\"lunge\",\"space\",\"avail\",\"short\",\"slurp\",\"loyal\",\"flirt\",\"pizza\",\"conch\",\"tempo\",\"droop\",\"plate\",\"bible\",\"plunk\",\"afoul\",\"savoy\",\"steep\",\"agile\",\"stake\",\"dwell\",\"knave\",\"beard\",\"arose\",\"motif\",\"smash\",\"broil\",\"glare\",\"shove\",\"baggy\",\"mammy\",\"swamp\",\"along\",\"rugby\",\"wager\",\"quack\",\"squat\",\"snaky\",\"debit\",\"mange\",\"skate\",\"ninth\",\"joust\",\"tramp\",\"spurn\",\"medal\",\"micro\",\"rebel\",\"flank\",\"learn\",\"nadir\",\"maple\",\"comfy\",\"remit\",\"gruff\",\"ester\",\"least\",\"mogul\",\"fetch\",\"cause\",\"oaken\",\"aglow\",\"meaty\",\"gaffe\",\"shyly\",\"racer\",\"prowl\",\"thief\",\"stern\",\"poesy\",\"rocky\",\"tweet\",\"waist\",\"spire\",\"grope\",\"havoc\",\"patsy\",\"truly\",\"forty\",\"deity\",\"uncle\",\"swish\",\"giver\",\"preen\",\"bevel\",\"lemur\",\"draft\",\"slope\",\"annoy\",\"lingo\",\"bleak\",\"ditty\",\"curly\",\"cedar\",\"dirge\",\"grown\",\"horde\",\"drool\",\"shuck\",\"crypt\",\"cumin\",\"stock\",\"gravy\",\"locus\",\"wider\",\"breed\",\"quite\",\"chafe\",\"cache\",\"blimp\",\"deign\",\"fiend\",\"logic\",\"cheap\",\"elide\",\"rigid\",\"false\",\"renal\",\"pence\",\"rowdy\",\"shoot\",\"blaze\",\"envoy\",\"posse\",\"brief\",\"never\",\"abort\",\"mouse\",\"mucky\",\"sulky\",\"fiery\",\"media\",\"trunk\",\"yeast\",\"clear\",\"skunk\",\"scalp\",\"bitty\",\"cider\",\"koala\",\"duvet\",\"segue\",\"creme\",\"super\",\"grill\",\"after\",\"owner\",\"ember\",\"reach\",\"nobly\",\"empty\",\"speed\",\"gipsy\",\"recur\",\"smock\",\"dread\",\"merge\",\"burst\",\"kappa\",\"amity\",\"shaky\",\"hover\",\"carol\",\"snort\",\"synod\",\"faint\",\"haunt\",\"flour\",\"chair\",\"detox\",\"shrew\",\"tense\",\"plied\",\"quark\",\"burly\",\"novel\",\"waxen\",\"stoic\",\"jerky\",\"blitz\",\"beefy\",\"lyric\",\"hussy\",\"towel\",\"quilt\",\"below\",\"bingo\",\"wispy\",\"brash\",\"scone\",\"toast\",\"easel\",\"saucy\",\"value\",\"spice\",\"honor\",\"route\",\"sharp\",\"bawdy\",\"radii\",\"skull\",\"phony\",\"issue\",\"lager\",\"swell\",\"urine\",\"gassy\",\"trial\",\"flora\",\"upper\",\"latch\",\"wight\",\"brick\",\"retry\",\"holly\",\"decal\",\"grass\",\"shack\",\"dogma\",\"mover\",\"defer\",\"sober\",\"optic\",\"crier\",\"vying\",\"nomad\",\"flute\",\"hippo\",\"shark\",\"drier\",\"obese\",\"bugle\",\"tawny\",\"chalk\",\"feast\",\"ruddy\",\"pedal\",\"scarf\",\"cruel\",\"bleat\",\"tidal\",\"slush\",\"semen\",\"windy\",\"dusty\",\"sally\",\"igloo\",\"nerdy\",\"jewel\",\"shone\",\"whale\",\"hymen\",\"abuse\",\"fugue\",\"elbow\",\"crumb\",\"pansy\",\"welsh\",\"syrup\",\"terse\",\"suave\",\"gamut\",\"swung\",\"drake\",\"freed\",\"afire\",\"shirt\",\"grout\",\"oddly\",\"tithe\",\"plaid\",\"dummy\",\"broom\",\"blind\",\"torch\",\"enemy\",\"again\",\"tying\",\"pesky\",\"alter\",\"gazer\",\"noble\",\"ethos\",\"bride\",\"extol\",\"decor\",\"hobby\",\"beast\",\"idiom\",\"utter\",\"these\",\"sixth\",\"alarm\",\"erase\",\"elegy\",\"spunk\",\"piper\",\"scaly\",\"scold\",\"hefty\",\"chick\",\"sooty\",\"canal\",\"whiny\",\"slash\",\"quake\",\"joint\",\"swept\",\"prude\",\"heavy\",\"wield\",\"femme\",\"lasso\",\"maize\",\"shale\",\"screw\",\"spree\",\"smoky\",\"whiff\",\"scent\",\"glade\",\"spent\",\"prism\",\"stoke\",\"riper\",\"orbit\",\"cocoa\",\"guilt\",\"humus\",\"shush\",\"table\",\"smirk\",\"wrong\",\"noisy\",\"alert\",\"shiny\",\"elate\",\"resin\",\"whole\",\"hunch\",\"pixel\",\"polar\",\"hotel\",\"sword\",\"cleat\",\"mango\",\"rumba\",\"puffy\",\"filly\",\"billy\",\"leash\",\"clout\",\"dance\",\"ovate\",\"facet\",\"chili\",\"paint\",\"liner\",\"curio\",\"salty\",\"audio\",\"snake\",\"fable\",\"cloak\",\"navel\",\"spurt\",\"pesto\",\"balmy\",\"flash\",\"unwed\",\"early\",\"churn\",\"weedy\",\"stump\",\"lease\",\"witty\",\"wimpy\",\"spoof\",\"saner\",\"blend\",\"salsa\",\"thick\",\"warty\",\"manic\",\"blare\",\"squib\",\"spoon\",\"probe\",\"crepe\",\"knack\",\"force\",\"debut\",\"order\",\"haste\",\"teeth\",\"agent\",\"widen\",\"icily\",\"slice\",\"ingot\",\"clash\",\"juror\",\"blood\",\"abode\",\"throw\",\"unity\",\"pivot\",\"slept\",\"troop\",\"spare\",\"sewer\",\"parse\",\"morph\",\"cacti\",\"tacky\",\"spool\",\"demon\",\"moody\",\"annex\",\"begin\",\"fuzzy\",\"patch\",\"water\",\"lumpy\",\"admin\",\"omega\",\"limit\",\"tabby\",\"macho\",\"aisle\",\"skiff\",\"basis\",\"plank\",\"verge\",\"botch\",\"crawl\",\"lousy\",\"slain\",\"cubic\",\"raise\",\"wrack\",\"guide\",\"foist\",\"cameo\",\"under\",\"actor\",\"revue\",\"fraud\",\"harpy\",\"scoop\",\"climb\",\"refer\",\"olden\",\"clerk\",\"debar\",\"tally\",\"ethic\",\"cairn\",\"tulle\",\"ghoul\",\"hilly\",\"crude\",\"apart\",\"scale\",\"older\",\"plain\",\"sperm\",\"briny\",\"abbot\",\"rerun\",\"quest\",\"crisp\",\"bound\",\"befit\",\"drawn\",\"suite\",\"itchy\",\"cheer\",\"bagel\",\"guess\",\"broad\",\"axiom\",\"chard\",\"caput\",\"leant\",\"harsh\",\"curse\",\"proud\",\"swing\",\"opine\",\"taste\",\"lupus\",\"gumbo\",\"miner\",\"green\",\"chasm\",\"lipid\",\"topic\",\"armor\",\"brush\",\"crane\",\"mural\",\"abled\",\"habit\",\"bossy\",\"maker\",\"dusky\",\"dizzy\",\"lithe\",\"brook\",\"jazzy\",\"fifty\",\"sense\",\"giant\",\"surly\",\"legal\",\"fatal\",\"flunk\",\"began\",\"prune\",\"small\",\"slant\",\"scoff\",\"torus\",\"ninny\",\"covey\",\"viper\",\"taken\",\"moral\",\"vogue\",\"owing\",\"token\",\"entry\",\"booth\",\"voter\",\"chide\",\"elfin\",\"ebony\",\"neigh\",\"minim\",\"melon\",\"kneed\",\"decoy\",\"voila\",\"ankle\",\"arrow\",\"mushy\",\"tribe\",\"cease\",\"eager\",\"birth\",\"graph\",\"odder\",\"terra\",\"weird\",\"tried\",\"clack\",\"color\",\"rough\",\"weigh\",\"uncut\",\"ladle\",\"strip\",\"craft\",\"minus\",\"dicey\",\"titan\",\"lucid\",\"vicar\",\"dress\",\"ditch\",\"gypsy\",\"pasta\",\"taffy\",\"flame\",\"swoop\",\"aloof\",\"sight\",\"broke\",\"teary\",\"chart\",\"sixty\",\"wordy\",\"sheer\",\"leper\",\"nosey\",\"bulge\",\"savor\",\"clamp\",\"funky\",\"foamy\",\"toxic\",\"brand\",\"plumb\",\"dingy\",\"butte\",\"drill\",\"tripe\",\"bicep\",\"tenor\",\"krill\",\"worse\",\"drama\",\"hyena\",\"think\",\"ratio\",\"cobra\",\"basil\",\"scrum\",\"bused\",\"phone\",\"court\",\"camel\",\"proof\",\"heard\",\"angel\",\"petal\",\"pouty\",\"throb\",\"maybe\",\"fetal\",\"sprig\",\"spine\",\"shout\",\"cadet\",\"macro\",\"dodgy\",\"satyr\",\"rarer\",\"binge\",\"trend\",\"nutty\",\"leapt\",\"amiss\",\"split\",\"myrrh\",\"width\",\"sonar\",\"tower\",\"baron\",\"fever\",\"waver\",\"spark\",\"belie\",\"sloop\",\"expel\",\"smote\",\"baler\",\"above\",\"north\",\"wafer\",\"scant\",\"frill\",\"awash\",\"snack\",\"scowl\",\"frail\",\"drift\",\"limbo\",\"fence\",\"motel\",\"ounce\",\"wreak\",\"revel\",\"talon\",\"prior\",\"knelt\",\"cello\",\"flake\",\"debug\",\"anode\",\"crime\",\"salve\",\"scout\",\"imbue\",\"pinky\",\"stave\",\"vague\",\"chock\",\"fight\",\"video\",\"stone\",\"teach\",\"cleft\",\"frost\",\"prawn\",\"booty\",\"twist\",\"apnea\",\"stiff\",\"plaza\",\"ledge\",\"tweak\",\"board\",\"grant\",\"medic\",\"bacon\",\"cable\",\"brawl\",\"slunk\",\"raspy\",\"forum\",\"drone\",\"women\",\"mucus\",\"boast\",\"toddy\",\"coven\",\"tumor\",\"truer\",\"wrath\",\"stall\",\"steam\",\"axial\",\"purer\",\"daily\",\"trail\",\"niche\",\"mealy\",\"juice\",\"nylon\",\"plump\",\"merry\",\"flail\",\"papal\",\"wheat\",\"berry\",\"cower\",\"erect\",\"brute\",\"leggy\",\"snipe\",\"sinew\",\"skier\",\"penny\",\"jumpy\",\"rally\",\"umbra\",\"scary\",\"modem\",\"gross\",\"avian\",\"greed\",\"satin\",\"tonic\",\"parka\",\"sniff\",\"livid\",\"stark\",\"trump\",\"giddy\",\"reuse\",\"taboo\",\"avoid\",\"quote\",\"devil\",\"liken\",\"gloss\",\"gayer\",\"beret\",\"noise\",\"gland\",\"dealt\",\"sling\",\"rumor\",\"opera\",\"thigh\",\"tonga\",\"flare\",\"wound\",\"white\",\"bulky\",\"etude\",\"horse\",\"circa\",\"paddy\",\"inbox\",\"fizzy\",\"grain\",\"exert\",\"surge\",\"gleam\",\"belle\",\"salvo\",\"crush\",\"fruit\",\"sappy\",\"taker\",\"tract\",\"ovine\",\"spiky\",\"frank\",\"reedy\",\"filth\",\"spasm\",\"heave\",\"mambo\",\"right\",\"clank\",\"trust\",\"lumen\",\"borne\",\"spook\",\"sauce\",\"amber\",\"lathe\",\"carat\",\"corer\",\"dirty\",\"slyly\",\"affix\",\"alloy\",\"taint\",\"sheep\",\"kinky\",\"wooly\",\"mauve\",\"flung\",\"yacht\",\"fried\",\"quail\",\"brunt\",\"grimy\",\"curvy\",\"cagey\",\"rinse\",\"deuce\",\"state\",\"grasp\",\"milky\",\"bison\",\"graft\",\"sandy\",\"baste\",\"flask\",\"hedge\",\"girly\",\"swash\",\"boney\",\"coupe\",\"endow\",\"abhor\",\"welch\",\"blade\",\"tight\",\"geese\",\"miser\",\"mirth\",\"cloud\",\"cabal\",\"leech\",\"close\",\"tenth\",\"pecan\",\"droit\",\"grail\",\"clone\",\"guise\",\"ralph\",\"tango\",\"biddy\",\"smith\",\"mower\",\"payee\",\"serif\",\"drape\",\"fifth\",\"spank\",\"glaze\",\"allot\",\"truck\",\"kayak\",\"virus\",\"testy\",\"tepee\",\"fully\",\"zonal\",\"metro\",\"curry\",\"grand\",\"banjo\",\"axion\",\"bezel\",\"occur\",\"chain\",\"nasal\",\"gooey\",\"filer\",\"brace\",\"allay\",\"pubic\",\"raven\",\"plead\",\"gnash\",\"flaky\",\"munch\",\"dully\",\"eking\",\"thing\",\"slink\",\"hurry\",\"theft\",\"shorn\",\"pygmy\",\"ranch\",\"wring\",\"lemon\",\"shore\",\"mamma\",\"froze\",\"newer\",\"style\",\"moose\",\"antic\",\"drown\",\"vegan\",\"chess\",\"guppy\",\"union\",\"lever\",\"lorry\",\"image\",\"cabby\",\"druid\",\"exact\",\"truth\",\"dopey\",\"spear\",\"cried\",\"chime\",\"crony\",\"stunk\",\"timid\",\"batch\",\"gauge\",\"rotor\",\"crack\",\"curve\",\"latte\",\"witch\",\"bunch\",\"repel\",\"anvil\",\"soapy\",\"meter\",\"broth\",\"madly\",\"dried\",\"scene\",\"known\",\"magma\",\"roost\",\"woman\",\"thong\",\"punch\",\"pasty\",\"downy\",\"knead\",\"whirl\",\"rapid\",\"clang\",\"anger\",\"drive\",\"goofy\",\"email\",\"music\",\"stuff\",\"bleep\",\"rider\",\"mecca\",\"folio\",\"setup\",\"verso\",\"quash\",\"fauna\",\"gummy\",\"happy\",\"newly\",\"fussy\",\"relic\",\"guava\",\"ratty\",\"fudge\",\"femur\",\"chirp\",\"forte\",\"alibi\",\"whine\",\"petty\",\"golly\",\"plait\",\"fleck\",\"felon\",\"gourd\",\"brown\",\"thrum\",\"ficus\",\"stash\",\"decry\",\"wiser\",\"junta\",\"visor\",\"daunt\",\"scree\",\"impel\",\"await\",\"press\",\"whose\",\"turbo\",\"stoop\",\"speak\",\"mangy\",\"eying\",\"inlet\",\"crone\",\"pulse\",\"mossy\",\"staid\",\"hence\",\"pinch\",\"teddy\",\"sully\",\"snore\",\"ripen\",\"snowy\",\"attic\",\"going\",\"leach\",\"mouth\",\"hound\",\"clump\",\"tonal\",\"bigot\",\"peril\",\"piece\",\"blame\",\"haute\",\"spied\",\"undid\",\"intro\",\"basal\",\"shine\",\"gecko\",\"rodeo\",\"guard\",\"steer\",\"loamy\",\"scamp\",\"scram\",\"manly\",\"hello\",\"vaunt\",\"organ\",\"feral\",\"knock\",\"extra\",\"condo\",\"adapt\",\"willy\",\"polka\",\"rayon\",\"skirt\",\"faith\",\"torso\",\"match\",\"mercy\",\"tepid\",\"sleek\",\"riser\",\"twixt\",\"peace\",\"flush\",\"catty\",\"login\",\"eject\",\"roger\",\"rival\",\"untie\",\"refit\",\"aorta\",\"adult\",\"judge\",\"rower\",\"artsy\",\"rural\",\"shave\"]\n\nNext we’ll turn this list into a Series object. We’ll also sort the answers.\n\nanswers = pd.Series(answers_list).sort_values(ignore_index=True)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#wordles-clues-algorithm",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#wordles-clues-algorithm",
    "title": "Draining the Fun Out of Wordle",
    "section": "Wordle’s clues algorithm",
    "text": "Wordle’s clues algorithm\nAfter each guess Wordle provides you with clues as to how close your guess was. Instead of colors we’ll use the following encoding:\n\nF (False), the letter does not appear in the word in any spot;\nP (Position), the letter appears in the word but is in the wrong spot;\nT (True), the letter is in the word and in the correct spot.\n\nThe match function generates the clues for a guess and an answer.\n\ndef match(guess, answer):\n    result = ['F'] * 5\n    chars = list(answer)\n    \n    # Mark correct letter and position as T\n    for i in range(5):\n        if guess[i] == answer[i]:\n            result[i] = 'T'\n            chars[i] = '_'\n    \n    # Mark correct letter, wrong position as P\n    for i in range(5):\n        for j in range(5):\n            if guess[i] == chars[j] and result[i] == 'F':\n                result[i] = 'P'\n                chars[j] = '_'\n    \n    # All other positions are marked as F by default\n    \n    return ''.join(result)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#filling-the-dataframe",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#filling-the-dataframe",
    "title": "Draining the Fun Out of Wordle",
    "section": "Filling the DataFrame",
    "text": "Filling the DataFrame\nUsing the wordlist and the match function we can create the DataFrame we’ll use to build the decision tree.\n\n# Add column with possible answers\ndf = answers.to_frame(name=\"answer\")\n\n\n# Suppress PerformanceWarning\nsimplefilter(action=\"ignore\", category=pd.errors.PerformanceWarning)\n\n# Add columns for answers\nfor index, value in answers.items():\n    df[value] = df[\"answer\"].map(lambda v: match(value, v))\n\nLet’s print the first ten rows to see how things turned out.\n\ndf.head(10)\n\n\n\n\n\n\n\n\nanswer\naback\nabase\nabate\nabbey\nabbot\nabhor\nabide\nabled\nabode\n...\nwryly\nyacht\nyearn\nyeast\nyield\nyoung\nyouth\nzebra\nzesty\nzonal\n\n\n\n\n0\naback\nTTTTT\nTTTFF\nTTTFF\nTTFFF\nTTFFF\nTTFFF\nTTFFF\nTTFFF\nTTFFF\n...\nFFFFF\nFPPFF\nFFTFF\nFFTFF\nFFFFF\nFFFFF\nFFFFF\nFFPFP\nFFFFF\nFFFPF\n\n\n1\nabase\nTTTFF\nTTTTT\nTTTFT\nTTFPF\nTTFFF\nTTFFF\nTTFFT\nTTFPF\nTTFFT\n...\nFFFFF\nFPFFF\nFPTFF\nFPTTF\nFFPFF\nFFFFF\nFFFFF\nFPPFP\nFPPFF\nFFFPF\n\n\n2\nabate\nTTTFF\nTTTFT\nTTTTT\nTTFPF\nTTFFP\nTTFFF\nTTFFT\nTTFPF\nTTFFT\n...\nFFFFF\nFPFFP\nFPTFF\nFPTFP\nFFPFF\nFFFFF\nFFFTF\nFPPFP\nFPFTF\nFFFPF\n\n\n3\nabbey\nTTFFF\nTTFFP\nTTFFP\nTTTTT\nTTTFF\nTTFFF\nTTFFP\nTTFTF\nTTFFP\n...\nFFFFT\nPPFFF\nPPPFF\nPPPFF\nPFPFF\nPFFFF\nPFFFF\nFPTFP\nFPFFT\nFFFPF\n\n\n4\nabbot\nTTFFF\nTTFFF\nTTFPF\nTTTFF\nTTTTT\nTTFTF\nTTFFF\nTTFFF\nTTPFF\n...\nFFFFF\nFPFFT\nFFPFF\nFFPFT\nFFFFF\nFPFFF\nFPFPF\nFFTFP\nFFFPF\nFPFPF\n\n\n5\nabhor\nTTFFF\nTTFFF\nTTFFF\nTTFFF\nTTFTF\nTTTTT\nTTFFF\nTTFFF\nTTPFF\n...\nFPFFF\nFPFPF\nFFPPF\nFFPFF\nFFFFF\nFPFFF\nFPFFP\nFFPPP\nFFFFF\nFPFPF\n\n\n6\nabide\nTTFFF\nTTFFT\nTTFFT\nTTFPF\nTTFFF\nTTFFF\nTTTTT\nTTFPP\nTTFTT\n...\nFFFFF\nFPFFF\nFPPFF\nFPPFF\nFPPFP\nFFFFF\nFFFFF\nFPPFP\nFPFFF\nFFFPF\n\n\n7\nabled\nTTFFF\nTTFFP\nTTFFP\nTTFTF\nTTFFF\nTTFFF\nTTFPP\nTTTTT\nTTFPP\n...\nFFFPF\nFPFFF\nFPPFF\nFPPFF\nFFPPT\nFFFFF\nFFFFF\nFPPFP\nFPFFF\nFFFPP\n\n\n8\nabode\nTTFFF\nTTFFT\nTTFFT\nTTFPF\nTTFPF\nTTFPF\nTTFTT\nTTFPP\nTTTTT\n...\nFFFFF\nFPFFF\nFPPFF\nFPPFF\nFFPFP\nFPFFF\nFPFFF\nFPPFP\nFPFFF\nFPFPF\n\n\n9\nabort\nTTFFF\nTTFFF\nTTFPF\nTTFFF\nTTFPT\nTTFPP\nTTFFF\nTTFFF\nTTTFF\n...\nFPFFF\nFPFFT\nFFPTF\nFFPFT\nFFFFF\nFPFFF\nFPFPF\nFFPTP\nFFFPF\nFPFPF\n\n\n\n\n10 rows × 2310 columns"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#preprocessing",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#preprocessing",
    "title": "Draining the Fun Out of Wordle",
    "section": "Preprocessing",
    "text": "Preprocessing\nWe’ll separate the DataFrame into features and the target variable. Then we’ll use sklearn’s LabelEncoder to convert the features into numeric values. We’ll use the same encoding for all columns. We do this because in our tree induction algorithm below we use sklearn’s mutual_info_classif function that expects features to be numeric.\n\nX = df.drop(columns=\"answer\")\ny = df[\"answer\"]\n\nLet’s prepare the label encoder.\n\nle = LabelEncoder()\nle.fit(X.stack().unique())\n\nLabelEncoder()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LabelEncoderLabelEncoder()\n\n\nNow we can convert all columns.\n\nX = X.apply(le.transform)\n\nAgain, let’s print the first few rows to check if the encoding went alright.\n\nX.head()\n\n\n\n\n\n\n\n\naback\nabase\nabate\nabbey\nabbot\nabhor\nabide\nabled\nabode\nabort\n...\nwryly\nyacht\nyearn\nyeast\nyield\nyoung\nyouth\nzebra\nzesty\nzonal\n\n\n\n\n0\n237\n231\n231\n214\n214\n214\n214\n214\n214\n214\n...\n0\n36\n18\n18\n0\n0\n0\n10\n0\n3\n\n\n1\n231\n237\n233\n217\n214\n214\n216\n217\n216\n214\n...\n0\n27\n45\n51\n9\n0\n0\n37\n36\n3\n\n\n2\n231\n233\n237\n217\n215\n214\n216\n217\n216\n215\n...\n0\n28\n45\n46\n9\n0\n6\n37\n33\n3\n\n\n3\n214\n215\n215\n237\n231\n214\n215\n220\n215\n214\n...\n2\n108\n117\n117\n90\n81\n81\n46\n29\n3\n\n\n4\n214\n214\n217\n231\n237\n220\n214\n214\n223\n225\n...\n0\n29\n9\n11\n0\n27\n30\n19\n3\n30\n\n\n\n\n5 rows × 2309 columns\n\n\n\nWe can see that the patterns have been replaced by numbers. Every number is an index of a value in the le.classes_ array. For demonstration purposes, let’s look at the first 10 items of this array.\n\nle.classes_[:10]\n\narray(['FFFFF', 'FFFFP', 'FFFFT', 'FFFPF', 'FFFPP', 'FFFPT', 'FFFTF',\n       'FFFTP', 'FFFTT', 'FFPFF'], dtype=object)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#tree-induction",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#tree-induction",
    "title": "Draining the Fun Out of Wordle",
    "section": "Tree induction",
    "text": "Tree induction\nNow we’re ready to generate our tree.\nSeveral tree induction algorithms exist. They generally work top down and use some metric to determine what feature to split by at each node. The sklearn library provides CART (Classification And Regression Trees) that by default use the Gini impurity as a metric. Nodes in CART, however, only support binary splits which would make our decision tree unnecessarily deep and large. An alternative candidate algorithm could be ID3 or ID4.5. These algorithms use a concept known as information gain (the reduction in entropy after splitting by a variable) to determine what feature to split by, and they support non-binary nodes. A few Python libraries exist that implement ID3/ID4.5. We could use one of those. However, we require a bit more control over how we select the best feature, which is why we roll our own tree induction algorithm.\nTo determine what feature (word) to split by in each node, we use a metric called mutual information which is the expected value of the information gain. This metric is commonly used for feature selection and is already provided by the sklearn library as mutual_info_classif. At each node multiple words might be equally good candidates; therefor, in addition to mutual information, we will also consider whether a feature could actually be the correct answer which will generally lead to slightly more optimal trees.\nThe approach I describe here won’t guarantee an optimal tree. We’re using a greedy strategy to select the most promising features. Selecting less promising features earlier on might yield more optimal splits at a later stage; however, tree induction would take much longer. We’ll still end up with an efficient tree for solving the daily Wordle, there’s just no guarantee it will be the optimal one. Realise that this is true for tree induction algorithms like CART/ID3/ID4.5 as well. Tree induction algorithms simply make locally optimal choices at each split based on the available data, and these choices may not lead to the overall best tree structure.\n\nclass WordleDecisionTree:\n    def fit(self, input, output, labels):\n        data = input.copy()\n        data[output.name] = output\n        self.labels = labels\n        self.tree = self.decision_tree(data, data, input.columns, output.name)\n\n    def decision_tree(self, data, orginal_data, feature_attribute_names, target_attribute_name):\n        unique_classes = np.unique(data[target_attribute_name])\n        if len(unique_classes) &lt;= 1:\n            return unique_classes[0]\n        else:\n            # determine best feature using mutual information\n            stats = dict(zip(feature_attribute_names, mutual_info_classif(\n                data[feature_attribute_names], \n                data[target_attribute_name], \n                discrete_features=True)\n            ))\n            best_feature = max(stats, key=lambda key: stats[key])\n            \n            # create tree structure, empty at first\n            tree = {best_feature: {}}\n\n            # remove best feature from available features, it will become the parent node\n            feature_attribute_names = [i for i in feature_attribute_names if i != best_feature]\n\n            # create nodes under parent node\n            parent_attribute_values = np.unique(data[best_feature])\n            for value in parent_attribute_values:\n                sub_data = data.where(data[best_feature] == value).dropna()\n                \n                remaining_features = np.unique(sub_data[target_attribute_name])\n                if len(remaining_features) &lt;= 2:\n                    subtree = self.decision_tree(sub_data, orginal_data, remaining_features, target_attribute_name)\n                else:\n                    subtree = self.decision_tree(sub_data, orginal_data, feature_attribute_names, target_attribute_name)\n                \n                # add subtree to original tree\n                if self.labels[int(value)] != \"TTTTT\":\n                    tree[best_feature][self.labels[int(value)]] = subtree\n            \n            return tree\n\nWe’ll instantiate this class and generate the tree. This took about 12 minutes on my machine.\nmodel = WordleDecisionTree()\nmodel.fit(X, y, le.classes_)\nThe tree is stored as a nested Python dictionary. Let’s convert it to a JSON string and print the first fifteen lines.\n\nprint('\\n'.join(json.dumps(model.tree, indent=4).split('\\n')[:15]))\n\n{\n    \"raise\": {\n        \"FFFFF\": {\n            \"mulch\": {\n                \"FFFFF\": {\n                    \"goody\": {\n                        \"FFTFF\": \"known\",\n                        \"FTFFT\": {\n                            \"bobby\": {\n                                \"FTFFT\": \"poppy\"\n                            }\n                        },\n                        \"FTFPT\": \"downy\",\n                        \"FTFTT\": {\n                            \"dowdy\": {\n\n\nThe root node of this tree shows the best word to start with. Again, remember that we are only considering words that could actually be a valid answer. We can’t make any claims about this word being the best word to start with. What we can claim however is that on some day we will guess the correct answer on a first try.\n\nprint(next(iter(model.tree)))\n\nraise\n\n\nWe can determine the max depth of the decision tree.\n\ndef depth(d):\n    queue = deque([(id(d), d, 1)])\n    memo = set()\n    while queue:\n        id_, o, level = queue.popleft()\n        if id_ in memo:\n            continue\n        memo.add(id_)\n        if isinstance(o, dict):\n            queue += ((id(v), v, level + 1) for v in o.values())\n    return level\n\n\ndepth(model.tree)\n\n11\n\n\nEvery level in this nested dictionary is either a guess or a response. So a depth of 11 shows we can always guess the correct answer in 6 tries or less. I imagine you letting out a huge sigh of relief now."
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#saving-the-decision-tree",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#saving-the-decision-tree",
    "title": "Draining the Fun Out of Wordle",
    "section": "Saving the decision tree",
    "text": "Saving the decision tree\nWe’ll save the decision tree as a JSON file so we don’t have to rerun the previous steps.\n\nwith open('wordle.json', 'w') as fp:\n    json.dump(model.tree, fp)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#loading-the-decision-tree",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#loading-the-decision-tree",
    "title": "Draining the Fun Out of Wordle",
    "section": "Loading the decision tree",
    "text": "Loading the decision tree\nWhenever we want to use the decision tree, we can just load it. Here we load it into the variable tree.\n\nwith open('wordle.json', 'r') as fp:\n    tree = json.load(fp)"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#using-the-decision-tree",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#using-the-decision-tree",
    "title": "Draining the Fun Out of Wordle",
    "section": "Using the decision tree",
    "text": "Using the decision tree\nThe first word to try, as we’ve already seen is:\n\nprint(next(iter(tree)))\n\nraise\n\n\nAfter we try raise we might get feedback such as ‘FPFFP’. We can use this to get the next guess:\n\nprint(next(iter(tree['raise']['FPFFP'])))\n\ncleat\n\n\nSuppose that after trying this word we get back ‘FTTTT’. We can just expand the chain of keys to find out what the next guess should be.\n\nprint(next(iter(tree['raise']['FPFFP']['cleat']['FTTTT'])))\n\nbleat\n\n\nAnd so on until the word has been guessed."
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#creating-the-user-interface",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#creating-the-user-interface",
    "title": "Draining the Fun Out of Wordle",
    "section": "Creating the user interface",
    "text": "Creating the user interface\nTraversing the decision tree like this is a bit cumbersome. Let’s build the GUI using Jupyter widgets to ease navigating the tree. We’ll display a grid which shows the next guess. Every element in this grid is a button widget. We change the caption on these buttons to display the next word to try. By clicking these buttons you can change their color to enter the clues Wordle provides as feedback.\nWe let traverse_tree be equal to the root node of the decision tree. We start at the top row of the grid.\n\ntraverse_tree = tree\nactive_row = 0\n\nWe update the color of the button every time it is clicked. On every update we traverse the tree and find the next guess.\n\ndef on_btn_click(b, row, col):\n    global traverse_tree\n    global active_row\n    \n    for r in range(6):\n        enable_row(r, r==row)\n    \n    if active_row &lt; row:\n        traverse_tree = traverse_tree[get_word(row - 1)][get_pattern(row - 1)]\n        active_row = row\n    \n    if b.style.button_color == '#FFFFFF':\n        b.style.button_color = '#C9B458'\n    elif b.style.button_color == '#C9B458':\n        b.style.button_color = '#787C7E'\n    elif b.style.button_color == '#787C7E':\n        b.style.button_color = '#6AAA64'\n    elif b.style.button_color == '#6AAA64':\n        b.style.button_color = '#C9B458'\n    \n    if row &lt; 6:\n        pattern = get_pattern(row)\n        if pattern:\n            set_word(row + 1, get_next_word(row).upper())\n        else:\n            set_word(row + 1, \"     \")\n    \n        enable_row(row + 1, get_word(row + 1).strip())\n\nThe following function finds the next guess in the tree.\n\ndef get_next_word(row):\n    try:\n        if isinstance(traverse_tree[get_word(row)][get_pattern(row)],str):\n            return traverse_tree[get_word(row)][get_pattern(row)]\n        return next(iter(traverse_tree[get_word(row)][get_pattern(row)]))\n    except:\n        return \"     \"\n    return \"     \"\n\nWe want to call on_btn_click() for every button in the interface. A function that handles a click on a button only takes one argument, the button that is clicked. However, the on_btn_click() takes three arguments: the button, the row and the column. To bind the on_btn_click() to each button we use some glue code. The following function returns a handler for every button’s click. Each handler encapsulates the row and column in the grid and forwards the call to the on_btn_click().\n\ndef create_on_btn_click_fun(row, col):\n    def _on_btn_click(b):\n        on_btn_click(b, row, col)\n    return _on_btn_click\n\nWe need a function the display the next guess in a row in the grid.\n\ndef set_word(row, word):\n    for c in range(5):\n        vbox.children[row].children[c].description = word[c]\n\nWe want the player to only press buttons in the currently active row. For this we create a function that can enable or disable a row.\n\ndef enable_row(row,b):\n    for c in range(5):\n        vbox.children[row].children[c].disabled = not b\n\nOnce the user has completely set the pattern in a row we want to return this pattern. The following function takes care of this. If not all colors have been set yet, it will return None.\n\ndef get_pattern(row):\n    pattern = []\n    for c in range(5):\n        if vbox.children[row].children[c].style.button_color == '#FFFFFF':\n            return None\n        elif vbox.children[row].children[c].style.button_color == '#C9B458':\n            pattern.append('P')\n        elif vbox.children[row].children[c].style.button_color == '#787C7E':\n            pattern.append('F')\n        elif vbox.children[row].children[c].style.button_color == '#6AAA64':\n            pattern.append('T')\n    return ''.join(pattern)\n\nWe also write a function that returns the word in a row.\n\ndef get_word(row):\n    letters = []\n    for c in range(5):\n        letters.append(vbox.children[row].children[c].description)\n    return ''.join(letters).lower()\n\nWe need to be able to clear the grid and set it up to solve another puzzle.\n\ndef on_reset_button_click(b):\n    global traverse_tree\n    global active_row\n    for r in range(6):\n        enable_row(r, r==0)\n        for c in range(5):\n            b = vbox.children[r].children[c]\n            b.style.button_color = '#FFFFFF'\n            b.description = ' '\n    traverse_tree = tree\n    active_row = 0\n    set_word(0, next(iter(traverse_tree)).upper())\n\nNow, let’s display the actual grid and a reset button.\n\nvbox_items = []\nfor r in range(6):\n    hbox_items = []\n    for c in range(5):\n        button = widgets.Button(description=' ', style=dict(button_color='#FFFFFF', font_weight='bold'), layout=widgets.Layout(width='32px', height='32px', border='solid 1px'))\n        button.on_click(create_on_btn_click_fun(r,c))\n        hbox_items.append(button)\n    vbox_items.append(widgets.HBox(hbox_items))\n\nvbox = widgets.VBox(vbox_items)\nreset_button = widgets.Button(description=\"Reset\")\nreset_button.on_click(on_reset_button_click)\ndisplay(vbox, reset_button)\non_reset_button_click(reset_button)\n\n\n\n\n\n\n\nTo use this GUI, you simply enter the suggested word into Wordle. By clicking the letters you change the colors and get the next guess.\n\n\n\n\nVictory in three guesses!"
  },
  {
    "objectID": "posts/draining-the-fun-out-of-wordle/index.html#taking-back-control-of-your-life",
    "href": "posts/draining-the-fun-out-of-wordle/index.html#taking-back-control-of-your-life",
    "title": "Draining the Fun Out of Wordle",
    "section": "Taking back control of your life",
    "text": "Taking back control of your life\nUse one of the following links to play with an interactive version:\n   \nThe binder link points to a minimal Voila web app version that just loads the decision tree from file and displays the user interface. The other links include the actual tree induction algorithm.\nNow you no longer need to worry about keeping your streak going. Please go back to doing something useful!"
  },
  {
    "objectID": "posts/vba-iban-validator/index.html",
    "href": "posts/vba-iban-validator/index.html",
    "title": "VBA IBAN Validator",
    "section": "",
    "text": "From February 2014 onwards, IBAN will be the new European standard for bank account numbers. This standardization is part of the SEPA initiative to improve the efficiency of cross-border euro payments.\nI wrote an IBAN validator in VBA for an MS Access database I’m maintaining, but you can also use it in Excel or any other application that supports VBA.\n\n\nmodValidIban.bas\n\nOption Compare Database\nOption Explicit\n\n' http://en.wikipedia.org/wiki/International_Bank_Account_Number\nPrivate Const IbanCountryLengths As String = \"AL28AD24AT20AZ28BH22BE16BA20BR29BG22CR21HR21CY28CZ24DK18DO28EE20FO18\" & _\n                                             \"FI18FR27GE22DE22GI23GR27GL18GT28HU28IS26IE22IL23IT27KZ20KW30LV21LB28\" & _\n                                             \"LI21LT20LU20MK19MT31MR27MU30MC27MD24ME22NL18NO15PK24PS29PL28PT25RO24\" & _\n                                             \"SM27SA24RS22SK24SI19ES24SE24CH21TN24TR26AE23GB22VG24QA29\"\n\nPrivate Function ValidIbanCountryLength(CountryCode As String, IbanLength As Integer) As Boolean\n    Dim i As Integer\n    For i = 0 To Len(IbanCountryLengths) / 4 - 1\n        If Mid(IbanCountryLengths, i * 4 + 1, 2) = CountryCode And _\n                    CInt(Mid(IbanCountryLengths, i * 4 + 3, 2)) = IbanLength Then\n            ValidIbanCountryLength = True\n            Exit Function\n        End If\n    Next i\n    ValidIbanCountryLength = False\nEnd Function\n\nPrivate Function Mod97(Num As String) As Integer\n    Dim lngTemp As Long\n    Dim strTemp As String\n\n    Do While Val(Num) &gt;= 97\n        If Len(Num) &gt; 5 Then\n            strTemp = Left(Num, 5)\n            Num = Right(Num, Len(Num) - 5)\n        Else\n            strTemp = Num\n            Num = \"\"\n        End If\n        lngTemp = CLng(strTemp)\n        lngTemp = lngTemp Mod 97\n        strTemp = CStr(lngTemp)\n        Num = strTemp & Num\n    Loop\n    Mod97 = CInt(Num)\nEnd Function\n\nPublic Function ValidIban(IBAN As String) As Boolean\n    Dim strIban As String\n    Dim i As Integer\n\n    strIban = UCase(IBAN)\n    ' Remove spaces\n    strIban = Replace(strIban, \" \", \"\")\n\n    ' Check if IBAN contains only uppercase characters and numbers\n    For i = 1 To Len(strIban)\n        If Not ((Asc(Mid(strIban, i, 1)) &lt;= Asc(\"9\") And Asc(Mid(strIban, i, 1)) &gt;= Asc(\"0\")) Or _\n                (Asc(Mid(strIban, i, 1)) &lt;= Asc(\"Z\") And Asc(Mid(strIban, i, 1)) &gt;= Asc(\"A\"))) Then\n            ValidIban = False\n            Exit Function\n        End If\n    Next i\n\n    ' Check if length of IBAN equals expected length for country\n    If Not ValidIbanCountryLength(Left(strIban, 2), Len(strIban)) Then\n        ValidIban = False\n        Exit Function\n    End If\n\n    ' Rearrange\n    strIban = Right(strIban, Len(strIban) - 4) & Left(strIban, 4)\n\n    ' Replace characters\n    For i = 0 To 25\n        strIban = Replace(strIban, Chr(i + Asc(\"A\")), i + 10)\n    Next i\n\n    ' Check remainder\n    ValidIban = Mod97(strIban) = 1\nEnd Function\n\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "",
    "text": "In the scikit-learn machine learning library, the predict method is used to make predictions on new data with a fitted model. This method expects the input data to have the same number of features as the data that the model was trained on. This makes sense for many models, but not necessarily for decision trees. Since decision trees look at one feature at a time, they may only need a subset of all features to make a prediction.\nIf we want to provide solely the features that are actually considered when making a prediction, we will need to traverse a decision tree iteratively.\nTo show you how this works, we’ll fit a decision tree model to a dataset of Guess Who character features. After fitting the model, we can traverse the resulting tree to make a prediction about the character’s identity."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#wait-how-do-i-play-guess-who-again",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#wait-how-do-i-play-guess-who-again",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Wait, how do I play Guess Who again?",
    "text": "Wait, how do I play Guess Who again?\nIt may have been a while since you played this game, so let’s start with a refresher.\nIn Guess Who two players try to guess the opponent’s character by asking yes-no questions. Each player starts the game with a board that includes cartoon images of 24 people and their first names with all the images standing up. Each player selects a card of their choice from a separate pile of cards containing the same 24 images. The objective of the game is to be the first to determine which card one’s opponent has selected. Players alternate asking various yes-no questions to eliminate candidates, such as:\n\nDoes your person wear a hat?\nDoes your person wear glasses?\nIs your person female?\n\nThe player will then eliminate candidates (based on the opponent’s response) by flipping those images down until only one is left."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#importing-necessary-libraries-and-loading-the-data",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#importing-necessary-libraries-and-loading-the-data",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Importing necessary libraries and loading the data",
    "text": "Importing necessary libraries and loading the data\nTo begin, we import the necessary libraries.\n\nimport pandas as pd\nimport numpy as np\nimport graphviz\nimport re\n\nfrom ipywidgets import GridspecLayout, HTML, VBox, HBox, Button, Label\nfrom sklearn.tree import DecisionTreeClassifier, export_graphviz\n\nData describing the characters is loaded into a Pandas DataFrame, with the character names located in the final column. Each feature in the DataFrame represents a specific trait, where a value of 1 or 0 indicates the presence or absence of that trait for a particular character.\n\ndf = pd.DataFrame({\n    # hair style\n    'hair_partition': [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0], \n    'curly_hair':     [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],\n    'hat':            [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'bald':           [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n    'long_hair':      [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    # hair color\n    'ginger_hair':    [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'white_hair':     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0],\n    'brown_hair':     [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0],\n    'blond_hair':     [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'black_hair':     [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1],\n    # facial attributes\n    'big_mouth':      [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\n    'big_nose':       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0],\n    'red_cheeks':     [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0],\n    'blue_eyes':      [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n    'sad_looking':    [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    # facial hair\n    'facial_hair':    [1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0],\n    'moustache':      [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0],\n    'beard':          [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n    # other\n    'glasses':        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1],\n    'earrings':      [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'female':         [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    # names\n    'name':           ['alex', 'alfred', 'anita', 'anne', 'bernard', 'bill', 'charles', 'claire', \n                       'david', 'eric', 'frans', 'george', 'herman', 'joe', 'maria', 'max', 'paul', \n                       'peter', 'philip', 'richard', 'robert', 'sam', 'susan', 'tom']\n})\n\nEvery trait is associated with a question. The following dictionary links each trait (or feature) to a valid yes-no question. We will use this dictionary to map feature names to questions.\n\ncolumn_description = {\n    \"hair_partition\": \"Does your character have a visible hair partition?\",\n    \"curly_hair\": \"Does your character have curly hair?\",\n    \"hat\": \"Does your character wear a hat?\",\n    \"bald\": \"Is your character bald?\",\n    \"long_hair\": \"Does your character have long hair?\",\n    \"ginger_hair\": \"Does your character have ginger hair?\",\n    \"white_hair\": \"Does your character have white hair?\",\n    \"brown_hair\": \"Does your character have brown hair?\",\n    \"blond_hair\": \"Does your character have blond hair?\",\n    \"black_hair\": \"Does your character have black hair?\",\n    \"big_mouth\": \"Does your character have a big mouth?\",\n    \"big_nose\": \"Does your character have a big nose?\",\n    \"red_cheeks\": \"Does your character have red cheeks?\",\n    \"blue_eyes\": \"Does your character have blue eyes?\",\n    \"sad_looking\": \"Does your character look sad?\",\n    \"facial_hair\": \"Does your character have facial hair?\",\n    \"moustache\": \"Does your character have a moustache?\",\n    \"beard\": \"Does your character have a beard?\",\n    \"glasses\": \"Does your character wear glasses?\",\n    \"earrings\": \"Does your character wear earrings?\",\n    \"female\": \"Is your character female?\"\n}\n\nI used the traits mentioned in this blog post. At the end of this post, I’ll suggest some more questions you could add."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#fitting-the-decision-tree",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#fitting-the-decision-tree",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Fitting the decision tree",
    "text": "Fitting the decision tree\nFirstly, we select the features and target variable from the DataFrame.\n\nX = df.iloc[:, :-1]\ny = df.iloc[:, -1]\n\nWe create a list feature_names containing the names of all the features in the input dataset. We will use this when visualizing the decision tree.\n\nfeature_names = list(df.columns)[:-1]\n\nBelow we fit the decision tree classifier using the DecisionTreeClassifier class. We specify the criterion for splitting nodes as entropy. The default is gini but entropy yields a slightly more optimal tree in this case.\n\nclf = DecisionTreeClassifier(criterion = \"entropy\")\nclf = clf.fit(X, y)"
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#visualizing-the-decision-tree",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#visualizing-the-decision-tree",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Visualizing the decision tree",
    "text": "Visualizing the decision tree\nThe depth of the tree tells us how many questions we need to ask at most. Ideally, you would want to do a binary search by splitting the number of possible characters in half with each question. By asking questions that split the number of remaining characters into two equal groups, you’d need only 4 or 5 questions at most.\nLet’s see how we do with the set of questions we defined above.\n\nclf.get_depth()\n\n6\n\n\nThe tree has a depth of 6. This means we need to ask 6 questions at most to guess the opponent’s characters if we use this decision tree. Let’s see what the tree looks like.\nIf we plot the tree graphically using sklearn.tree.plot_tree the result is illegible. A better way is to use the Graphviz format. The export_graphviz function returns a DOT string which is the abstract language used by Graphviz to describe nodes, edges, graphs, subgraphs etc.\n\ndot_data = export_graphviz(clf, out_file=None, feature_names=feature_names, \n    rotate=True, class_names=y, filled=True, rounded=True, \n    leaves_parallel=True, impurity=False, special_characters=True)\n\nWe can make the tree more compact by removing superfluous content from the nodes.\n\ndot_data = re.sub(\"=&lt;samples = .*class = \", \"=&lt;\", dot_data)\ndot_data = re.sub(\" &le; 0.5.*&gt;, fillcolor\", \"&gt;, fillcolor\", dot_data)\ndot_data = re.sub('labeldistance.*headlabel=\"True\"', 'label=\"NO\"', dot_data)\ndot_data = re.sub('labeldistance.*headlabel=\"False\"', 'label=\"YES\"', dot_data)\ndot_data = re.sub('ranksep=.*,', 'ranksep=0.02', dot_data)\n\nFinally we display the tree.\n\ngraph = graphviz.Source(dot_data)\ngraph\n\n\n\n\nWe can see that most characters can be guessed in 4 or 5 moves. Only two characters need a 6th question."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#traversing-the-decision-tree",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#traversing-the-decision-tree",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Traversing the decision tree",
    "text": "Traversing the decision tree\nWe can traverse the decision tree programmatically using the tree_ attribute of the trained clf object. The tree_ attribute is an instance of the sklearn.tree._tree.Tree class, which represents the decision tree as a binary tree of nodes.\nThe Tree class has several attributes and methods that can be used to traverse the tree, including:\n\nnode_count: the total number of nodes in the tree.\nfeature: an array of length node_count containing the feature index at each node, or -2 for leaf nodes.\nthreshold: an array of length node_count containing the threshold value at each split node, or -2 for leaf nodes. In our case the threshold value will always be 0.5 because all our features are either 0 or 1.\nvalue: an array of shape (node_count, n_outputs, n_classes) containing the class distribution at each leaf node.\nchildren_left: an array of length node_count containing the index of the left child node for each split node, or -1 for leaf nodes.\nchildren_right: an array of length node_count containing the index of the right child node for each split node, or -1 for leaf nodes.\n\nTo traverse the decision tree, we start at the root node (index 0) and recursively traverse the left or right child nodes depending on the feature value.\nThe following function traverses the tree and queries the user at each (non-leaf) node it encounters. It uses the column_description dictionary that we’ve defined above to match feature names to questions.\n\ndef play_game(node_id=0):\n    if clf.tree_.children_left[node_id] == -1:\n        # leaf node\n        print(f\"Your character is: {clf.classes_[clf.tree_.value[node_id].argmax()].capitalize()}\")\n    else:\n        feature = clf.feature_names_in_[clf.tree_.feature[node_id]]\n        threshold = clf.tree_.threshold[node_id]\n\n        while (ans := input(f\"{column_description[feature]} (Y/N): \").lower()) not in ['y', 'n']:\n            pass\n        \n        val = 0 if ans == 'n' else 1\n        if val &lt;= threshold:\n            # it's a 'no', so traverse left subtree\n            play_game(clf.tree_.children_left[node_id])\n        else:\n            # traverse right subtree\n            play_game(clf.tree_.children_right[node_id])\n\nBy calling this function, we recursively traverse the decision tree starting from the root node (index 0), checking the feature value of the input instance at each split node and following the left or right child node accordingly, until a leaf node is reached. At the leaf node, the function prints the predicted class label by finding the index of the largest class probability in the value array of the leaf node, which corresponds to the predicted class label (the name of the character)."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#creating-a-fancy-gui-with-ipywidgets",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#creating-a-fancy-gui-with-ipywidgets",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Creating a fancy GUI with ipywidgets",
    "text": "Creating a fancy GUI with ipywidgets\nWe can create a way fancier GUI using Jupyter widgets, and render it using Voila to create an interactive web app. We’ll display the pictures of the characters that we will flip down while traversing the tree. The images were taken from this website.\nWe use the following features of the tree_ attribute.\n\nchildren_left = clf.tree_.children_left\nchildren_right = clf.tree_.children_right\nfeature = clf.tree_.feature\nvalue = clf.tree_.value\n\nThe next part sets up the grid using GridspecLayout with 3 rows and 8 columns. Each cell in the grid contains an HTML element with an image of a character loaded from the website mentioned above.\nThe code also creates a label and three buttons using the Label and Button classes, and arranges them in a horizontal box (HBox). The label displays the current question or the final answer, and the buttons allow the user to answer yes or no to a question, and restart the game. These widgets are then arranged in a vertical box (VBox) along with the grid.\n\ngrid = GridspecLayout(3, 8)\ngrid.width = \"1120\"\n\nfor i in range(3):\n    for j in range(8):\n        grid[i, j] = HTML(value=\"&lt;img src='https://guesswhocharacters.info/imgs/{}.jpeg' width=130 height=190&gt;\".format(str(df.name[i*8+j])))\n\nlabel = Label(value=\"Put the questions and answer here\")\nbutton_yes = Button(description=\"Yes\")\nbutton_no = Button(description=\"No\")\nbutton_play_again = Button(description=\"Play again\")\nhbox = HBox([label, button_yes, button_no, button_play_again])\nvbox = VBox([grid, hbox])\n\nThe root node of the tree will have an id of 0 which is where we start out search.\n\n# Start at root\nnode_id = 0\n\nThe functions below are for updating the GUI based on user interactions:\n\nupdate_gui() updates the label and buttons based on the current node in a decision tree model used for the game. If the current node is a leaf node, meaning it represents a final answer, the label displays the character’s name and the “Yes” and “No” buttons are hidden while the “Play Again” button is shown. If the current node is a branch node, the label displays the current question, and the “Yes” and “No” buttons are shown while the “Play Again” button is hidden.\nshow_all_cards() makes all cards visible in the grid.\nhide_cards(attribute, val) hides cards in the grid that have a particular attribute with a given value.\non_button_yes_clicked(b), on_button_no_clicked(b), and on_button_play_again_clicked(b) are callback functions that are executed when the “Yes”, “No”, or “Play Again” button is clicked, respectively. These functions update the node_id variable that tracks the current node in the decision tree model and call update_gui() to update the GUI based on the new node.\n\n\ndef update_gui():\n    if children_left[node_id] == children_right[node_id]:\n        label.value = \"You character is \" + y[np.argmax(value[node_id])].capitalize()\n        button_yes.layout.display = 'none'\n        button_no.layout.display = 'none'\n        button_play_again.layout.display = 'block'\n    else:\n        label.value = column_description[df.columns[feature[node_id]]]\n        button_yes.layout.display = 'block'\n        button_no.layout.display = 'block'\n        button_play_again.layout.display = 'none'\n\ndef show_all_cards():\n    for i in range(3):\n        for j in range(8):\n            grid[i, j].layout.visibility = 'visible'\n\ndef hide_cards(attribute, val):\n    for i in range(3):\n        for j in range(8):\n            if df[attribute][i*8+j] == val:\n                grid[i, j].layout.visibility = 'hidden'\n        \ndef on_button_yes_clicked(b):\n    global node_id\n    hide_cards(df.columns[feature[node_id]], 0)\n    node_id = children_right[node_id]\n    update_gui()\n\ndef on_button_no_clicked(b):\n    global node_id\n    hide_cards(df.columns[feature[node_id]], 1)\n    node_id = children_left[node_id]\n    update_gui()\n\ndef on_button_play_again_clicked(b):\n    global node_id\n    show_all_cards()\n    node_id = 0\n    update_gui()\n    \nbutton_yes.on_click(on_button_yes_clicked)\nbutton_no.on_click(on_button_no_clicked)\nbutton_play_again.on_click(on_button_play_again_clicked)\n\nupdate_gui()\n\nFinally, the GUI is displayed using the display() function.\n\ndisplay(vbox)\n\n\n\n\nUse one of the following links to play with an interactive version:"
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#ok-cool-but-how-do-i-win-at-guess-who",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#ok-cool-but-how-do-i-win-at-guess-who",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "OK, cool, but how do I win at Guess Who?",
    "text": "OK, cool, but how do I win at Guess Who?\nNow you know how to fit and traverse a decision tree. Let’s see how we can improve the decision tree.\nOur decision tree above has a depth of 6 which seems decent, but as I mentioned, we can do better. In order to guess our opponent’s character with the least number of attempts, we want to pose questions that halve the number of potential characters each turn. By employing this tactic, we can quickly narrow down the options from 24 people to 12, then 6, 3, and eventually just 1 or 2 remaining. This approach enables us to guess the character within a maximum of 4 or 5 turns.\nThe game has deliberately been designed so that obvious traits, like if the person is female, or if the person has a moustache, applies to 5 characters at most. This makes even splits challenging. Two strategies that are mentioned in various places are the letter strategy and the compound questions strategy.\n\nLetter strategy\nThe letter strategy is a simple yet effective approach. It works by asking questions that revolve around the starting letter of each character’s name and focusing on the middle starting letter of the remaining characters. For instance, asking as a first question if the person’s name starts with the letters A-G would eliminate half the characters. If the person’s name does indeed start with one of the letters A-G, a follow-up question might be whether the person’s name starts with the letters A-B, and so on.\n\n\nCompound questions strategy\nAnother approach is the compound questions strategy. Rather than asking about a single characteristic at a time, you can ask about two or more characteristics simultaneously. For example, instead of asking “Does your person have white hair?”, you could ask “Does your person have white hair OR black hair?”. The facial hair trait used above is an example of such a compound question as it asks whether the character has a beard OR a moustache."
  },
  {
    "objectID": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#conclusion",
    "href": "posts/traversing-a-decision-tree-to-win-at-guess-who/index.html#conclusion",
    "title": "Traversing a Decision Tree to Win at Guess Who?",
    "section": "Conclusion",
    "text": "Conclusion\nWe have seen how a fitted decision tree can be traversed iteratively.\nBy adding new questions based on the letter and compound questions strategies to the DataFrame above you should be able to reduce the depth of the decision tree to five.\nSo there you have it, you now have all the tools to dominate (and drain all the fun out of) your Guess Who games.\nGood luck and happy guessing!"
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html",
    "href": "posts/a-custom-sudoku-widget/index.html",
    "title": "A Custom Sudoku Widget",
    "section": "",
    "text": "In this post I’ll demonstrate how to build a custom Jupyter widget for displaying and editing Sudoku puzzles. I’ll also show how to create a Sudoku solver that uses this widget."
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#how-to-play-sudoku",
    "href": "posts/a-custom-sudoku-widget/index.html#how-to-play-sudoku",
    "title": "A Custom Sudoku Widget",
    "section": "How to play Sudoku",
    "text": "How to play Sudoku\nOnly read this if you’ve been living under a rock, otherwise skip to the good stuff.\nIn Sudoku, the objective is to fill a 9x9 grid with digits so that each column, each row, and each of the nine 3x3 blocks that compose the grid contain all of the digits from 1 to 9.\nAn example Sudoku puzzle:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8\n\n\n5\n\n\n\n\n6\n\n\n1\n\n\n\n\n\n\n\n\n\n\n9\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n3\n\n\n\n\n8\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n\n\n7\n\n\n\n\n\n\n\n\n9\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5\n\n\n8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n6\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\nThe solution to this puzzle looks like this:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3\n\n\n8\n\n\n5\n\n\n9\n\n\n6\n\n\n1\n\n\n4\n\n\n2\n\n\n7\n\n\n\n\n9\n\n\n2\n\n\n4\n\n\n8\n\n\n7\n\n\n3\n\n\n1\n\n\n5\n\n\n6\n\n\n\n\n1\n\n\n6\n\n\n7\n\n\n5\n\n\n4\n\n\n2\n\n\n3\n\n\n9\n\n\n8\n\n\n\n\n\n\n5\n\n\n4\n\n\n3\n\n\n1\n\n\n8\n\n\n7\n\n\n9\n\n\n6\n\n\n2\n\n\n\n\n7\n\n\n1\n\n\n8\n\n\n2\n\n\n9\n\n\n6\n\n\n5\n\n\n4\n\n\n3\n\n\n\n\n2\n\n\n9\n\n\n6\n\n\n4\n\n\n3\n\n\n5\n\n\n8\n\n\n7\n\n\n1\n\n\n\n\n\n\n4\n\n\n7\n\n\n1\n\n\n6\n\n\n5\n\n\n8\n\n\n2\n\n\n3\n\n\n9\n\n\n\n\n8\n\n\n3\n\n\n9\n\n\n7\n\n\n2\n\n\n4\n\n\n6\n\n\n1\n\n\n5\n\n\n\n\n6\n\n\n5\n\n\n2\n\n\n3\n\n\n1\n\n\n9\n\n\n7\n\n\n8\n\n\n4\n\n\n\n\n\nThe first row (3 8 5 9 6 1 4 2 7) contains all digits from 1 to 9. Also the first column (3 9 1 5 7 2 4 8 6) contains all digits from 1 to 9, as does the first subblock (3 8 5 - 9 2 4 - 1 6 7) and all the other ones."
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#creating-the-widget",
    "href": "posts/a-custom-sudoku-widget/index.html#creating-the-widget",
    "title": "A Custom Sudoku Widget",
    "section": "Creating the widget",
    "text": "Creating the widget\nThere are two ways to create Jupyter widgets - an easy way and a more complicated way. For this post, we will be using the easy way, which involves creating two cells in a Jupyter notebook. The first cell contains the Python code for the back-end of the widget, while the second cell contains the JavaScript for the front-end.\nIf you want to create a proper Python package that can be installed with pip install, you can follow the more complicated way. A good resource is this tutorial.\nFor this post, we’ll stick with the easy way.\n\nThe Python back-end\nThe following code defines a Python class named Sudoku that extends the DOMWidget class from the ipywidgets library.\n\nfrom traitlets import Unicode, Bool, Int, List, validate, observe, TraitError, All\nfrom ipywidgets import DOMWidget, register\nimport copy\n\n@register\nclass Sudoku(DOMWidget):\n    _view_name = Unicode('SudokuView').tag(sync=True)\n    _view_module = Unicode('sudoku_widget').tag(sync=True)\n    _view_module_version = Unicode('0.1.0').tag(sync=True)\n    \n    # Attributes\n    fixed = List(trait=Bool(), default_value=[False] * 81, minlen=81, maxlen=81, help=\"A list of booleans that indicate whether a value is part of the puzzle.\").tag(sync=True)\n    _value = List(trait=Int(), default_value=[0] * 81, minlen=81, maxlen=81, help=\"A list of integers for each cell.\").tag(sync=True)\n    disabled = Bool(False, help=\"Enable or disable user changes.\").tag(sync=True)\n\n    # Basic validator for value\n    @validate('_value')\n    def _valid_value(self, proposal):\n        for i in proposal['value']:\n            if i &lt; 0 or i &gt; 9:\n                raise TraitError('Invalid value: all elements must be numbers from 0 to 9')\n        return proposal['value']\n    \n    @property\n    def value(self):\n        return copy.deepcopy(self._value)\n    \n    @value.setter\n    def value(self, v):\n        self._value = v\n\n    def __init__(self,*args,**kwargs):\n        kwargs['_value'] = kwargs.pop('value', [0]*81)\n        DOMWidget.__init__(self,*args,**kwargs)\n    \n    def __getitem__(self,index):\n        return self._value[index]\n    \n    \n    def __setitem__(self,index,val):\n        vals = self.value\n        vals[index] = val\n        self._value = vals\n\nThis Sudoku class has the following attributes:\n\nvalue: A list of integers that represents the current state of the puzzle.\nfixed: A list of booleans that indicates whether a value is part of the original puzzle and cannot be changed by the user.\ndisabled: A boolean that enables or disables user changes to the puzzle.\n\nThe fixed and value attributes are defined using the List trait from the traitlets library. The validate decorator is used to define a validator for the value attribute that checks that all elements are numbers from 0 to 9.\nThe __getitem__ and __setitem__ methods are implemented to allow indexing and assignment of elements in the value attribute.\nThe @register decorator registers the Sudoku class as an ipywidget, which allows it to be displayed and interacted with in a Jupyter environment.\n\n\nThe JavaScript front-end\nThe front-end contains a bit more code.\n\n%%javascript\nrequire.undef('sudoku_widget');\n\ndefine('sudoku_widget', [\"@jupyter-widgets/base\"], function(widgets) {\n    \n    // Define the SudokuView\n    class SudokuView extends widgets.DOMWidgetView {\n        \n        // Render the view.\n        render() {\n            this.sudoku_table = document.createElement('table');\n            this.sudoku_table.style.borderCollapse = 'collapse';\n            this.sudoku_table.style.marginLeft = '0';\n            \n            for (let i=0; i&lt;3; i++) {\n                let colgroup = document.createElement('colgroup');\n                colgroup.style.border = 'solid medium';\n                for (let j=0; j&lt;3; j++) {\n                    let col = document.createElement('col');\n                    col.style.border = 'solid thin';\n                    col.style.width = '2em';\n                    colgroup.appendChild(col);\n                }\n                this.sudoku_table.appendChild(colgroup);\n            }\n            \n            for (let t=0; t&lt;3; t++) {\n                let tbody = document.createElement('tbody');\n                tbody.style.border = 'solid medium';\n                for (let r=0; r&lt;3; r++) {\n                    let tr = document.createElement('tr');\n                    tr.style.height = '2em';\n                    tr.style.border = 'solid thin';\n                    for (let c=0; c&lt;9; c++) {\n                        let td = document.createElement('td');\n                        tr.appendChild(td);\n                    }\n                    tbody.appendChild(tr);\n                }\n                this.sudoku_table.appendChild(tbody);\n            }\n            \n            this.el.appendChild(this.sudoku_table);\n            \n            this.model_changed();\n        \n            // Python -&gt; JavaScript update\n            this.model.on('change', this.model_changed, this);\n        }\n\n        model_changed() {\n            let tds = this.sudoku_table.getElementsByTagName('td');\n            let disabled = this.model.get('disabled');\n                        \n            for (let i=0; i &lt; 81; i++) {\n                let td = tds[i];\n                td.innerText = ''; // Delete td contents\n                td.style.textAlign = 'center';\n                td.style.height = '2em';\n                let value = this.model.get('_value')[i];\n                let fixed = this.model.get('fixed')[i];\n\n                if (fixed && value &gt; 0) {\n                    let b = document.createElement('b');\n                    b.innerText = value;\n                    td.appendChild(b);\n                } else if (disabled && value &gt; 0) {\n                    td.innerText = value;\n                } else if (!disabled && !fixed) {\n                    let input = document.createElement('input');\n                    input.type = 'text';\n                    input.maxLength = 1;\n                    input.style.top = 0;\n                    input.style.left = 0;\n                    input.style.margin = 0;\n                    input.style.height = '100%';\n                    input.style.width = '100%';\n                    input.style.border = 'none';\n                    input.style.textAlign = 'center';\n                    input.style.marginTop = 0;\n                    input.style.padding = 0;\n                    input.value = (value &gt; 0 ? value : '');\n                    input.oninput = this.input_input.bind(this, i);\n                    input.onchange = this.input_changed.bind(this, i); // JavaScript -&gt; Python update\n                    td.appendChild(input);\n                }\n            }\n            \n        }\n        \n        input_input(i) {\n            this.sudoku_table.getElementsByTagName('td')[i].getElementsByTagName('input')[0].value = \n                this.sudoku_table.getElementsByTagName('td')[i].\n                    getElementsByTagName('input')[0].value.replace(/[^1-9]/g,'');\n        }\n        \n        input_changed(i) {\n            this.sudoku_table.getElementsByTagName('td')[i].getElementsByTagName('input')[0].value = \n                this.sudoku_table.getElementsByTagName('td')[i].\n                    getElementsByTagName('input')[0].value.replace(/[^1-9]/g,'');\n            let v = parseInt(this.sudoku_table.getElementsByTagName('td')[i].getElementsByTagName('input')[0].value) || 0;\n            let value = this.model.get('_value').slice();\n            value[i] = v;\n            this.model.set('_value', value);\n            this.model.save_changes();\n        }\n        \n    }\n\n    return {\n        SudokuView: SudokuView\n    }\n    \n});\n\n\n\n\n\nThe define function defines the sudoku_widget module, which depends on the @jupyter-widgets/base module. It creates a SudokuView class that extends the base class widgets.DOMWidgetView, which is responsible for rendering and updating the widget.\nThe render method of the SudokuView class creates a table element with 9 rows and 9 columns, representing the Sudoku game board. It adds the table to the widget’s HTML element, and registers a listener for model changes. The model_changed method is called when the model changes, and it updates the widget’s HTML to reflect the new model state.\nThe input_input and input_changed methods are event handlers that respond to user input on the Sudoku board. They update the model and the widget’s HTML to reflect the new user input."
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#how-to-use-this-widget",
    "href": "posts/a-custom-sudoku-widget/index.html#how-to-use-this-widget",
    "title": "A Custom Sudoku Widget",
    "section": "How to use this widget",
    "text": "How to use this widget\nOnce we have executed these two cells, we’re good to use our widget.\n\nimport ipywidgets as widgets\n\npuzzle = [\n    0,8,5, 0,6,1, 0,0,0,\n    9,0,4, 0,0,0, 0,0,0,\n    0,0,0, 0,0,2, 3,0,8,\n    \n    0,4,0, 0,0,0, 0,0,2,\n    7,0,0, 0,9,0, 5,0,0,\n    0,0,0, 0,3,0, 8,0,0,\n    \n    0,0,0, 0,5,8, 0,0,0,\n    0,0,0, 7,0,0, 0,1,0,\n    6,0,0, 0,0,0, 0,0,4]\n\nfixed_digits = [v &gt; 0 for v in puzzle]\n\nsudoku = Sudoku(value=puzzle, fixed=fixed_digits, disabled=False)\n\ndisplay(sudoku)\n\n\n\n\nThe widget accepts three parameters: value, fixed and disabled. The parameter value is a list of digits. A digit of 0 means empty. The parameter fixed is a list of boolean values, where True means a digit can’t be edited and will be printed in bold. The boolean disabled indicates whether a user can edit digits.\nOne can read the values in a grid like this:\n\nprint(sudoku.value)\n\n[0, 8, 5, 0, 6, 1, 0, 0, 0, 9, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 8, 0, 4, 0, 0, 0, 0, 0, 0, 2, 7, 0, 0, 0, 9, 0, 5, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 5, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 4]\n\n\nRunning the next cell would show the solution by updating the widget.\nsolution = [\n    3,8,5, 9,6,1, 4,2,7,\n    9,2,4, 8,7,3, 1,5,6,\n    1,6,7, 5,4,2, 3,9,8,\n    \n    5,4,3, 1,8,7, 9,6,2,\n    7,1,8, 2,9,6, 5,4,3,\n    2,9,6, 4,3,5, 8,7,1,\n\n    4,7,1, 6,5,8, 2,3,9,\n    8,3,9, 7,2,4, 6,1,5,\n    6,5,2, 3,1,9, 7,8,4]\n\nsudoku.value = solution"
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#creating-a-sudoku-solver",
    "href": "posts/a-custom-sudoku-widget/index.html#creating-a-sudoku-solver",
    "title": "A Custom Sudoku Widget",
    "section": "Creating a Sudoku solver",
    "text": "Creating a Sudoku solver\nNow that we have this widget to our disposal, we’ll create a Sudoku solver.\n\nBuilding the user interface\nFirst, let’s tackle the easy part: creating the user interface for our Sudoku solver. We’ll use the Sudoku widget along with some other widgets to make it easy for the user to select from pre-made puzzles or enter their own.\n\npuzzle1 = [\n    0,8,5, 0,6,1, 0,0,0,\n    9,0,4, 0,0,0, 0,0,0,\n    0,0,0, 0,0,2, 3,0,8,\n    \n    0,4,0, 0,0,0, 0,0,2,\n    7,0,0, 0,9,0, 5,0,0,\n    0,0,0, 0,3,0, 8,0,0,\n    \n    0,0,0, 0,5,8, 0,0,0,\n    0,0,0, 7,0,0, 0,1,0,\n    6,0,0, 0,0,0, 0,0,4]\n\npuzzle2 = [\n    3,6,0, 0,0,0, 0,0,5,\n    0,1,0, 0,9,0, 2,0,8,\n    0,5,0, 1,8,0, 0,0,7,\n    \n    5,0,0, 0,0,6, 4,0,0,\n    2,4,6, 0,5,0, 7,0,0,\n    0,0,0, 0,7,0, 0,0,0,\n    \n    0,0,0, 0,0,7, 1,0,3,\n    0,0,3, 9,4,0, 0,0,0,\n    0,0,0, 0,0,1, 0,0,0]\n\npuzzle3 = [\n    0,2,0, 0,4,0, 0,0,5,\n    0,5,8, 0,0,0, 0,0,0,\n    0,1,0, 8,0,0, 4,0,0,\n    \n    7,0,0, 0,0,8, 0,4,0,\n    0,0,1, 9,0,5, 7,0,0,\n    0,3,0, 7,0,0, 0,0,2,\n    \n    0,0,4, 0,0,3, 0,1,0,\n    0,0,0, 0,0,0, 9,6,0,\n    2,0,0, 0,1,0, 0,5,0\n]\n\nsudoku = Sudoku(value=puzzle1, fixed=[v &gt; 0 for v in puzzle1], disabled=False)\nexample_dropdown = widgets.Dropdown(\n    options=[('Empty', [0] * 81), ('Example 1', puzzle1), ('Example 2', puzzle2), ('Example 3', puzzle3)], \n    value=puzzle1,\n    layout=widgets.Layout(margin='10px 0px 0px 20px', width='150px')\n)\nsolve_button = widgets.Button(\n    description=\"Solve\", \n    layout=widgets.Layout(margin='20px 0px 0px 20px', width='150px')\n)\nnext_button = widgets.Button(\n    description=\"Next\", \n    layout=widgets.Layout(margin='20px 0px 0px 20px', width='150px', display='none')\n)\nvbox = widgets.VBox([example_dropdown, solve_button, next_button])\nhbox = widgets.HBox([sudoku, vbox])\nlabel = widgets.Label()\n\nThe Sudoku widget displays a Sudoku board.\nThere is also a Dropdown widget for selecting pre-made puzzles or an empty board, and two Button widgets for solving the puzzle and showing the next solution (if there are multiple solutions).\nFinally, there is a Label widget that can be used to display messages to the user. All of these widgets are arranged in a layout using VBox and HBox widgets.\n\n\nWriting the event handlers\nThe widgets are not functional on their own; we need to write code to make them responsive to user input.\n\n# global variables\ngen = None\nsolution = None\n\ndef on_example_dropdown_change(change):\n    if change['type'] == 'change' and change['name'] == 'value':\n        value = change['new']\n        fixed = [v &gt; 0 for v in value]\n        sudoku.value = value\n        sudoku.fixed = fixed\n        label.value = \"\"\n        solve_button.layout.display = 'inline-block'\n        next_button.layout.display = 'none'\n\nexample_dropdown.observe(on_example_dropdown_change)\n\ndef on_solve_button_clicked(b):\n    global gen\n    global solution\n    \n    val = sudoku.value.copy()\n    sudoku.fixed = [v &gt; 0 for v in val]\n    gen = solve_sudoku(val)\n    try:\n        solution = next(gen)\n        sudoku.value = solution\n    except StopIteration:\n        label.value = \"This sudoku has no solution.\"\n        sudoku.fixed = [False] * 81\n        return\n    \n    try:\n        solution = next(gen).copy()\n        label.value = \"This sudoku has multiple solutions.\"\n        solve_button.layout.display = 'none'\n        next_button.layout.display = 'inline-block'\n    except StopIteration:\n        label.value = \"\"\n        solve_button.layout.display = 'none'\n    \nsolve_button.on_click(on_solve_button_clicked)\n\ndef on_next_button_clicked(b):\n    global gen\n    global solution\n    \n    sudoku.value = solution\n    try:\n        solution = next(gen)\n    except StopIteration:\n        label.value = \"\"\n        next_button.layout.display = 'none'\n\nnext_button.on_click(on_next_button_clicked)\n\nThe on_example_dropdown_change function is called when the user selects an example puzzle from a dropdown menu, and it sets up the Sudoku grid with the selected puzzle and clears any previous solutions.\nThe on_solve_button_clicked function is called when the user clicks a button to solve the puzzle, and it generates a Sudoku solver object and attempts to find a solution to the puzzle. If a solution is found, it updates the Sudoku grid with the solution and enables a button to find the next solution if there are multiple solutions. If no solution is found, it displays an error message.\nThe on_next_button_clicked function is called when the user clicks the “next” button to find the next solution to a puzzle with multiple solutions, and it updates the Sudoku grid with the next solution if there is one, or disables the “next” button if there are no more solutions.\nThe gen and solution variables are used to keep track of the state of the Sudoku solver object and the next solution.\n\n\nThe solver\nWe can easily solve puzzles using backtracking. The solve_sudoku function utilizes recursion to generate solutions. It is called by the on_solve_button_clicked function above.\n\ndef solve_sudoku(puzzle, index=0):\n    if index == 81:\n        # Solution found\n        yield puzzle\n    elif puzzle[index] &gt; 0:\n        # Already filled\n        yield from solve_sudoku(puzzle, index + 1)\n    else:\n        for v in range(1,10):\n            # Fill in a digit and check constraints\n            puzzle[index] = v\n            if is_valid_square(puzzle, index):\n                yield from solve_sudoku(puzzle, index + 1)\n            puzzle[index] = 0\n\nThe solve_sudoku function takes in a puzzle parameter which is a list of length 81, representing the 9x9 Sudoku grid with empty squares represented as 0s. The function yields solutions as they are found.\nThe following functions are used to check the constraints.\n\ndef get_column(puzzle, k):\n    column = []\n    for i in range(9):\n        column.append(puzzle[i*9 + k])\n    return column\n\ndef get_row(puzzle, r):\n    return puzzle[r*9:(r+1)*9]\n\ndef get_block(puzzle, b):\n    block = []\n    for r in range(3):\n        for k in range(3):\n            block.append(puzzle[[0,3,6,27,30,33,54,57,60][b]+9*r+k])\n    return block\n\ndef is_valid(l):\n    # Check for duplicate values\n    digits = [v for v in l if v &gt; 0]\n    s = set(digits)\n    return len(digits) == len(s)\n\ndef is_valid_square(puzzle, i):\n    k = i % 9\n    r = int(i / 9)\n    b = int(r / 3) * 3 + int(k / 3)\n    \n    return is_valid(get_row(puzzle, r)) and is_valid(get_column(puzzle, k)) and is_valid(get_block(puzzle, b))\n\nThe get_column, get_row, and get_block functions are used to retrieve the values in the columns, rows, and 3x3 blocks that a given index belongs to.\nThe is_valid function checks if a list of values contains duplicate values. It returns True if the list contains no duplicates (excluding 0s) and False otherwise.\nThe is_valid_square function checks if a value can be placed in a given square of the Sudoku grid without violating the rules of the game. It uses the get_row, get_column, get_block, and is_valid functions.\n\n\nDisplaying the user interface\nIt’s time to show the user interface.\n\ndisplay(hbox, label)\n\n\n\n\n\n\n\nTo play with an interactive version, you’ll need to run it in Jupyter Notebook. Sadly, it won’t work in JupyterLab. It does work in Voilà in case you wish to turn it into a web app. The corresponding gist can be found here."
  },
  {
    "objectID": "posts/a-custom-sudoku-widget/index.html#conclusion",
    "href": "posts/a-custom-sudoku-widget/index.html#conclusion",
    "title": "A Custom Sudoku Widget",
    "section": "Conclusion",
    "text": "Conclusion\nIn this post, we saw how to create a custom widget in Jupyter Notebook. It’s worth noting that the approach I presented here is more of a quick fix. Originally, I developed this code as part of a Sudoku programming assignment for my students, and I had control over the environment they were using (Jupyter Notebook and Voila).\nFor creating Jupyter widgets, it is recommended to use widget-cookiecutter (for JavaScript) or widget-ts-cookiecutter (for TypeScript). These tools offer a more robust and reliable approach to building widgets in Jupyter."
  },
  {
    "objectID": "posts/dancing-queens/index.html",
    "href": "posts/dancing-queens/index.html",
    "title": "Dancing Queen(s)",
    "section": "",
    "text": "The n-queens problem is a puzzle that involves placing n queens on an n x n chessboard such that no two queens threaten each other. A queen can threaten another queen if they are in the same row, column, or diagonal. The objective is to find all possible ways to place n queens on the chessboard without any of them threatening each other.\nIn this post, we’ll explore how to solve the n-queens problem using Python and visualize solutions using Matplotlib. We’ll also see how to turn all solutions into an animation."
  },
  {
    "objectID": "posts/dancing-queens/index.html#importing-libraries",
    "href": "posts/dancing-queens/index.html#importing-libraries",
    "title": "Dancing Queen(s)",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe start by importing the necessary libraries. The Matplotlib library will be used to display the chessboard and queens.\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation\n\nfrom IPython.display import HTML\nfrom ipywidgets import widgets"
  },
  {
    "objectID": "posts/dancing-queens/index.html#the-solver",
    "href": "posts/dancing-queens/index.html#the-solver",
    "title": "Dancing Queen(s)",
    "section": "The solver",
    "text": "The solver\nThe code for the solver itself, consists of three functions: is_valid(), solve_n_queens_(), and solve_n_queens().\nThe is_valid() function takes three parameters: a board, a row, and a column. It checks if a queen can be placed at the given row and column on the board without attacking any other queen on the board. The function does this by iterating through each row before the current row and checking if a queen in that row attacks the given position.\nHere’s what the code for is_valid() looks like:\n\ndef is_valid(board, row, col):\n    for i in range(row):\n        if board[i] == col or row - i == abs(col - board[i]):\n            return False\n    return True\n\nThe solve_n_queens_() function takes two parameters: a board and a row. It solves the n-queens problem recursively by placing a queen at each row one by one. At each row, it checks if a queen can be placed at any of the columns on that row without attacking any other queen on the board. If a valid position is found, the function calls itself with the updated board and the next row. If no valid position is found, it backtracks to the previous row and tries the next column.\nThis is the code for solve_n_queens_():\n\ndef solve_n_queens_(board, row):\n    if row == len(board):\n        yield list(board)\n    else:\n        for col in range(len(board)):\n            if is_valid(board, row, col):\n                board[row] = col\n                yield from solve_n_queens_(board, row + 1)\n                board[row] = -1\n\nFinally, the solve_n_queens() function calls solve_n_queens_() with an empty board:\n\ndef solve_n_queens(n):\n    board = [-1] * n\n    yield from solve_n_queens_(board, 0)\n\nIn the three functions above, the board variable is a list that represents the chessboard. The board is initialized as a list of -1’s with a length of n. Each element in the list represents a column on the board, and the index of the element represents a row on the board. When a queen is placed on the board, its position is marked by setting the corresponding element in the board list to the column number of that queen.\nFor example, let’s say we have a 4x4 chessboard, and we place a queen at row 0 and column 1. We would represent this by setting board[0] = 1. The is_valid() function then checks if a queen can be placed at the given row and column on the board list without attacking any other queen on the board. If a valid position is found, the solve_n_queens_() function continues to the next row and updates the board list accordingly.\nIn case you didn’t know, the yield keyword turns the function into a generator that yields values as they are computed, rather than generating them all at once and returning them as a list or other collection. This makes it possible to produce each valid solution as it is found, rather than waiting until all solutions have been found and returning them all at once."
  },
  {
    "objectID": "posts/dancing-queens/index.html#function-to-display-a-solution",
    "href": "posts/dancing-queens/index.html#function-to-display-a-solution",
    "title": "Dancing Queen(s)",
    "section": "Function to display a solution",
    "text": "Function to display a solution\nThe following function takes an n-queens solution and an ax object as inputs and plots the solution on the given axes.\n\ndef plot_n_queens_solution(solution, ax):\n    # Define the colors of the squares\n    light_color = \"#F0D9B5\"\n    dark_color = \"#B58863\"\n\n    board_size = len(solution)\n    \n    # Draw the squares\n    for i in range(board_size):\n        for j in range(board_size):\n            if (i + j) % 2 == 0:\n                color = light_color\n            else:\n                color = dark_color\n            ax.add_patch(plt.Rectangle((i, j), 1, 1, color=color))\n\n    # Draw the pieces on the board\n    for y, x in enumerate(solution):\n        ax.text(x+0.5, y+0.5, \"♛\", ha=\"center\", va=\"center\", fontsize=240/board_size, color=\"black\")\n\n    # Set the aspect ratio to \"equal\"\n    ax.set_aspect('equal')\n\n    # Set the x and y limits to show the whole board\n    ax.set_xlim(0, board_size)\n    ax.set_ylim(0, board_size)\n\n    # Remove the tick labels\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    # Flip the y-axis\n    ax.invert_yaxis()"
  },
  {
    "objectID": "posts/dancing-queens/index.html#display-all-solutions",
    "href": "posts/dancing-queens/index.html#display-all-solutions",
    "title": "Dancing Queen(s)",
    "section": "Display all solutions",
    "text": "Display all solutions\nNow, let’s combine the solver with the code that displays a solution.\n\ndef plot_all_n_queens_solutions(board_size):\n    for solution in solve_n_queens(board_size):\n        fig, ax = plt.subplots()\n        plot_n_queens_solution(solution, ax)\n        plt.show()\n\nThis function uses the solve_n_queens function to generate all valid solutions to the n-queens puzzle of size board_size. It then loops over each solution, creating a new plot for each one using the plt.subplots() function, and then calling the plot_n_queens_solution function to plot the solution onto the plot. Finally, the plot is displayed using plt.show(). This process is repeated for each solution, resulting in all valid solutions being displayed as individual plots.\nNow, let’s call this function to generate and display all valid solutions to the n-queens puzzle of size 4.\n\nplot_all_n_queens_solutions(4)\n\n\n\n\n\n\n\nIn this case we find only two valid solution."
  },
  {
    "objectID": "posts/dancing-queens/index.html#show-solutions-one-by-one",
    "href": "posts/dancing-queens/index.html#show-solutions-one-by-one",
    "title": "Dancing Queen(s)",
    "section": "Show solutions one by one",
    "text": "Show solutions one by one\nIf the board size is larger, plotting all possible solutions would take up a lot of space. To address this issue, the following code generates widgets that enable you to choose a board size and iterate through the solutions.\nWe start by creating a user interface with a dropdown menu, a button, an output widget, and a label widget using the Python widgets module.\n\nboard_size_dropdown = widgets.Dropdown(options=list(range(1,21)), value=8, description=\"Board size: \")\nnext_button = widgets.Button(description=\"Next\")\nhbox = widgets.HBox([board_size_dropdown, next_button])\noutput = widgets.Output()\nlabel = widgets.Label()\n\ndisplay(hbox, output, label)\n\n\n\n\n\n\n\n\n\n\nWe declare the following global variables:\n\ngen = None\nsolution = None\n\nThe gen is a generator object that generates solutions for a given board size using the solve_n_queens function. The solution variable stores the next solution to be displayed in the output widget. It is updated each time the “Next” button is clicked to display the next solution in the generator.\n\ndef on_board_size_dropdown_change(change):\n    global gen\n    global solution\n    \n    if change['type'] == 'change' and change['name'] == 'value':\n        value = change['new']\n        next_button.layout.display = 'none'\n        \n        output.clear_output()\n        \n        gen = solve_n_queens(value)\n        try:\n            solution = next(gen)            \n            with output:\n                fig, ax = plt.subplots()\n                plot_n_queens_solution(solution, ax)\n                plt.show()\n        except StopIteration:\n            label.value = \"No solutions found.\"\n            return\n\n        try:\n            solution = next(gen).copy()\n            label.value = \"\"\n            next_button.layout.display = 'inline-block'\n        except StopIteration:\n            label.value = \"\"\n\nboard_size_dropdown.observe(on_board_size_dropdown_change)\n\nThe on_board_size_dropdown_change function handles changes to the board size dropdown menu. It clears the output widget, displays the first solution (if any), and stores the next solution in the solution variable (if any).\n\ndef on_next_button_clicked(b):\n    global gen\n    global solution\n    \n    output.clear_output(wait=True)\n    with output:\n        fig, ax = plt.subplots()\n        plot_n_queens_solution(solution, ax)\n        plt.show()\n    \n    try:\n        solution = next(gen)\n    except StopIteration:\n        label.value = \"\"\n        next_button.layout.display = 'none'\n\nnext_button.on_click(on_next_button_clicked)\n\non_board_size_dropdown_change({'type': 'change', 'name': 'value', 'new': board_size_dropdown.value})\n\nThe on_next_button_clicked function handles clicks on the “Next” button by clearing the output widget, displaying the current solution, and generating the next solution."
  },
  {
    "objectID": "posts/dancing-queens/index.html#create-a-matplotlib-animation-that-shows-all-solutions",
    "href": "posts/dancing-queens/index.html#create-a-matplotlib-animation-that-shows-all-solutions",
    "title": "Dancing Queen(s)",
    "section": "Create a Matplotlib animation that shows all solutions",
    "text": "Create a Matplotlib animation that shows all solutions\nAnother thing we can do is animate all solutions. We first set up the necessary functions and objects for later use in creating an animation.\n\nfig, ax = plt.subplots()\n\ndef gen_func(n):\n    def generator():\n        yield from solve_n_queens(n)\n    return generator\n\ndef animate(solution):\n    ax.clear()\n    plot_n_queens_solution(solution, ax)\n\nplt.close()\n\nWe can then create an animation of the n-queens problem using the matplotlib.animation module and display it.\n\nboard_size = 8\n\nanim = matplotlib.animation.FuncAnimation(fig, animate, frames=gen_func(board_size), save_count=999999999999)\nHTML(anim.to_jshtml(default_mode='once'))\n\n\n\n\n\n\n\n\n  \n  \n    \n    \n      \n          \n      \n        \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n      \n          \n    \n    \n      \n      Once\n      \n      Loop\n      \n      Reflect\n    \n  \n\n\n\n\n\n\nTo fully enjoy the animation, it is recommended to listen to ABBA’s song Dancing Queen in the background.\nI originally created this code to teach my students about the concept of backtracking. I hope it will be helpful for you as well.\nUse one of the following links to play with an interactive version:"
  },
  {
    "objectID": "posts/icosian-game/index.html",
    "href": "posts/icosian-game/index.html",
    "title": "Icosian Game",
    "section": "",
    "text": "The Irish mathematician William Rowan Hamilton is probably best known for discovering quaternions. He is also the inventor of the Icosian game.\nIn this blog post I’ll describe the game and share some Prolog code for solving it."
  },
  {
    "objectID": "posts/icosian-game/index.html#how-to-play-the-icosian-game",
    "href": "posts/icosian-game/index.html#how-to-play-the-icosian-game",
    "title": "Icosian Game",
    "section": "How to play the Icosian game",
    "text": "How to play the Icosian game\nThe game’s objective is to find a path around a dodecahedron such that every vertex is visited once, no edge is visited multiple times, and the path ends in de same vertex it started from. Instead of using a 3d dodecahedron, the game was distributed as a pegboard with holes at the vertices of the 2d dodecahedral graph.\n\n\n\nOne of the few remaining copies (from the collection of the puzzle museum)\n\n\nThe game was meant to be played by two people. The first player would set up the challenge by placing the first five pegs in any five consecutive holes and then the second player would be required to place the remaining fifteen pegs consecutively in such a way that the succession would be cyclical."
  },
  {
    "objectID": "posts/icosian-game/index.html#some-graph-theory",
    "href": "posts/icosian-game/index.html#some-graph-theory",
    "title": "Icosian Game",
    "section": "Some graph theory",
    "text": "Some graph theory\nIn graph theory, a path that visits every vertex of a graph once is now known as a Hamiltonian path. A path that visits every vertex once and that ends in the same vertex as it started off from is called a Hamiltonian cycle. So playing this game is essentially searching for a Hamiltonian cycle in the dodecahedral graph."
  },
  {
    "objectID": "posts/icosian-game/index.html#solving-this-game-using-prolog",
    "href": "posts/icosian-game/index.html#solving-this-game-using-prolog",
    "title": "Icosian Game",
    "section": "Solving this game using Prolog",
    "text": "Solving this game using Prolog\nThe Icosian game was never a commercial success, probably because it’s too easy. I wrote some Prolog code to solve this game and explore possible solutions.\n\n\nicosian.pl\n\n% A Prolog solver for the Icosian game\n% https://en.wikipedia.org/wiki/Icosian_game\n\nicosian_puzzle_edges([\n    (b,c), (b,g), (b,z), (c,d), (c,p), (d,f), (d,m), (f,g), (f,k), (g,h), \n    (h,j), (h,x), (j,k), (j,v), (k,l), (l,t), (l,m), (m,n), (n,p), (n,s), \n    (p,q), (q,z), (q,r), (r,s), (r,w), (s,t), (t,v), (v,w), (w,x), (x,z)\n]).\n\nconnected(Adj,P,Q) :- member((P,Q),Adj); member((Q,P),Adj).\n\ngraph_order(Adj,N) :- \n    findall(A,connected(Adj,A,_),B0), \n    sort(B0,B), \n    length(B,N). \n\nhamiltonian_cycle(Adj,[Start|TourRest]) :-\n    graph_order(Adj,N),\n    append([[Start],MidTour,[Start]],[Start|TourRest]),\n    length([Start|MidTour],N),\n    hamiltonian_cycle(Adj,Start,MidTour,[Start]).\n\nhamiltonian_cycle(Adj,Start,[],[LastVisited|_]) :-\n    connected(Adj,LastVisited,Start).\nhamiltonian_cycle(Adj,Start,[Head|Tail],[VisitedHead|VisitedTail]) :-\n    connected(Adj,VisitedHead,Head),\n    not(member(Head,[VisitedHead|VisitedTail])),\n    hamiltonian_cycle(Adj,Start,Tail,[Head,VisitedHead|VisitedTail]).\n\nprint_icosian_puzzle :- print_icosian_solution([]).\n\nedge_in_tour(P,Q,Tour) :-\n    append([_,[P,Q],_],Tour);\n    append([_,[Q,P],_],Tour).\n\nformat_edge(P,Q,Tour,Atom,Out) :-\n    edge_in_tour(P,Q,Tour),\n    format(atom(Out),'\\e[31m~w\\e[0m',[Atom]), !.\nformat_edge(_P,_Q,_Tour,Atom,Atom).\n\nprint_icosian_solution(Tour) :-\n    findall(F,(member((P,Q,A),[\n        (b,c,'-'), (b,g,'/'), (b,z,'\\\\'), (c,d,'\\\\'), (c,p,'/'), \n        (d,f,'/'), (d,m,'\\\\'), (f,g,'\\\\'), (f,k,'|'), (g,h,'/'),\n        (h,j,'\\\\'), (h,x,'\\\\'), (j,k,'/'), (j,v,'/'), (k,l,'\\\\'),\n        (l,t,'\\\\'), (l,m,'/'), (m,n,'/'), (n,p,'\\\\'), (n,s,'---'),\n        (p,q,'\\\\'), (q,z,'/'), (q,r,'|'), (r,s,'\\\\'), (r,w,'/'),\n        (s,t,'/'), (t,v,'-------'), (v,w,'\\\\'), (w,x,'---'), (x,z,'/')\n    ]),format_edge(P,Q,Tour,A,F)),[BC,BG,BZ,CD,CP,DF,DM,FG,FK,GH,\n        HJ,HX,JK,JV,KL,LT,LM,MN,NP,NS,PQ,QZ,QR,RS,RW,ST,TV,VW,WX,XZ]),\n    format('            R',[]), nl,\n    format('           ~w~w~w',[RW,QR,RS]), nl,\n    format('          ~w ~w ~w',[RW,QR,RS]), nl,\n    format('         ~w  ~w  ~w',[RW,QR,RS]), nl,\n    format('        ~w   Q   ~w',[RW,RS]), nl,\n    format('       ~w   ~w ~w   ~w',[RW,QZ,PQ,RS]), nl,\n    format('      ~w   ~w   ~w   ~w',[RW,QZ,PQ,RS]), nl,\n    format('     ~w   Z     P   ~w',[RW,RS]), nl,\n    format('    ~w   ~w ~w   ~w ~w   ~w',[RW,XZ,BZ,CP,NP,RS]), nl,\n    format('   ~w   ~w   B~wC   ~w   ~w',[RW,XZ,BC,NP,RS]), nl,\n    format('  ~w   ~w   ~w   ~w   ~w   ~w',[RW,XZ,BG,CD,NP,RS]), nl,\n    format(' ~w   ~w   G     D   ~w   ~w',[RW,XZ,NP,RS]), nl,\n    format('W~wX   ~w ~w   ~w ~w   N~wS',[WX,GH,FG,DF,DM,NS]), nl,\n    format(' ~w   ~w ~w   ~w ~w   ~w ~w   ~w',[VW,HX,GH,FG,DF,DM,MN,ST]), nl,\n    format('  ~w   H     F     M   ~w',[VW,ST]), nl,\n    format('   ~w   ~w    ~w    ~w   ~w',[VW,HJ,FK,LM,ST]), nl,\n    format('    ~w   ~w   K   ~w   ~w',[VW,HJ,LM,ST]), nl,\n    format('     ~w   ~w ~w ~w ~w   ~w',[VW,HJ,JK,KL,LM,ST]), nl,\n    format('      ~w   J   L   ~w',[VW,ST]), nl,\n    format('       ~w ~w     ~w ~w',[VW,JV,LT,ST]), nl,\n    format('        V~wT',[TV]), nl.\n\nsolve_icosian_puzzle :-\n    icosian_puzzle_edges(Adj), \n    hamiltonian_cycle(Adj,Tour), \n    print_icosian_solution(Tour).\n\nThe icosian_puzzle_edges/1 predicate defines the graph by specifying a list of edges between vertices. This list is used by the connected/3 predicate which checks whether there is an edge between two vertices.\nThe hamiltonian_cycle/2 predicate defines the main algorithm for finding a Hamiltonian cycle on the graph, given a starting vertex. After determining the number of vertices in the graph, it recursively tries to find a cycle that visits each vertex exactly once.\nThe print_icosian_solution/1 predicate prints out the solution to the Icosian game, highlighting the edges in the Hamiltonian cycle found by the hamiltonian_cycle/2 predicate.\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/icosian-game/index.html#how-to-use-this-code",
    "href": "posts/icosian-game/index.html#how-to-use-this-code",
    "title": "Icosian Game",
    "section": "How to use this code",
    "text": "How to use this code\nTo use this program, open the icosian.pl file in your preferred Prolog interpreter (I always use SWI-Prolog). Entering solve_icosian_puzzle. and pressing ; repeatedly will yield possible solutions.\n\nSuppose you want to explore how the cycle that starts with the vertices Q, R, S, N, P could be continued, you would enter:\nicosian_puzzle_edges(Adj), Tour = [q,r,s,n,p|Rest], hamiltonian_cycle(Adj,Tour), print_icosian_solution(Tour).\nThis game might remind you of the Travelling Salesman Problem (TSP). Finding a Hamiltonian cycle can be considered a special case of the TSP, namely, one where each pair of vertices with an edge between them has distance 1, while vertex pairs without an edge between them are separated by a distance of infinity."
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html",
    "href": "posts/from-baby-face-to-neanderthal/index.html",
    "title": "From Baby Face to Neanderthal",
    "section": "",
    "text": "Earlier this year, I embarked on the famous pilgrimage Camino de Santiago, walking from my hometown Leeuwarden in the north of the Netherlands all the way to Santiago de Compostela. For three months, I lived out of a backpack and primarily engaged in wild-camping along the trail. Throughout my journey, I visited some of the most awe-inspiring places, met incredible people along the way, and created unforgettable memories that I will cherish forever.\nI didn’t want people to think I was just on a huge camping trip to get away from the daily grind, so I told them it was a pilgrimage of “spiritual growth” and “self-discovery”. Some just scoffed, others thought I was losing my mind. To convince my less-enlightened friends that this wasn’t just a three-month hike to nowhere, I took a selfie every day to document my, ehm, transcendence.\nIn this post I’ll show how I turned these daily selfies into a time-lapse video using MediaPipe and OpenCV."
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#import-libraries",
    "href": "posts/from-baby-face-to-neanderthal/index.html#import-libraries",
    "title": "From Baby Face to Neanderthal",
    "section": "Import libraries",
    "text": "Import libraries\nWe start by importing the necessary libraries. We use MediaPipe to detect face landmarks and OpenCV to scale and translate the images to align them with each other.\n\nimport cv2\nimport os\nimport glob\nimport itertools\n\nimport numpy as np\nimport pandas as pd\nimport mediapipe as mp\nimport matplotlib.pyplot as plt\n\nfrom os import listdir\nfrom os.path import isfile, join"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#about-mediapipe",
    "href": "posts/from-baby-face-to-neanderthal/index.html#about-mediapipe",
    "title": "From Baby Face to Neanderthal",
    "section": "About MediaPipe",
    "text": "About MediaPipe\nMediaPipe is a framework developed by Google that bundles several ML solutions to process images and video. The Face Mesh component estimates 468 3D face landmarks. Below I show how this component can be used.\nWe first load an image using the OpenCV 2 library and plot it using Matplotlib.\n\nFILENAME = \"selfie.jpg\"\nimage = cv2.imread(FILENAME)\n\nplt.figure(figsize=(10, 10))\nplt.title(\"Original\")\nplt.axis('off')\nplt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\nplt.show()\n\n\n\n\nThen we find the landmarks and draw a mesh on the image.\n\nmp_drawing = mp.solutions.drawing_utils\nmp_drawing_styles = mp.solutions.drawing_styles\nmp_face_mesh = mp.solutions.face_mesh\ndrawing_spec = mp_drawing.DrawingSpec(thickness=1, circle_radius=1)\n\nwith mp_face_mesh.FaceMesh(static_image_mode=True, \n            max_num_faces=1, refine_landmarks=True, min_detection_confidence=0.5) as face_mesh:\n    image = cv2.imread(FILENAME)\n    results = face_mesh.process(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\n\n    # draw face mesh landmarks on the image.\n    for face_landmarks in results.multi_face_landmarks:\n        mp_drawing.draw_landmarks(image=image, landmark_list=face_landmarks, \n            connections=mp_face_mesh.FACEMESH_TESSELATION, landmark_drawing_spec=None,\n            connection_drawing_spec=mp_drawing_styles.get_default_face_mesh_tesselation_style())\n        mp_drawing.draw_landmarks(image=image,\n            landmark_list=face_landmarks, connections=mp_face_mesh.FACEMESH_CONTOURS, landmark_drawing_spec=None, \n            connection_drawing_spec=mp_drawing_styles.get_default_face_mesh_contours_style())\n        mp_drawing.draw_landmarks(image=image, landmark_list=face_landmarks,\n            connections=mp_face_mesh.FACEMESH_IRISES, landmark_drawing_spec=None,\n            connection_drawing_spec=mp_drawing_styles.get_default_face_mesh_iris_connections_style())\n\nINFO: Created TensorFlow Lite XNNPACK delegate for CPU.\n\n\nAnd show the result.\n\nplt.figure(figsize=(10,10))\nplt.title(\"Result\")\nplt.axis('off')\nplt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\nplt.show()"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#selecting-landmarks",
    "href": "posts/from-baby-face-to-neanderthal/index.html#selecting-landmarks",
    "title": "From Baby Face to Neanderthal",
    "section": "Selecting landmarks",
    "text": "Selecting landmarks\nWe’re only interested in a few specific landmarks to figure out how to scale and translate images so that they can be stitched together into a time-lapse video. More specifically, we are interested in the landmarks corresponding to the nose and the left- and rightmost points of the face. The landmark that corresponds with the tip of the nose is used to align images. The left- and rightmost landmarks are used to determine how much to scale them.\nThe index numbers for the different landmarks can be found in this image.\nWe define some constants including the indexes of the landmarks we’re interested in. You can experiment with the FPS parameter that tells you how many different frames will be shown per second.\nIMG_PATH = \"selfies/\" # the input directory\nOUTPUT_PATH = \"output/\" # also used for temporary files\nVIDEO_NAME = 'video.avi' # the output filename\nFPS = 3 # frames per second\n\nNOSE_TIP_LANDMARK = 1\nLEFTMOST_LANDMARK = 234\nRIGHTMOST_LANDMARK = 454"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#clearing-old-files",
    "href": "posts/from-baby-face-to-neanderthal/index.html#clearing-old-files",
    "title": "From Baby Face to Neanderthal",
    "section": "Clearing old files",
    "text": "Clearing old files\nTo start, we’ll delete all files in OUTPUT_PATH that might still be there from previous runs.\nfiles = glob.glob(os.path.join(OUTPUT_PATH, \"*\"))\nfor f in files:\n    os.remove(f)"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#defining-helper-functions",
    "href": "posts/from-baby-face-to-neanderthal/index.html#defining-helper-functions",
    "title": "From Baby Face to Neanderthal",
    "section": "Defining helper functions",
    "text": "Defining helper functions\nWe need to define a couple of helper functions.\nMediapipe landmarks are defined as 3D coordinates. The following function converts a landmark into a 2D pixel coordinate.\n\ndef to_pixel_coord(image, landmark):\n    # convert landmark to pixel coordinates\n    [height, width, _] = image.shape\n    return int(landmark.x * width), int(landmark.y * height)\n\nAnother function loops through all files in a directory and tries to determine the landmarks’ pixel coordinates. The result is returned as a Pandas dataframe.\n\ndef read_landmarks(path):\n    # find all files in directory\n    filenames = [f for f in listdir(path) if isfile(join(path, f))]\n    filenames.sort()\n    \n    # create an empty dataframe\n    columns = {\n        \"file\": str(), \n        \"nose_tip_x\": int(), \"nose_tip_y\": int(), \n        \"leftmost_x\": int(), \"leftmost_y\": int(), \n        \"rightmost_x\": int(), \"rightmost_y\": int(),\n        \"width\": int(), \"height\": int()\n    }\n    df = pd.DataFrame(columns, index=[])\n    \n    # find the landmarks' pixel coordinates\n    with mp_face_mesh.FaceMesh(static_image_mode=True, \n                max_num_faces=1, refine_landmarks=True, \n                min_detection_confidence=0.5) as face_mesh:\n        for file in filenames:\n            image = cv2.imread(os.path.join(path, file))\n            results = face_mesh.process(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))\n\n            if not len(results.multi_face_landmarks) == 1:\n                # detected less or more than one face -&gt; skip image\n                continue\n            face_landmarks = results.multi_face_landmarks[0]\n            nose_tip_x, nose_tip_y = to_pixel_coord(image, face_landmarks.landmark[NOSE_TIP_LANDMARK])\n            leftmost_x, leftmost_y = to_pixel_coord(image, face_landmarks.landmark[LEFTMOST_LANDMARK])\n            rightmost_x, rightmost_y = to_pixel_coord(image, face_landmarks.landmark[RIGHTMOST_LANDMARK])\n            [height, width, _] = image.shape\n            landmarks_xy = [file, nose_tip_x, nose_tip_y, leftmost_x, leftmost_y, rightmost_x, rightmost_y, width, height]\n            df = pd.concat([df, pd.DataFrame([landmarks_xy], columns=list(columns.keys()))], ignore_index=True)\n    \n    return df\n\nWe also need a function to scale images.\n\ndef scale_image(filename_input, filename_output, factor):\n    # read image from disk\n    image = cv2.imread(filename_input)\n    \n    (height, width) = image.shape[:2]\n\n    res = cv2.resize(image, (int(width * factor), int(height * factor)), interpolation=cv2.INTER_CUBIC)\n  \n    # write image back to disk.\n    cv2.imwrite(filename_output, res)\n\nThe next function translates an image. Translating an image means shifting it within a given frame of reference.\n\ndef translate_image(filename_input, filename_output, x, y):\n    # if the shift is (x, y) then the translation matrix would be\n    # M = [1 0 x]\n    #     [0 1 y]\n    M = np.float32([[1, 0, x], [0, 1, y]])\n    \n    # read image from disk.\n    image = cv2.imread(filename_input)\n    (rows, cols) = image.shape[:2]\n  \n    # warpAffine does appropriate shifting given the translation matrix.\n    res = cv2.warpAffine(image, M, (cols, rows))\n  \n    # write image back to disk.\n    cv2.imwrite(filename_output, res)"
  },
  {
    "objectID": "posts/from-baby-face-to-neanderthal/index.html#processing-the-images",
    "href": "posts/from-baby-face-to-neanderthal/index.html#processing-the-images",
    "title": "From Baby Face to Neanderthal",
    "section": "Processing the images",
    "text": "Processing the images\nNow we can process our collection of selfies. This means finding landmarks, scaling, and translating images so that they align properly.\n\nFinding landmarks\nWe can just call the function we define before.\ndf = read_landmarks(IMG_PATH)\n\n\nScaling images\nBy rescaling the images we make the face in each photo of similar size.\nWe first determine the mean size of the face.\nmean_face_size = int(df.rightmost_x.mean()) - int(df.leftmost_x.mean())\nAfter finding the mean face size, we rescale each image to match this.\nfor _, row in df.iterrows():\n    filename = row['file']\n    face_size = row['rightmost_x'] - row['leftmost_x']\n    scale_image(os.path.join(IMG_PATH, filename), os.path.join(OUTPUT_PATH, filename), mean_face_size / face_size)\nAfter rescaling, we need to find the landmarks again as they have changed.\ndf = read_landmarks(OUTPUT_PATH)\n\n\nTranslating images\nIn this step we find the average location of the tip of the nose. Then we translate all images so that the tips of the noses align. We keep track of how much an image is maximally shifted in the horizontal or vertical direction so we can properly crop the images later.\nmean_x = int(df.nose_tip_x.mean())\nmean_y = int(df.nose_tip_y.mean())\ncrop_left = 0\ncrop_right = 0\ncrop_top = 0\ncrop_bottom = 0\nfor _, row in df.iterrows():\n    filename = row['file']\n    shift_x = mean_x - row['nose_tip_x']\n    shift_y = mean_y - row['nose_tip_y']\n    translate_image(os.path.join(OUTPUT_PATH, filename), os.path.join(OUTPUT_PATH, filename), shift_x, shift_y)\n    \n    if shift_x &gt; 0 and shift_x &gt; crop_left:\n        crop_left = shift_x\n    elif shift_x &lt; 0 and abs(shift_x) &gt; crop_right:\n        crop_right = abs(shift_x)\n    elif shift_y &gt; 0 and shift_y &gt; crop_top:\n        crop_top = shift_y\n    elif shift_y &lt; 0 and abs(shift_y) &gt; crop_bottom:\n        crop_bottom = abs(shift_y)\n\n\nCropping images\nBecause of translating we ended up with images with black bars on the sides. We crop images so that these disappear. This way we end up with images that are a bit smaller.\nmin_width = df.width.min()\nmin_height = df.height.min()\n\nfor _, row in df.iterrows():\n    filename = row['file']\n    image = cv2.imread(os.path.join(OUTPUT_PATH, filename))\n    (rows, cols) = image.shape[:2]\n    res = image[crop_top:min_height, crop_left:min_width]\n    cv2.imwrite(os.path.join(OUTPUT_PATH, filename), res)"
  },
  {
    "objectID": "posts/blocbirds/index.html",
    "href": "posts/blocbirds/index.html",
    "title": "BLOCBIRDS",
    "section": "",
    "text": "A few years ago, I visited the BLOCBIRDS exhibition while it was on display at the Frisian Museum of Natural History. The exhibition featured 25 compositions, each one inspired by different bird species and crafted entirely from rectangular shapes.\nEach composition represents the colors and proportions of a bird’s plumage. Take for example the composition based on the Bluethroat bird species.\nIn this blog post, we’ll explore how to use machine learning to create similar avian-inspired art."
  },
  {
    "objectID": "posts/blocbirds/index.html#importing-libraries",
    "href": "posts/blocbirds/index.html#importing-libraries",
    "title": "BLOCBIRDS",
    "section": "Importing libraries",
    "text": "Importing libraries\nWe’ll start by importing some libraries.\n\nfrom PIL import Image\nfrom rembg import remove\nfrom IPython.display import display, clear_output\nfrom sklearn.cluster import KMeans\n\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nimport numpy as np\nimport squarify\nimport random\n\nThe rembg module implements U²-Net, a neural network architecture that performs Salient Object Detection. Salient object detection is a computer vision technique that aims to identify the most visually significant objects or regions in an image. We will use it to separate the bird we’re interested in from the background.\nWe will use KMeans to extract the color palette. The squarify module is needed to plot the artwork."
  },
  {
    "objectID": "posts/blocbirds/index.html#loading-an-image-and-removing-the-background",
    "href": "posts/blocbirds/index.html#loading-an-image-and-removing-the-background",
    "title": "BLOCBIRDS",
    "section": "Loading an image and removing the background",
    "text": "Loading an image and removing the background\nWe’ll start by loading an image of the Spangled cotinga which I got from here.\n\nimage = Image.open(\"spangled-continga.jpg\")\nimage\n\n\n\n\nTo create a BLOCBIRDS-like artwork based on this image of this colorful bird, we need to extract its color palette while excluding the background. We can achieve this by utilizing the aforementioned rembg module, which allows us to remove the background and focus solely on the bird’s plumage. The algorithm makes all irrelevant pixels transparent.\n\nimage = remove(image)\nimage\n\n\n\n\nNotice how it even removes the branch the bird was perching on."
  },
  {
    "objectID": "posts/blocbirds/index.html#extracting-the-palette",
    "href": "posts/blocbirds/index.html#extracting-the-palette",
    "title": "BLOCBIRDS",
    "section": "Extracting the palette",
    "text": "Extracting the palette\nK-means clustering can be used to extract dominant colors from an image. The idea is to group the pixels of the image into k clusters based on their color similarity. The algorithm then computes the average color of each cluster and assigns it as the representative color for that cluster. These representative colors can be used to create a color palette for the image.\n\nGetting the pixels\nWe first need to extract the pixels from our image. To do this we first convert the PIL image to a numpy array.\n\nnp_image = np.array(image)\n\nThis numpy array will have the same dimensions as the image. Next we select all pixels that aren’t transparent.\n\nh, w, d = np_image.shape\nif d == 4:\n    pixels = np_image[np_image[:,:,3] == 255]\n    pixels = pixels[:,:3]\nelse:\n    pixels = np_image.reshape((h * w, d))\n\n\n\nDetermining the colors\nBefore applying k-means clustering, we must determine the number of clusters, denoted by k, that we want to generate. This value represents the desired number of colors in the final palette. In this case, we will use 12 clusters or colors, although determining the ideal number is a matter of taste and some experimentation.\n\nn_clusters = 12\n\nOnce we have defined these parameters, we can apply the k-means algorithm to the pixel data of the image. Euclidean distance is used as a distance metric.\n\n# cluster pixels\nclt = KMeans(n_clusters=n_clusters, n_init='auto')\nclt.fit(pixels)\n\nKMeans(n_clusters=12, n_init='auto')In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.KMeansKMeans(n_clusters=12, n_init='auto')\n\n\nThe algorithm iteratively assigns each pixel to the nearest cluster center, updates the cluster centers based on the new pixel assignments, and repeats this process until convergence. At convergence, we have the k cluster centers or centroids which represent the dominant colors in the image.\nTo translate these centroids to actual colors we use a helper function.\n\ndef rgb_to_hex(r, g, b):\n    return \"#{:02x}{:02x}{:02x}\".format(r, g, b)\n\nWe then extract all colors and also the number of pixels that fall within that cluster.\n\ncolors = [rgb_to_hex(int(r), int(g), int(b)) for r, g, b in clt.cluster_centers_]\n_, sizes = np.unique(clt.labels_, return_counts=True)"
  },
  {
    "objectID": "posts/blocbirds/index.html#plotting-our-art",
    "href": "posts/blocbirds/index.html#plotting-our-art",
    "title": "BLOCBIRDS",
    "section": "Plotting our art",
    "text": "Plotting our art\nFinally, we can use these extracted colors and number of pixels per color to plot our artwork.\n\nfig, ax = plt.subplots(figsize=(7,7))\nsquarify.plot(sizes=sizes, color=colors, ax=ax)\nax.axis('off')\nplt.show()\n\n\n\n\nBeautiful! Wouldn’t you agree?"
  },
  {
    "objectID": "posts/blocbirds/index.html#customizing-the-composition",
    "href": "posts/blocbirds/index.html#customizing-the-composition",
    "title": "BLOCBIRDS",
    "section": "Customizing the composition",
    "text": "Customizing the composition\nThe way the squarify function plots the rectangles is influenced by the order of elements in the colors and sizes lists. By shuffling these two lists, we can experiment with different compositions.\n\nsquares = list(zip(sizes, colors))\nrandom.shuffle(squares)\nshuffled_sizes, shuffled_colors = zip(*squares)\n\nNow, we can visualize a new composition based on these shuffled lists.\n\nfig, ax = plt.subplots(figsize=(7,7))\nsquarify.plot(sizes=shuffled_sizes, color=shuffled_colors, ax=ax)\nax.axis('off')\nplt.show()"
  },
  {
    "objectID": "posts/blocbirds/index.html#splitting-up-the-rectangles",
    "href": "posts/blocbirds/index.html#splitting-up-the-rectangles",
    "title": "BLOCBIRDS",
    "section": "Splitting up the rectangles",
    "text": "Splitting up the rectangles\nIn our plots every color gets represented by exactly one rectangle. In the BLOCBIRDS` compositions multiple rectangles can have the same color. To play around with this we can create a set of sliders, one for each color and use these to set the number of rectangles that a color can use.\n\nsliders = [widgets.IntSlider(value=1, min=1, max=20, style={'handle_color': color}) for color in colors]\n\nupdate_button = widgets.Button(description='Update')\n\noutput = widgets.Output()\n\nvbox = widgets.VBox(sliders + [update_button])\nhbox = widgets.HBox([vbox, output])\n\nThe colors and sizes for each rectangle are kept as tuples in a list.\n\nrectangles = []\n\nWe have added an “Update” button that should update this list of rectangles based on the selected number of rectangles for each color. When clicked this button executes the on_update_button_clicked(b) function.\n\ndef on_update_button_clicked(b):\n    global rectangles, fig\n    with output:\n        clear_output(wait=True)\n        splits = [slider.value for slider in sliders]\n        rectangles = []\n        for i, c in enumerate(splits):\n            rectangles += [(sizes[i] // c, colors[i])] * c\n        \n        random.shuffle(rectangles)\n        shuffled_sizes, shuffled_colors = zip(*rectangles)\n        \n        fig, ax = plt.subplots(figsize=(7,7))\n        squarify.plot(sizes=shuffled_sizes, color=shuffled_colors, ax=ax)\n        ax.axis('off')\n        plt.show()\n\nupdate_button.on_click(on_update_button_clicked)\n\n# Draw the first plot \non_update_button_clicked(None)\n\nThe purpose of this function is to plot a new composition based on the values of the sliders.\nNow we show our sliders, button and plot.\n\ndisplay(hbox)"
  },
  {
    "objectID": "posts/blocbirds/index.html#saving-the-artwork",
    "href": "posts/blocbirds/index.html#saving-the-artwork",
    "title": "BLOCBIRDS",
    "section": "Saving the artwork",
    "text": "Saving the artwork\nOnce you’re happy with a composition you can save it to file.\n\nfig.tight_layout()\nfig.savefig('spangled-continga-art.png')"
  },
  {
    "objectID": "posts/blocbirds/index.html#some-more-examples",
    "href": "posts/blocbirds/index.html#some-more-examples",
    "title": "BLOCBIRDS",
    "section": "Some more examples",
    "text": "Some more examples\nThe first few examples are all based on images I got from this site.\n\nGolden pheasant\n\n\n\n\n\n\n\n\n\n\n\n\nMandarin duck\n\n\n\n\n\n\n\n\n\n\n\n\nIndian peafowl\nIn this case I didn’t remove the background because the bird already took up the entire frame. I set the number of rectangles for all colors but one shade of blue to quite high to mimic the pattern of the tail of this blue bird.\n\n\n\n\n\n\n\n\n\n\n\n\nHalfmoon betta fish\nInstead of just birds we can also use pictures of other animals, like this Halfmoon betta fish.\n\n\n\n\n\n\n\n\n\n\n\n\nCalifornia spangled\nOr we create an abstract of the California spangled. I set the number of rectangles to two for green to mimic the eyes.\n\n\n\n\n\n\n\n\n\n\n\n\nThe Matrix\nInstead of animals we can use a movie still.\n\n\n\n\n\n\n\n\n\n\n\n\nBLACKPINK\nOr perhaps you’re more into the visual aesthetics of BLACKPINK’s DDU-DU DDU-DU."
  },
  {
    "objectID": "posts/blocbirds/index.html#creating-your-own-artwork",
    "href": "posts/blocbirds/index.html#creating-your-own-artwork",
    "title": "BLOCBIRDS",
    "section": "Creating your own artwork",
    "text": "Creating your own artwork\nIf you want to create your own piece of art, check out one of the following links:"
  }
]