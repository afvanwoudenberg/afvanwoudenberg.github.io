[
  {
    "objectID": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html",
    "href": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html",
    "title": "How to Traverse a Decision Tree and Win at Guess Who?",
    "section": "",
    "text": "In the scikit-learn machine learning library, the predict method is used to make predictions on new data with a fitted model. This method expects the input data to have the same number of features as the data that the model was trained on. This makes sense for many models, but not necessarily for decision trees. Since decision trees look at one feature at a time, they may only need a subset of all features to make a prediction.\nIf we want to provide solely the features that are actually considered when making a prediction, we will need to traverse a decision tree iteratively.\nTo show you how this works, we’ll fit a decision tree model to a dataset of Guess Who character features. After fitting the model, we can traverse the resulting tree to make a prediction about the character’s identity."
  },
  {
    "objectID": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#wait-how-do-i-play-guess-who-again",
    "href": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#wait-how-do-i-play-guess-who-again",
    "title": "How to Traverse a Decision Tree and Win at Guess Who?",
    "section": "Wait, how do I play Guess Who again?",
    "text": "Wait, how do I play Guess Who again?\nIt may have been a while since you played this game, so let’s start with a refresher.\nIn Guess Who two players try to guess the opponent’s character by asking yes-no questions. Each player starts the game with a board that includes cartoon images of 24 people and their first names with all the images standing up. Each player selects a card of their choice from a separate pile of cards containing the same 24 images. The objective of the game is to be the first to determine which card one’s opponent has selected. Players alternate asking various yes-no questions to eliminate candidates, such as:\n\nDoes your person wear a hat?\nDoes your person wear glasses?\nIs your person female?\n\nThe player will then eliminate candidates (based on the opponent’s response) by flipping those images down until only one is left."
  },
  {
    "objectID": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#importing-necessary-libraries-and-loading-the-data",
    "href": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#importing-necessary-libraries-and-loading-the-data",
    "title": "How to Traverse a Decision Tree and Win at Guess Who?",
    "section": "Importing necessary libraries and loading the data",
    "text": "Importing necessary libraries and loading the data\nTo begin, we import the necessary libraries.\n\nimport pandas as pd\nimport numpy as np\nimport graphviz\nimport re\n\nfrom ipywidgets import GridspecLayout, HTML, VBox, HBox, Button, Label\nfrom sklearn.tree import DecisionTreeClassifier, export_graphviz\n\nData describing the characters is loaded into a Pandas DataFrame, with the character names located in the final column. Each feature in the DataFrame represents a specific trait, where a value of 1 or 0 indicates the presence or absence of that trait for a particular character.\n\ndf = pd.DataFrame({\n    # hair style\n    'hair_partition': [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0], \n    'curly_hair':     [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],\n    'hat':            [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'bald':           [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n    'long_hair':      [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    # hair color\n    'ginger_hair':    [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'white_hair':     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0],\n    'brown_hair':     [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0],\n    'blond_hair':     [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'black_hair':     [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1],\n    # facial attributes\n    'big_mouth':      [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0],\n    'big_nose':       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0],\n    'red_cheeks':     [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0],\n    'blue_eyes':      [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n    'sad_looking':    [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n    # facial hair\n    'facial_hair':    [1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0],\n    'moustache':      [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0],\n    'beard':          [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n    # other\n    'glasses':        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1],\n    'earrings':      [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    'female':         [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n    # names\n    'name':           ['alex', 'alfred', 'anita', 'anne', 'bernard', 'bill', 'charles', 'claire', \n                       'david', 'eric', 'frans', 'george', 'herman', 'joe', 'maria', 'max', 'paul', \n                       'peter', 'philip', 'richard', 'robert', 'sam', 'susan', 'tom']\n})\n\nEvery trait is associated with a question. The following dictionary links each trait (or feature) to a valid yes-no question. We will use this dictionary to map feature names to questions.\n\ncolumn_description = {\n    \"hair_partition\": \"Does your character have a visible hair partition?\",\n    \"curly_hair\": \"Does your character have curly hair?\",\n    \"hat\": \"Does your character wear a hat?\",\n    \"bald\": \"Is your character bald?\",\n    \"long_hair\": \"Does your character have long hair?\",\n    \"ginger_hair\": \"Does your character have ginger hair?\",\n    \"white_hair\": \"Does your character have white hair?\",\n    \"brown_hair\": \"Does your character have brown hair?\",\n    \"blond_hair\": \"Does your character have blond hair?\",\n    \"black_hair\": \"Does your character have black hair?\",\n    \"big_mouth\": \"Does your character have a big mouth?\",\n    \"big_nose\": \"Does your character have a big nose?\",\n    \"red_cheeks\": \"Does your character have red cheeks?\",\n    \"blue_eyes\": \"Does your character have blue eyes?\",\n    \"sad_looking\": \"Does your character look sad?\",\n    \"facial_hair\": \"Does your character have facial hair?\",\n    \"moustache\": \"Does your character have a moustache?\",\n    \"beard\": \"Does your character have a beard?\",\n    \"glasses\": \"Does your character wear glasses?\",\n    \"earrings\": \"Does your character wear earrings?\",\n    \"female\": \"Is your character female?\"\n}\n\nI used the traits mentioned in this blog post. At the end of this post, I’ll suggest some more questions you could add."
  },
  {
    "objectID": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#fitting-the-decision-tree",
    "href": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#fitting-the-decision-tree",
    "title": "How to Traverse a Decision Tree and Win at Guess Who?",
    "section": "Fitting the decision tree",
    "text": "Fitting the decision tree\nFirstly, we select the features and target variable from the DataFrame.\n\nX = df.iloc[:, :-1]\ny = df.iloc[:, -1]\n\nWe create a list feature_names containing the names of all the features in the input dataset. We will use this when visualizing the decision tree.\n\nfeature_names = list(df.columns)[:-1]\n\nBelow we fit the decision tree classifier using the DecisionTreeClassifier class. We specify the criterion for splitting nodes as entropy. The default is gini but entropy yields a slightly more optimal tree in this case.\n\nclf = DecisionTreeClassifier(criterion = \"entropy\")\nclf = clf.fit(X, y)"
  },
  {
    "objectID": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#visualizing-the-decision-tree",
    "href": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#visualizing-the-decision-tree",
    "title": "How to Traverse a Decision Tree and Win at Guess Who?",
    "section": "Visualizing the decision tree",
    "text": "Visualizing the decision tree\nThe depth of the tree tells us how many questions we need to ask at most. Ideally, you would want to do a binary search by splitting the number of possible characters in half with each question. By asking questions that split the number of remaining characters into two equal groups, you’d need only 4 or 5 questions at most.\nLet’s see how we do with the set of questions we defined above.\n\nclf.get_depth()\n\n6\n\n\nThe tree has a depth of 6. This means we need to ask 6 questions at most to guess the opponent’s characters if we use this decision tree. Let’s see what the tree looks like.\nIf we plot the tree graphically using sklearn.tree.plot_tree the result is illegible. A better way is to use the Graphviz format. The export_graphviz function returns a DOT string which is the abstract language used by Graphviz to describe nodes, edges, graphs, subgraphs etc.\n\ndot_data = export_graphviz(clf, out_file=None, feature_names=feature_names, \n    rotate=True, class_names=y, filled=True, rounded=True, \n    leaves_parallel=True, impurity=False, special_characters=True)\n\nWe can make the tree more compact by removing superfluous content from the nodes.\n\ndot_data = re.sub(\"=<samples = .*class = \", \"=<\", dot_data)\ndot_data = re.sub(\" &le; 0.5.*>, fillcolor\", \">, fillcolor\", dot_data)\ndot_data = re.sub('labeldistance.*headlabel=\"True\"', 'label=\"NO\"', dot_data)\ndot_data = re.sub('labeldistance.*headlabel=\"False\"', 'label=\"YES\"', dot_data)\ndot_data = re.sub('ranksep=.*,', 'ranksep=0.02', dot_data)\n\nFinally we display the tree.\n\ngraph = graphviz.Source(dot_data)\ngraph\n\n\n\n\nWe can see that most characters can be guessed in 4 or 5 moves. Only two characters need a 6th question."
  },
  {
    "objectID": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#traversing-the-decision-tree",
    "href": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#traversing-the-decision-tree",
    "title": "How to Traverse a Decision Tree and Win at Guess Who?",
    "section": "Traversing the decision tree",
    "text": "Traversing the decision tree\nWe can traverse the decision tree programmatically using the tree_ attribute of the trained clf object. The tree_ attribute is an instance of the sklearn.tree._tree.Tree class, which represents the decision tree as a binary tree of nodes.\nThe Tree class has several attributes and methods that can be used to traverse the tree, including:\n\nnode_count: the total number of nodes in the tree.\nfeature: an array of length node_count containing the feature index at each node, or -2 for leaf nodes.\nthreshold: an array of length node_count containing the threshold value at each split node, or -2 for leaf nodes. In our case the threshold value will always be 0.5 because all our features are either 0 or 1.\nvalue: an array of shape (node_count, n_outputs, n_classes) containing the class distribution at each leaf node.\nchildren_left: an array of length node_count containing the index of the left child node for each split node, or -1 for leaf nodes.\nchildren_right: an array of length node_count containing the index of the right child node for each split node, or -1 for leaf nodes.\n\nTo traverse the decision tree, we start at the root node (index 0) and recursively traverse the left or right child nodes depending on the feature value.\nThe following function traverses the tree and queries the user at each (non-leaf) node it encounters. It uses the column_description dictionary that we’ve defined above to match feature names to questions.\n\ndef play_game(node_id=0):\n    if clf.tree_.children_left[node_id] == -1:\n        # leaf node\n        print(f\"Your character is: {clf.classes_[clf.tree_.value[node_id].argmax()].capitalize()}\")\n    else:\n        feature = clf.feature_names_in_[clf.tree_.feature[node_id]]\n        threshold = clf.tree_.threshold[node_id]\n\n        while (ans := input(f\"{column_description[feature]} (Y/N): \").lower()) not in ['y', 'n']:\n            pass\n        \n        val = 0 if ans == 'n' else 1\n        if val <= threshold:\n            # it's a 'no', so traverse left subtree\n            play_game(clf.tree_.children_left[node_id])\n        else:\n            # traverse right subtree\n            play_game(clf.tree_.children_right[node_id])\n\nBy calling this function, we recursively traverse the decision tree starting from the root node (index 0), checking the feature value of the input instance at each split node and following the left or right child node accordingly, until a leaf node is reached. At the leaf node, the function prints the predicted class label by finding the index of the largest class probability in the value array of the leaf node, which corresponds to the predicted class label (the name of the character)."
  },
  {
    "objectID": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#creating-a-fancy-gui-with-ipywidgets",
    "href": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#creating-a-fancy-gui-with-ipywidgets",
    "title": "How to Traverse a Decision Tree and Win at Guess Who?",
    "section": "Creating a fancy GUI with ipywidgets",
    "text": "Creating a fancy GUI with ipywidgets\nWe can create a way fancier GUI using Jupyter widgets, and render it using Voila to create an interactive web app. We’ll display the pictures of the characters that we will flip down while traversing the tree. The images were taken from this website.\nWe use the following features of the tree_ attribute.\n\nchildren_left = clf.tree_.children_left\nchildren_right = clf.tree_.children_right\nfeature = clf.tree_.feature\nvalue = clf.tree_.value\n\nThe next part sets up the grid using GridspecLayout with 3 rows and 8 columns. Each cell in the grid contains an HTML element with an image of a character loaded from the website mentioned above.\nThe code also creates a label and three buttons using the Label and Button classes, and arranges them in a horizontal box (HBox). The label displays the current question or the final answer, and the buttons allow the user to answer yes or no to a question, and restart the game. These widgets are then arranged in a vertical box (VBox) along with the grid.\n\ngrid = GridspecLayout(3, 8)\ngrid.width = \"1120\"\n\nfor i in range(3):\n    for j in range(8):\n        grid[i, j] = HTML(value=\"<img src='https://guesswhocharacters.info/imgs/{}.jpeg' width=130 height=190>\".format(str(df.name[i*8+j])))\n\nlabel = Label(value=\"Put the questions and answer here\")\nbutton_yes = Button(description=\"Yes\")\nbutton_no = Button(description=\"No\")\nbutton_play_again = Button(description=\"Play again\")\nhbox = HBox([label, button_yes, button_no, button_play_again])\nvbox = VBox([grid, hbox])\n\nThe root node of the tree will have an id of 0 which is where we start out search.\n\n# Start at root\nnode_id = 0\n\nThe functions below are for updating the GUI based on user interactions:\n\nupdate_gui() updates the label and buttons based on the current node in a decision tree model used for the game. If the current node is a leaf node, meaning it represents a final answer, the label displays the character’s name and the “Yes” and “No” buttons are hidden while the “Play Again” button is shown. If the current node is a branch node, the label displays the current question, and the “Yes” and “No” buttons are shown while the “Play Again” button is hidden.\nshow_all_cards() makes all cards visible in the grid.\nhide_cards(attribute, val) hides cards in the grid that have a particular attribute with a given value.\non_button_yes_clicked(b), on_button_no_clicked(b), and on_button_play_again_clicked(b) are callback functions that are executed when the “Yes”, “No”, or “Play Again” button is clicked, respectively. These functions update the node_id variable that tracks the current node in the decision tree model and call update_gui() to update the GUI based on the new node.\n\n\ndef update_gui():\n    if children_left[node_id] == children_right[node_id]:\n        label.value = \"You character is \" + y[np.argmax(value[node_id])].capitalize()\n        button_yes.layout.display = 'none'\n        button_no.layout.display = 'none'\n        button_play_again.layout.display = 'block'\n    else:\n        label.value = column_description[df.columns[feature[node_id]]]\n        button_yes.layout.display = 'block'\n        button_no.layout.display = 'block'\n        button_play_again.layout.display = 'none'\n\ndef show_all_cards():\n    for i in range(3):\n        for j in range(8):\n            grid[i, j].layout.visibility = 'visible'\n\ndef hide_cards(attribute, val):\n    for i in range(3):\n        for j in range(8):\n            if df[attribute][i*8+j] == val:\n                grid[i, j].layout.visibility = 'hidden'\n        \ndef on_button_yes_clicked(b):\n    global node_id\n    hide_cards(df.columns[feature[node_id]], 0)\n    node_id = children_right[node_id]\n    update_gui()\n\ndef on_button_no_clicked(b):\n    global node_id\n    hide_cards(df.columns[feature[node_id]], 1)\n    node_id = children_left[node_id]\n    update_gui()\n\ndef on_button_play_again_clicked(b):\n    global node_id\n    show_all_cards()\n    node_id = 0\n    update_gui()\n    \nbutton_yes.on_click(on_button_yes_clicked)\nbutton_no.on_click(on_button_no_clicked)\nbutton_play_again.on_click(on_button_play_again_clicked)\n\nupdate_gui()\n\nFinally, the GUI is displayed using the display() function.\n\ndisplay(vbox)\n\n\n\n\nUse one of the following links to play with an interactive version:"
  },
  {
    "objectID": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#ok-cool-but-how-do-i-win-at-guess-who",
    "href": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#ok-cool-but-how-do-i-win-at-guess-who",
    "title": "How to Traverse a Decision Tree and Win at Guess Who?",
    "section": "OK, cool, but how do I win at Guess Who?",
    "text": "OK, cool, but how do I win at Guess Who?\nNow you know how to fit and traverse a decision tree. Let’s see how we can improve the decision tree.\nOur decision tree above has a depth of 6 which seems decent, but as I mentioned, we can do better. In order to guess our opponent’s character with the least number of attempts, we want to pose questions that halve the number of potential characters each turn. By employing this tactic, we can quickly narrow down the options from 24 people to 12, then 6, 3, and eventually just 1 or 2 remaining. This approach enables us to guess the character within a maximum of 4 or 5 turns.\nThe game has deliberately been designed so that obvious traits, like if the person is female, or if the person has a moustache, applies to 5 characters at most. This makes even splits challenging. Two strategies that are mentioned in various places are the letter strategy and the compound questions strategy.\n\nLetter strategy\nThe letter strategy is a simple yet effective approach. It works by asking questions that revolve around the starting letter of each character’s name and focusing on the middle starting letter of the remaining characters. For instance, asking as a first question if the person’s name starts with the letters A-G would eliminate half the characters. If the person’s name does indeed start with one of the letters A-G, a follow-up question might be whether the person’s name starts with the letters A-B, and so on.\n\n\nCompound questions strategy\nAnother approach is the compound questions strategy. Rather than asking about a single characteristic at a time, you can ask about two or more characteristics simultaneously. For example, instead of asking “Does your person have white hair?”, you could ask “Does your person have white hair OR black hair?”. The facial hair trait used above is an example of such a compound question as it asks whether the character has a beard OR a moustache."
  },
  {
    "objectID": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#conclusion",
    "href": "posts/how-to-traverse-a-decision-tree-and-win-at-guess-who/index.html#conclusion",
    "title": "How to Traverse a Decision Tree and Win at Guess Who?",
    "section": "Conclusion",
    "text": "Conclusion\nWe have seen how a fitted decision tree can be traversed iteratively.\nBy adding new questions based on the letter and compound questions strategies to the DataFrame above you should be able to reduce the depth of the decision tree to five.\nSo there you have it, you now have all the tools to dominate (and drain all the fun out of) your Guess Who games.\nGood luck and happy guessing!"
  },
  {
    "objectID": "posts/skyline-puzzle/index.html",
    "href": "posts/skyline-puzzle/index.html",
    "title": "Skyline Puzzle",
    "section": "",
    "text": "A coworker of mine recently introduced me to this puzzle:\nThe puzzle is called Skyline and it’s a packing puzzle. The objective is to place the metal rod in one of the holes in the base and place the nine wooden pieces around it. It was designed by Jean Claude Constantin.\nWhen solved, the puzzle looks something like this:\nIn this blog post I present some Prolog code to generate all solutions for each rod position."
  },
  {
    "objectID": "posts/skyline-puzzle/index.html#solving-this-puzzle-using-prolog",
    "href": "posts/skyline-puzzle/index.html#solving-this-puzzle-using-prolog",
    "title": "Skyline Puzzle",
    "section": "Solving this puzzle using Prolog",
    "text": "Solving this puzzle using Prolog\nIt’s a breeze to program a Skyline solver using Prolog’s built-in backtracking mechanism.\n\n\nskyline.pl\n\n% A Prolog solver for the Skyline puzzle\n% http://www.constantin-jean-clau.de/\n\nprint_solution(X,Y) :- solve(X,Y,Sol), print_board(Sol).\n\npos(X,Y,_) :- member(X,[1,2,3,4,5,6,7]), member(Y,[1,2,3,4,5,6,7]).\n\nboard(Board) :- findall(pos(X,Y,_),pos(X,Y,_),Board).\n\nsolve(X,Y,Board) :- \n    board(Board), \n    member(pos(X,Y,' '),Board),\n    solve(1,1,Board,[]).\n\nsolve(7,7,_,_) :- !.\nsolve(8,Y,Board,Placed) :-\n    Yn is Y + 1,\n    solve(1,Yn,Board,Placed), !.\nsolve(X,Y,Board,Placed) :-\n    member(pos(X,Y,V),Board),\n    nonvar(V),\n    Xn is X + 1,\n    solve(Xn,Y,Board,Placed).\nsolve(X,Y,Board,Placed) :-\n    member(pos(X,Y,V),Board),\n    var(V),\n    member(Piece,[i,g,h,f,e,d,a,c,b]),\n    not(member(Piece,Placed)),\n    piece(Piece,Locs),\n    place_piece(Piece,X,Y,Locs,Board),\n    Xn is X + 1,\n    solve(Xn,Y,Board,[Piece|Placed]).\n\nprint_board(Board) :- \n    write('+-------+'), nl,\n    findall(_,(member(Y,[1,2,3,4,5,6,7]),print_line(Y,Board)),_),\n    write('+-------+'), nl.\n\nprint_line(Y,Board) :- \n    write('|'), \n    findall(_,(member(X,[1,2,3,4,5,6,7]),print_piece(X,Y,Board)),_), \n    write('|'),\n    nl.\n\nprint_piece(X,Y,Board) :- \n    member(pos(X,Y,P),Board), \n    not(var(P)),\n    write(P), !.\nprint_piece(_,_,_) :- \n    write('_').\n\nplace_piece(_,_,_,[],_).\nplace_piece(Piece,X0,Y0,[(Xd,Yd)|Locs],Board) :-\n    X is X0 + Xd, X > 0, X =< 7, \n    Y is Y0 + Yd, Y > 0, Y =< 7,\n    member(pos(X,Y,Piece),Board),\n    place_piece(Piece,X0,Y0,Locs,Board).\n\npiece(a,[(0,0),(0,1),(0,2),(0,3),(0,4)]).\npiece(a,[(0,0),(1,0),(2,0),(3,0),(4,0)]).\n\npiece(b,[(0,0),(1,0)]).\npiece(b,[(0,0),(0,1)]).\n\npiece(c,[(0,0),(-1,1),(0,1),(1,1)]).\npiece(c,[(0,0),(1,0),(1,1),(2,0)]).\npiece(c,[(0,0),(0,1),(-1,1),(0,2)]).\npiece(c,[(0,0),(0,1),(1,1),(0,2)]).\n\npiece(d,[(0,0),(0,1),(1,1),(1,2),(2,2)]).\npiece(d,[(0,0),(1,0),(-1,1),(0,1),(-1,2)]).\npiece(d,[(0,0),(1,0),(1,1),(2,1),(2,2)]). \npiece(d,[(0,0),(-1,1),(0,1),(-2,2),(-1,2)]).\n\npiece(e,[(0,0),(0,1),(0,2),(0,3),(1,1)]).\npiece(e,[(0,0),(1,0),(2,0),(3,0),(2,1)]).\npiece(e,[(0,0),(0,1),(0,2),(0,3),(-1,2)]).\npiece(e,[(0,0),(-1,1),(0,1),(1,1),(2,1)]).\n\npiece(f,[(0,0),(-1,1),(0,1),(-2,2),(-1,2),(0,2)]).\npiece(f,[(0,0),(0,1),(1,1),(0,2),(1,2),(2,2)]).\npiece(f,[(0,0),(1,0),(2,0),(0,1),(1,1),(0,2)]).\npiece(f,[(0,0),(1,0),(2,0),(1,1),(2,1),(2,2)]).\n\npiece(g,[(0,0),(1,0),(0,1),(1,1),(2,1),(0,2),(1,2)]).\npiece(g,[(0,0),(1,0),(2,0),(0,1),(1,1),(2,1),(1,2)]).\npiece(g,[(0,0),(1,0),(-1,1),(0,1),(1,1),(0,2),(1,2)]).\npiece(g,[(0,0),(-1,1),(0,1),(1,1),(-1,2),(0,2),(1,2)]).\n\npiece(h,[(0,0),(0,1),(0,2),(0,3),(1,1),(1,2)]).\npiece(h,[(0,0),(1,0),(2,0),(3,0),(1,1),(2,1)]).\npiece(h,[(0,0),(-1,1),(0,1),(-1,2),(0,2),(0,3)]).\npiece(h,[(0,0),(1,0),(-1,1),(0,1),(1,1),(2,1)]).\n\npiece(i,[(0,0),(-2,1),(-1,1),(0,1),(-2,2),(-1,2),(0,2),(-1,3)]).\npiece(i,[(0,0),(1,0),(-1,1),(0,1),(1,1),(0,2),(1,2),(2,2)]).\npiece(i,[(0,0),(-1,1),(0,1),(1,1),(-1,2),(0,2),(1,2),(-1,3)]).\npiece(i,[(0,0),(1,0),(2,0),(1,1),(2,1),(3,1),(1,2),(2,2)]).\n\nYou can find a copy of this code as a GitHub gist here.\nThe solve/3 predicate is the main predicate that solves the puzzle. It takes as input the X and Y coordinates of the empty cell on the board and returns a solution, which is a list of pos(X,Y,P) terms representing the placement of the pieces on the board. The solve/4 predicate is a helper predicate that recursively places the pieces on the board.\nThe program also includes several other predicates that define the properties of the puzzle, such as the shape and size of each piece, and the rules for placing the pieces on the board. The piece/2 predicate defines the shape of each piece, and the place_piece/5 predicate checks whether a piece can be placed on a given location on the board.\nFinally, the print_board/1 predicate is used to print the solution to the puzzle in a readable format."
  },
  {
    "objectID": "posts/skyline-puzzle/index.html#how-to-use-this-solver",
    "href": "posts/skyline-puzzle/index.html#how-to-use-this-solver",
    "title": "Skyline Puzzle",
    "section": "How to use this solver",
    "text": "How to use this solver\nTo use this program, open the skyline.pl file in your preferred Prolog interpreter (I personally prefer SWI-Prolog). To find find a solution for when the metal rod is in position (4, 4), simply type the following:\nprint_solution(4,4).\n+-------+\n|ggeeeeh|\n|gggdehh|\n|ggiddhh|\n|iii ddh|\n|iiicfff|\n|bicccff|\n|baaaaaf|\n+-------+\ntrue\nThe helper predicate print_solution/2 calls the solve/3 to solve and print_board/1 to display the solution.\nYou can press ; to find alternative solutions.\nIf you want to see all solutions for a given rod position, you can type:\nfindall(_,print_solution(4,4),_)."
  },
  {
    "objectID": "posts/icosian-game/index.html",
    "href": "posts/icosian-game/index.html",
    "title": "Icosian Game",
    "section": "",
    "text": "The Irish mathematician William Rowan Hamilton is probably best known for discovering quaternions. He is also the inventor of the Icosian game.\nIn this blog post I’ll describe the game and show some Prolog code for solving it."
  },
  {
    "objectID": "posts/icosian-game/index.html#how-to-play-the-icosian-game",
    "href": "posts/icosian-game/index.html#how-to-play-the-icosian-game",
    "title": "Icosian Game",
    "section": "How to play the Icosian game",
    "text": "How to play the Icosian game\nThe game’s objective is to find a path around a dodecahedron such that every vertex is visited once, no edge is visited multiple times, and the path ends in de same vertex it started from. Instead of using a 3d dodecahedron, the game was distributed as a pegboard with holes at the vertices of the 2d dodecahedral graph.\n\n\n\nOne of the few remaining copies (from the collection of the puzzle museum)\n\n\nThe game was meant to be played by two people. The first player would set up the challenge by placing the first five pegs in any five consecutive holes and then the second player would be required to place the remaining fifteen pegs consecutively in such a way that the succession would be cyclical."
  },
  {
    "objectID": "posts/icosian-game/index.html#some-graph-theory",
    "href": "posts/icosian-game/index.html#some-graph-theory",
    "title": "Icosian Game",
    "section": "Some graph theory",
    "text": "Some graph theory\nIn graph theory, a path that visits every vertex of a graph once is now known as a Hamiltonian path. A path that visits every vertex once and that ends in the same vertex as it started off from is called a Hamiltonian cycle. So playing this game is essentially searching for a Hamiltonian cycle in the dodecahedral graph."
  },
  {
    "objectID": "posts/icosian-game/index.html#solving-this-game-using-prolog",
    "href": "posts/icosian-game/index.html#solving-this-game-using-prolog",
    "title": "Icosian Game",
    "section": "Solving this game using Prolog",
    "text": "Solving this game using Prolog\nThe Icosian game was never a commercial success, probably because it’s too easy. I wrote some Prolog code to solve this game and explore possible solutions.\n\n\nicosian.pl\n\n% A Prolog solver for the Icosian game\n% https://en.wikipedia.org/wiki/Icosian_game\n\nicosian_puzzle_edges([\n    (b,c), (b,g), (b,z), (c,d), (c,p), (d,f), (d,m), (f,g), (f,k), (g,h), \n    (h,j), (h,x), (j,k), (j,v), (k,l), (l,t), (l,m), (m,n), (n,p), (n,s), \n    (p,q), (q,z), (q,r), (r,s), (r,w), (s,t), (t,v), (v,w), (w,x), (x,z)\n]).\n\nconnected(Adj,P,Q) :- member((P,Q),Adj); member((Q,P),Adj).\n\ngraph_order(Adj,N) :- \n    findall(A,connected(Adj,A,_),B0), \n    sort(B0,B), \n    length(B,N). \n\nhamiltonian_cycle(Adj,[Start|TourRest]) :-\n    graph_order(Adj,N),\n    append([[Start],MidTour,[Start]],[Start|TourRest]),\n    length([Start|MidTour],N),\n    hamiltonian_cycle(Adj,Start,MidTour,[Start]).\n\nhamiltonian_cycle(Adj,Start,[],[LastVisited|_]) :-\n    connected(Adj,LastVisited,Start).\nhamiltonian_cycle(Adj,Start,[Head|Tail],[VisitedHead|VisitedTail]) :-\n    connected(Adj,VisitedHead,Head),\n    not(member(Head,[VisitedHead|VisitedTail])),\n    hamiltonian_cycle(Adj,Start,Tail,[Head,VisitedHead|VisitedTail]).\n\nprint_icosian_puzzle :- print_icosian_solution([]).\n\nedge_in_tour(P,Q,Tour) :-\n    append([_,[P,Q],_],Tour);\n    append([_,[Q,P],_],Tour).\n\nformat_edge(P,Q,Tour,Atom,Out) :-\n    edge_in_tour(P,Q,Tour),\n    format(atom(Out),'\\e[31m~w\\e[0m',[Atom]), !.\nformat_edge(_P,_Q,_Tour,Atom,Atom).\n\nprint_icosian_solution(Tour) :-\n    findall(F,(member((P,Q,A),[\n        (b,c,'-'), (b,g,'/'), (b,z,'\\\\'), (c,d,'\\\\'), (c,p,'/'), \n        (d,f,'/'), (d,m,'\\\\'), (f,g,'\\\\'), (f,k,'|'), (g,h,'/'),\n        (h,j,'\\\\'), (h,x,'\\\\'), (j,k,'/'), (j,v,'/'), (k,l,'\\\\'),\n        (l,t,'\\\\'), (l,m,'/'), (m,n,'/'), (n,p,'\\\\'), (n,s,'---'),\n        (p,q,'\\\\'), (q,z,'/'), (q,r,'|'), (r,s,'\\\\'), (r,w,'/'),\n        (s,t,'/'), (t,v,'-------'), (v,w,'\\\\'), (w,x,'---'), (x,z,'/')\n    ]),format_edge(P,Q,Tour,A,F)),[BC,BG,BZ,CD,CP,DF,DM,FG,FK,GH,\n        HJ,HX,JK,JV,KL,LT,LM,MN,NP,NS,PQ,QZ,QR,RS,RW,ST,TV,VW,WX,XZ]),\n    format('            R',[]), nl,\n    format('           ~w~w~w',[RW,QR,RS]), nl,\n    format('          ~w ~w ~w',[RW,QR,RS]), nl,\n    format('         ~w  ~w  ~w',[RW,QR,RS]), nl,\n    format('        ~w   Q   ~w',[RW,RS]), nl,\n    format('       ~w   ~w ~w   ~w',[RW,QZ,PQ,RS]), nl,\n    format('      ~w   ~w   ~w   ~w',[RW,QZ,PQ,RS]), nl,\n    format('     ~w   Z     P   ~w',[RW,RS]), nl,\n    format('    ~w   ~w ~w   ~w ~w   ~w',[RW,XZ,BZ,CP,NP,RS]), nl,\n    format('   ~w   ~w   B~wC   ~w   ~w',[RW,XZ,BC,NP,RS]), nl,\n    format('  ~w   ~w   ~w   ~w   ~w   ~w',[RW,XZ,BG,CD,NP,RS]), nl,\n    format(' ~w   ~w   G     D   ~w   ~w',[RW,XZ,NP,RS]), nl,\n    format('W~wX   ~w ~w   ~w ~w   N~wS',[WX,GH,FG,DF,DM,NS]), nl,\n    format(' ~w   ~w ~w   ~w ~w   ~w ~w   ~w',[VW,HX,GH,FG,DF,DM,MN,ST]), nl,\n    format('  ~w   H     F     M   ~w',[VW,ST]), nl,\n    format('   ~w   ~w    ~w    ~w   ~w',[VW,HJ,FK,LM,ST]), nl,\n    format('    ~w   ~w   K   ~w   ~w',[VW,HJ,LM,ST]), nl,\n    format('     ~w   ~w ~w ~w ~w   ~w',[VW,HJ,JK,KL,LM,ST]), nl,\n    format('      ~w   J   L   ~w',[VW,ST]), nl,\n    format('       ~w ~w     ~w ~w',[VW,JV,LT,ST]), nl,\n    format('        V~wT',[TV]), nl.\n\nsolve_icosian_puzzle :-\n    icosian_puzzle_edges(Adj), \n    hamiltonian_cycle(Adj,Tour), \n    print_icosian_solution(Tour).\n\nThe icosian_puzzle_edges/1 predicate defines the graph by specifying a list of edges between vertices which is used by the connected/3 predicate which checks whether there is an edge between two vertices.\nThe hamiltonian_cycle/2 predicate defines the main algorithm for finding a Hamiltonian cycle on the graph, given a starting vertex. After determining the number of vertices in the graph, it recursively tries to find a cycle that visits each vertex exactly once.\nThe print_icosian_solution/1 predicate prints out the solution to the Icosian game, highlighting the edges in the Hamiltonian cycle found by the hamiltonian_cycle/2 predicate.\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/icosian-game/index.html#how-to-use-this-code",
    "href": "posts/icosian-game/index.html#how-to-use-this-code",
    "title": "Icosian Game",
    "section": "How to use this code",
    "text": "How to use this code\nTo use this program, open the icosian.pl file in your preferred Prolog interpreter (I always use SWI-Prolog). Entering solve_icosian_puzzle. and pressing ; repeatedly will yield possible solutions.\n\nSuppose you want to explore how the cycle that starts with the vertices Q, R, S, N, P could be continued, you would enter:\nicosian_puzzle_edges(Adj), Tour = [q,r,s,n,p|Rest], hamiltonian_cycle(Adj,Tour), print_icosian_solution(Tour).\nThis game might remind you of the Travelling Salesman Problem (TSP). Finding a Hamiltonian cycle can be considered a special case of the TSP, namely, one where each pair of vertices with an edge between them has distance 1, while vertex pairs without an edge between them are separated by a distance of infinity."
  },
  {
    "objectID": "posts/vba-iban-validator/index.html",
    "href": "posts/vba-iban-validator/index.html",
    "title": "VBA IBAN Validator",
    "section": "",
    "text": "From February 2014 onwards, IBAN will be the new European standard for bank account numbers. This standardization is part of the SEPA initiative to improve the efficiency of cross-border euro payments.\nI wrote an IBAN validator in VBA for an MS Access database I’m maintaining, but you can also use it in Excel or any other application that supports VBA.\n\n\nmodValidIban.bas\n\nOption Compare Database\nOption Explicit\n\n' http://en.wikipedia.org/wiki/International_Bank_Account_Number\nPrivate Const IbanCountryLengths As String = \"AL28AD24AT20AZ28BH22BE16BA20BR29BG22CR21HR21CY28CZ24DK18DO28EE20FO18\" & _\n                                             \"FI18FR27GE22DE22GI23GR27GL18GT28HU28IS26IE22IL23IT27KZ20KW30LV21LB28\" & _\n                                             \"LI21LT20LU20MK19MT31MR27MU30MC27MD24ME22NL18NO15PK24PS29PL28PT25RO24\" & _\n                                             \"SM27SA24RS22SK24SI19ES24SE24CH21TN24TR26AE23GB22VG24QA29\"\n\nPrivate Function ValidIbanCountryLength(CountryCode As String, IbanLength As Integer) As Boolean\n    Dim i As Integer\n    For i = 0 To Len(IbanCountryLengths) / 4 - 1\n        If Mid(IbanCountryLengths, i * 4 + 1, 2) = CountryCode And _\n                    CInt(Mid(IbanCountryLengths, i * 4 + 3, 2)) = IbanLength Then\n            ValidIbanCountryLength = True\n            Exit Function\n        End If\n    Next i\n    ValidIbanCountryLength = False\nEnd Function\n\nPrivate Function Mod97(Num As String) As Integer\n    Dim lngTemp As Long\n    Dim strTemp As String\n\n    Do While Val(Num) >= 97\n        If Len(Num) > 5 Then\n            strTemp = Left(Num, 5)\n            Num = Right(Num, Len(Num) - 5)\n        Else\n            strTemp = Num\n            Num = \"\"\n        End If\n        lngTemp = CLng(strTemp)\n        lngTemp = lngTemp Mod 97\n        strTemp = CStr(lngTemp)\n        Num = strTemp & Num\n    Loop\n    Mod97 = CInt(Num)\nEnd Function\n\nPublic Function ValidIban(IBAN As String) As Boolean\n    Dim strIban As String\n    Dim i As Integer\n\n    strIban = UCase(IBAN)\n    ' Remove spaces\n    strIban = Replace(strIban, \" \", \"\")\n\n    ' Check if IBAN contains only uppercase characters and numbers\n    For i = 1 To Len(strIban)\n        If Not ((Asc(Mid(strIban, i, 1)) <= Asc(\"9\") And Asc(Mid(strIban, i, 1)) >= Asc(\"0\")) Or _\n                (Asc(Mid(strIban, i, 1)) <= Asc(\"Z\") And Asc(Mid(strIban, i, 1)) >= Asc(\"A\"))) Then\n            ValidIban = False\n            Exit Function\n        End If\n    Next i\n\n    ' Check if length of IBAN equals expected length for country\n    If Not ValidIbanCountryLength(Left(strIban, 2), Len(strIban)) Then\n        ValidIban = False\n        Exit Function\n    End If\n\n    ' Rearrange\n    strIban = Right(strIban, Len(strIban) - 4) & Left(strIban, 4)\n\n    ' Replace characters\n    For i = 0 To 25\n        strIban = Replace(strIban, Chr(i + Asc(\"A\")), i + 10)\n    Next i\n\n    ' Check remainder\n    ValidIban = Mod97(strIban) = 1\nEnd Function\n\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html",
    "href": "posts/bridge-and-torch-puzzle/index.html",
    "title": "Bridge and Torch Puzzle",
    "section": "",
    "text": "The Bridge and torch puzzle goes like this:\nIn this blog post I give a solution and some code for finding all solutions in Prolog."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html#solving-the-puzzle",
    "href": "posts/bridge-and-torch-puzzle/index.html#solving-the-puzzle",
    "title": "Bridge and Torch Puzzle",
    "section": "Solving the puzzle",
    "text": "Solving the puzzle\nOne might guess that an obvious solution would be to let the fastest person (A) shuttle each other person over the bridge and return alone with the torch. This would give the following schedule:\n\n\n\nA, B\n\\(\\rightarrow\\)\n2 minutes\n\n\nA\n\\(\\leftarrow\\)\n1 minutes\n\n\nA, C\n\\(\\rightarrow\\)\n5 minutes\n\n\nA\n\\(\\leftarrow\\)\n1 minutes\n\n\nA, D\n\\(\\rightarrow\\)\n10 minutes\n\n\n\nThe total duration of this schedule would be 19 minutes, so the torch would run out of battery while person A and D are still on the bridge.\nThe optimal solution consists of letting the two slowest people (C and D) cross the bridge together, giving the following schedule:\n\n\n\nA, B\n\\(\\rightarrow\\)\n2 minutes\n\n\nB\n\\(\\leftarrow\\)\n2 minutes\n\n\nC, D\n\\(\\rightarrow\\)\n10 minutes\n\n\nA\n\\(\\leftarrow\\)\n1 minutes\n\n\nA, B\n\\(\\rightarrow\\)\n2 minutes\n\n\n\nWhich gives a total crossing time of exactly 17 minutes."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html#prolog-to-the-rescue",
    "href": "posts/bridge-and-torch-puzzle/index.html#prolog-to-the-rescue",
    "title": "Bridge and Torch Puzzle",
    "section": "Prolog to the rescue",
    "text": "Prolog to the rescue\nProlog is quite suitable for solving these kinds of search problems.\n\n\nbridge.pl\n\n% A Prolog solver for the bridge and torch puzzle\n% https://en.wikipedia.org/wiki/Bridge_and_torch_problem\n\nprint_all_solutions :-\n    findall(_,print_solution,_).\n\nprint_solution :-\n    init(State),\n    solve(State,Solution,EndState),\n    writeln('Start state:'),\n    writeln(State),\n    writeln('Solution:'),\n    writeln(Solution),\n    writeln('Final state:'),\n    writeln(EndState), nl.\n\nsolve(State,[],State) :- goal(State).\nsolve(State,[Move|Tail],EndState) :- s(State,Move,NewState), solve(NewState,Tail,EndState).\n\ngoal(state([],right,[_,_,_,_],T)) :- T =< 17.\n\ninit(state([a,b,c,d],left,[],0)).\n\ns(state(L1,left,L2,T),cross(L3),state(L4,right,L6,T2)) :-       \n    select_one_or_two(L1,L3,L4),\n    ord_union(L2,L3,L6),\n    min_time_needed(L3,Tn),\n    T2 is T + Tn, \n    T2 =< 17.\ns(state(L1,right,L2,T),cross(L3),state(L4,left,L5,T2)) :-       \n    select_one_or_two(L2,L3,L5),\n    ord_union(L1,L3,L4),\n    min_time_needed(L3,Tn),\n    T2 is T + Tn, \n    T2 =< 17.\n\nselect_one_or_two(L,[Sel],L2) :- select(Sel,L,L2).\nselect_one_or_two(L,[Sel1,Sel2],L2) :- select(Sel1,L,NewL), select(Sel2,NewL,L2), Sel1@<Sel2.\n\nmin_time_needed([A],T) :- time_needed(A,T).\nmin_time_needed([A,B],T) :- time_needed(A,T1), time_needed(B,T2), max_list([T1,T2],T).\n\ntime_needed(a,1).\ntime_needed(b,2).\ntime_needed(c,5).\ntime_needed(d,10).\n\nThe init predicate defines the initial state of the puzzle, which includes the positions of the four people and the torch, and the time taken so far. The goal predicate defines the goal state, which is when all four people are on the other side of the bridge in at most 17 minutes.\nThe program finds a sequence of moves that will get all four people across the bridge in the shortest time. The solve predicate recursively searches for a sequence of moves that will lead to the goal state. The s predicate defines the possible moves that can be made from a given state. The select_one_or_two predicate selects one or two people from the group to cross the bridge. The min_time_needed predicate calculates the time needed for the selected people to cross the bridge.\nI chose to represent a state by keeping track of two lists, one for each side of the bridge. An alternative representation might be to use one list with the times it takes each person and a positive/negative sign that indicates on which side of the brige the person is. This list could look like this: [1,2,-5,-10] and would indicate that the persons with times 1 and 2 are on one side of the bridge and the others would be on the other side. We could add another number, say 1 (or -1), to indicate on which side the flashlight is. Finding a suitable representation is often half the battle and multiple alternatives might work equally well.\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/bridge-and-torch-puzzle/index.html#running-the-solver",
    "href": "posts/bridge-and-torch-puzzle/index.html#running-the-solver",
    "title": "Bridge and Torch Puzzle",
    "section": "Running the solver",
    "text": "Running the solver\nTo run the solver, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the solver by typing:\n[bridge].\nThis loads the bridge.pl file. You can execute the solver which will output all solutions to the console:\nprint_all_solutions.\nStart state:\nstate([a,b,c,d],left,[],0)\nSolution:\n[cross([a,b]),cross([a]),cross([c,d]),cross([b]),cross([a,b])]\nFinal state:\nstate([],right,[a,b,c,d],17)\n\nStart state:\nstate([a,b,c,d],left,[],0)\nSolution:\n[cross([a,b]),cross([b]),cross([c,d]),cross([a]),cross([a,b])]\nFinal state:\nstate([],right,[a,b,c,d],17)"
  },
  {
    "objectID": "posts/who-owns-the-zebra/index.html",
    "href": "posts/who-owns-the-zebra/index.html",
    "title": "Who Owns the Zebra",
    "section": "",
    "text": "On December 17, 1962, Life International magazine published the following puzzle:\nThis puzzle is said to be invented by Einstein and therefore sometimes referred to as Einstein’s puzzle or Einstein’s riddle. Supposedly, he also claimed that only 2% of the world’s population would be smart enough to solve it. For neither claim is there any evidence."
  },
  {
    "objectID": "posts/who-owns-the-zebra/index.html#solving-the-puzzle-using-prolog",
    "href": "posts/who-owns-the-zebra/index.html#solving-the-puzzle-using-prolog",
    "title": "Who Owns the Zebra",
    "section": "Solving the puzzle using Prolog",
    "text": "Solving the puzzle using Prolog\nAs an example of how to solve these kinds of logic puzzles using Prolog, I wrote this code:\n\n\neinstein.pl\n\n% A Prolog solver for the Zebra puzzle a.k.a. Einstein's riddle.\n% https://en.wikipedia.org/wiki/Zebra_Puzzle\n\neinstein :-\n    einstein(Solution),\n    write_sol(Solution).\n\neinstein(Sol) :-\n    Sol = [ \n        [1,N1,C1,P1,D1,S1],                             % There are five houses.\n        [2,N2,C2,P2,D2,S2],\n        [3,N3,C3,P3,D3,S3],\n        [4,N4,C4,P4,D4,S4],\n        [5,N5,C5,P5,D5,S5]],\n    member([_,englishman,red,_,_,_],Sol),               % The Englishman lives in the red house.\n    member([_,spaniard,_,dog,_,_],Sol),                 % The Spaniard owns the dog.\n    member([_,_,green,_,coffee,_],Sol),                 % Coffee is drunk in the green house.\n    member([_,ukrainian,_,_,tea,_],Sol),                % The Ukrainian drinks tea.\n    member([GH,_,green,_,_,_],Sol),                     % The green house is immediately to the right of the ivory house.\n    member([IH,_,ivory,_,_,_],Sol),\n    GH =:= IH + 1,\n    member([_,_,_,snails,_,old_gold],Sol),              % The Old Gold smoker owns snails.\n    member([_,_,yellow,_,_,kools],Sol),                 % Kools are smoked in the yellow house.\n    member([3,_,_,_,milk,_],Sol),                       % Milk is drunk in the middle house.\n    member([1,norwegian,_,_,_,_],Sol),                  % The Norwegian lives in the first house.\n    member([BH,_,_,_,_,chesterfields],Sol),             % The man who smokes Chesterfields lives in the house next to the man with the fox.\n    member([CH,_,_,fox,_,_],Sol),\n    next_to(BH,CH),\n    member([DH,_,_,_,_,kools],Sol),                     % Kools are smoked in the house next to the house where the horse is kept.\n    member([HH,_,_,horse,_,_],Sol),\n    next_to(DH,HH),\n    member([_,_,_,_,orange_juice,lucky_strike],Sol),    % The Lucky Strike smoker drinks organge juice.\n    member([_,japanese,_,_,_,parliaments],Sol),         % The Japanese smokes Parliaments\n    member([NH,norwegian,_,_,_,_],Sol),                 % The Norwegian lives next to the blue house.\n    member([BlH,_,blue,_,_,_],Sol),\n    next_to(NH,BlH),\n    permutation([englishman,spaniard,ukrainian,japanese,norwegian],[N1,N2,N3,N4,N5]),\n    permutation([green,ivory,yellow,blue,red],[C1,C2,C3,C4,C5]),\n    permutation([dog,snails,fox,horse,zebra],[P1,P2,P3,P4,P5]),\n    permutation([coffee,tea,milk,orange_juice,water],[D1,D2,D3,D4,D5]),\n    permutation([old_gold,kools,chesterfields,lucky_strike,parliaments],[S1,S2,S3,S4,S5]).\n\nnext_to(A,B) :- A =:= B - 1.\nnext_to(A,B) :- A =:= B + 1.\n\nwrite_sol(Solution) :-\n    write('+--+------------+------------+------------+-------------+--------------+'),nl,\n    maplist(writef('|%2L|%12L|%12L|%12L|%13L|%14L|\\n'),Solution),\n    write('+--+------------+------------+------------+-------------+--------------+'),nl.\n\nThe program uses a list of lists to represent the houses and applies a set of constraints to determine the correct answer.\nThe einstein/1 predicate defines the structure of the solution as a list of lists called Sol. Each sublist corresponds to a house and contains five variables representing the house number, nationality, color, pet, drink, and cigarette brand.\nThe predicate then uses a set of member/2 and next_to/2 predicates to apply the given clues and constraints to the list of houses. For example, member([_,englishman,red,_,_,_],Sol) specifies that the Englishman lives in the red house, and the predicates member([BH,_,_,_,_,chesterfields],Sol), member([CH,_,_,fox,_,_],Sol), and next_to(BH,CH) specify that the man who smokes Chesterfields lives in the house next to the man with the fox.\nFinally, write_sol/1 outputs the solutions in a formatted table.\nYou can find a copy of this code as a GitHub gist here."
  },
  {
    "objectID": "posts/who-owns-the-zebra/index.html#running-the-solver",
    "href": "posts/who-owns-the-zebra/index.html#running-the-solver",
    "title": "Who Owns the Zebra",
    "section": "Running the solver",
    "text": "Running the solver\nTo run the solver, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the solver by typing:\n[einstein].\nThis loads the einstein.pl file. You can execute the solver which will output the solution to the console:\neinstein.\n+--+------------+------------+------------+-------------+--------------+\n|1 |norwegian   |yellow      |fox         |water        |kools         |\n|2 |ukrainian   |blue        |horse       |tea          |chesterfields |\n|3 |englishman  |red         |snails      |milk         |old_gold      |\n|4 |spaniard    |ivory       |dog         |orange_juice |lucky_strike  |\n|5 |japanese    |green       |zebra       |coffee       |parliaments   |\n+--+------------+------------+------------+-------------+--------------+"
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "",
    "text": "If you’re a programmer then you must be a masochist. After all, what kind of person enjoys staring at a screen for hours on end, squinting at lines of code that seem to blend together like a modern art painting? What kind of person willingly submits themselves to the endless frustration of debugging, only to find that the solution was something as simple as a missing semicolon?\nIf this is you then you’re going to love Brainfuck - the programming language that’s minimalistic to the point of absurdity. With only eight commands, Brainfuck is both challenging and frustrating for even the most experienced programmers.\nIn this post I’ll give a brief overview of the language and then describe how to use the Brainfuck interpreter I wrote."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#how-does-brainfuck-work",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#how-does-brainfuck-work",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "How does Brainfuck work?",
    "text": "How does Brainfuck work?\nBrainfuck programs operate on a memory tape consisting of an array of cells, each containing a single byte. With the tape initially set to zero, Brainfuck programs modify the values in the memory cells, move the pointer left and right along the tape, and perform input and output operations using its eight commands."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#commands",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#commands",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "Commands",
    "text": "Commands\nHere’s a breakdown of the available commands in Brainfuck:\n\n<: Move the pointer one cell to the left.\n>: Move the pointer one cell to the right.\n+: Increment the value of the cell the pointer is pointing to by one.\n-: Decrement the value of the cell the pointer is pointing to by one.\n.: Output the value of the cell the pointer is pointing to.\n,: Input a byte and store its value in the cell the pointer is pointing to.\n[: If the value of the cell the pointer is pointing to is zero, jump forward to the corresponding ] command.\n]: If the value of the cell the pointer is pointing to is non-zero, jump back to the corresponding [ command.\n\nDue to its minimalistic syntax, Brainfuck is used to challenge and amuse programmers. I’ll be honest - programming in Brainfuck is an absolute nightmare. Writing an interpreter for it is easy though."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#using-the-interpreter",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#using-the-interpreter",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "Using the interpreter",
    "text": "Using the interpreter\nYou can download my Brainfuck interpreter here.\nThe Prolog program provided, bf.pl, is the interpreter. It defines a number of Prolog predicates that can be used to interpret Brainfuck programs. The interpreter uses a list to represent the memory tape, and provides predicates for setting and getting the values of cells, as well as for incrementing and decrementing cell values.\nThe main predicate, run(Prog), takes a list of Brainfuck commands as input and interprets the program. It uses a helper predicate, sequence/4, to recursively process each command in the program, updating the memory tape and pointer as necessary.\nMy interpreter isn’t the fastest, but it does have dynamic memory tape length. Most other interpreters have a fixed tape length of (usually) 30,000 cells."
  },
  {
    "objectID": "posts/a-brainfuck-interpreter-in-prolog/index.html#running-brainfuck-programs",
    "href": "posts/a-brainfuck-interpreter-in-prolog/index.html#running-brainfuck-programs",
    "title": "A Brainf*ck Interpreter in Prolog",
    "section": "Running Brainfuck programs",
    "text": "Running Brainfuck programs\nI’ve included a couple of example programs taken from The Brainfuck Archive, including a “Hello World!” program. To execute a Brainfuck program using the interpreter, you can use the run_bf_program/1 predicate which in turn uses the run/1 predicate.\nFor example, to run the “Hello World!” program, you first start the Prolog interpreter (I use SWI-Prolog) by opening up a terminal and typing:\nswipl\nThis will start the Prolog interpreter. You can then load the Brainfuck interpreter by typing:\n[bf].\nThis loads the bf.pl file into the interpreter. You can then run a Brainfuck program using the run_bf_program/1 predicate, like so:\nrun_bf_program('hellobf.bf').\nThis will run the hellobf.bf program and output the famous “Hello World!” message to the console.\nAlternatively, you can execute these three steps at once by typing:\nswipl -s bf.pl -g \"run_bf_program('hellobf.bf'), halt.\"\nAdding halt will make the Prolog interpreter exit after the Brainfuck run_bf_program/1 predicate has finished.\nYou can also run Brainfuck code directly like this:\nswipl -s bf.pl -g \"atom_chars('++++[++++>---<]>-.---[----->+<]>-.+++[->+++<]>++.++++++++.+++++.--------.---[->+++<]>+.-[--->+<]>.++++++++.',Chars), run(Chars), halt.\"\nHappy coding and good luck with your sanity!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aswin van Woudenberg",
    "section": "",
    "text": "Hello, I’m Aswin, a lecturer at NHL Stenden University of Applied Sciences and freelance data scientist. On this website, I share my professional and personal pursuits with a focus on machine learning, logic programming, and software development."
  },
  {
    "objectID": "index.html#work-with-me",
    "href": "index.html#work-with-me",
    "title": "Aswin van Woudenberg",
    "section": "💼 Work With Me",
    "text": "💼 Work With Me\nI am open to consulting and advisory work.\nPlease contact me at reachme@aswinvanwoudenberg.com or connect with me on LinkedIn for potential projects that align with my expertise."
  },
  {
    "objectID": "index.html#posts",
    "href": "index.html#posts",
    "title": "Aswin van Woudenberg",
    "section": "📮 Posts",
    "text": "📮 Posts\n\n\n\n\n\n\nHow to Traverse a Decision Tree and Win at Guess Who?\n\n\n\n\n\n\n\nmachine learning\n\n\ndecision trees\n\n\ngames\n\n\npython\n\n\nsklearn\n\n\n\n\nIn this post I’ll construct a decision tree for playing the game Guess Who and show how to traverse it iteratively.\n\n\n\n\n\n\nJan 4, 2022\n\n\n16 min\n\n\n\n\n\n\n\n\nIcosian Game\n\n\n\n\n\n\n\nprogramming\n\n\nprolog\n\n\npuzzles\n\n\n\n\nA Prolog solver for the Icosian game.\n\n\n\n\n\n\nApr 24, 2020\n\n\n4 min\n\n\n\n\n\n\n\n\nSkyline Puzzle\n\n\n\n\n\n\n\nprogramming\n\n\nprolog\n\n\npuzzles\n\n\n\n\nA Prolog solver for the ‘Skyline’ puzzle.\n\n\n\n\n\n\nOct 4, 2015\n\n\n2 min\n\n\n\n\n\n\n\n\nVBA IBAN Validator\n\n\n\n\n\n\n\nprogramming\n\n\nvba\n\n\n\n\nA function in VBA that checks the validity of an IBAN (International Bank Account Number).\n\n\n\n\n\n\nJul 18, 2013\n\n\n3 min\n\n\n\n\n\n\n\n\nBridge and Torch Puzzle\n\n\n\n\n\n\n\nprogramming\n\n\nprolog\n\n\npuzzles\n\n\n\n\nA Prolog solver for the ‘Bridge and torch’ puzzle.\n\n\n\n\n\n\nJul 3, 2009\n\n\n4 min\n\n\n\n\n\n\n\n\nWho Owns the Zebra\n\n\n\n\n\n\n\nprogramming\n\n\nprolog\n\n\npuzzles\n\n\n\n\nA Prolog solver for the ‘Zebra puzzle’ a.k.a. ‘Einstein’s puzzle’.\n\n\n\n\n\n\nOct 26, 2007\n\n\n5 min\n\n\n\n\n\n\n\n\nA Brainf*ck Interpreter in Prolog\n\n\n\n\n\n\n\nprogramming\n\n\nesoteric\n\n\nprolog\n\n\n\n\nAn esoteric programming language interpreter written in a slightly less esoteric programming language.\n\n\n\n\n\n\nJan 5, 2007\n\n\n3 min\n\n\n\n\n\n\nNo matching items"
  }
]